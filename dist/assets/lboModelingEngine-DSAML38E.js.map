{"version":3,"file":"lboModelingEngine-DSAML38E.js","sources":["../../src/utils/apiLogger.js","../../src/services/lboModelingEngine.js"],"sourcesContent":["/**\n * Enhanced API logging and monitoring utility\n * Provides comprehensive logging, metrics collection, and performance monitoring\n */\n\n// Log levels\nconst LOG_LEVELS = {\n  ERROR: 0,\n  WARN: 1,\n  INFO: 2,\n  DEBUG: 3,\n  TRACE: 4\n};\n\n// Default configuration\nconst DEFAULT_CONFIG = {\n  logLevel: LOG_LEVELS.INFO,\n  enableMetrics: true,\n  enablePerformanceTracking: true,\n  enableErrorTracking: true,\n  maxLogHistory: 1000,\n  metricsRetentionPeriod: 24 * 60 * 60 * 1000 // 24 hours\n};\n\n/**\n * API Logger class for comprehensive monitoring\n */\nclass ApiLogger {\n  constructor(config = {}) {\n    this.config = { ...DEFAULT_CONFIG, ...config };\n    this.logs = [];\n    this.metrics = new Map();\n    this.performanceData = new Map();\n    this.errorCounts = new Map();\n    this.startTime = Date.now();\n  }\n\n  /**\n   * Log a message with specified level\n   * @param {string} level - Log level\n   * @param {string} message - Log message\n   * @param {Object} metadata - Additional metadata\n   */\n  log(level, message, metadata = {}) {\n    const levelValue = LOG_LEVELS[level.toUpperCase()] || LOG_LEVELS.INFO;\n\n    if (levelValue <= this.config.logLevel) {\n      const logEntry = {\n        timestamp: new Date().toISOString(),\n        level: level.toUpperCase(),\n        message,\n        metadata,\n        id: this.generateLogId()\n      };\n\n      this.logs.push(logEntry);\n      this.trimLogs();\n\n      // Console output with formatting\n      this.outputToConsole(logEntry);\n    }\n  }\n\n  /**\n   * Log API request start\n   * @param {string} service - Service name (e.g., 'FMP', 'ALPHA_VANTAGE')\n   * @param {string} endpoint - API endpoint\n   * @param {Object} params - Request parameters\n   * @returns {string} Request ID for tracking\n   */\n  logApiRequest(service, endpoint, params = {}) {\n    const requestId = this.generateRequestId();\n    const startTime = Date.now();\n\n    this.log('INFO', 'ðŸš€ API Request Started', {\n      requestId,\n      service,\n      endpoint,\n      params: this.sanitizeParams(params),\n      startTime\n    });\n\n    // Store performance tracking data\n    this.performanceData.set(requestId, {\n      service,\n      endpoint,\n      startTime,\n      params: this.sanitizeParams(params)\n    });\n\n    return requestId;\n  }\n\n  /**\n   * Log API request completion\n   * @param {string} requestId - Request ID from logApiRequest\n   * @param {boolean} success - Whether request was successful\n   * @param {Object} response - Response data (will be sanitized)\n   * @param {Error} error - Error object if request failed\n   */\n  logApiResponse(requestId, success, response = null, error = null) {\n    const performanceData = this.performanceData.get(requestId);\n    if (!performanceData) {\n      this.log('WARN', 'No performance data found for request', { requestId });\n      return;\n    }\n\n    const endTime = Date.now();\n    const duration = endTime - performanceData.startTime;\n    const { service, endpoint } = performanceData;\n\n    if (success) {\n      this.log('INFO', 'âœ… API Request Completed', {\n        requestId,\n        service,\n        endpoint,\n        duration,\n        responseSize: this.getResponseSize(response),\n        success: true\n      });\n\n      this.recordMetric(service, 'success', 1);\n    } else {\n      this.log('ERROR', 'âŒ API Request Failed', {\n        requestId,\n        service,\n        endpoint,\n        duration,\n        error: error\n          ? {\n            message: error.message,\n            code: error.code,\n            status: error.response?.status,\n            statusText: error.response?.statusText\n          }\n          : null,\n        success: false\n      });\n\n      this.recordMetric(service, 'error', 1);\n      this.recordError(service, error);\n    }\n\n    // Record performance metrics\n    this.recordMetric(service, 'duration', duration);\n    this.recordMetric(service, 'requests', 1);\n\n    // Clean up performance data\n    this.performanceData.delete(requestId);\n  }\n\n  /**\n   * Log rate limiting events\n   * @param {string} service - Service name\n   * @param {number} waitTime - Time to wait in milliseconds\n   * @param {number} remainingRequests - Remaining requests in current period\n   */\n  logRateLimit(service, waitTime, remainingRequests = null) {\n    this.log('WARN', 'â±ï¸ Rate Limit Hit', {\n      service,\n      waitTime,\n      remainingRequests,\n      action: 'throttling'\n    });\n\n    this.recordMetric(service, 'rateLimitHits', 1);\n  }\n\n  /**\n   * Log circuit breaker events\n   * @param {string} service - Service name\n   * @param {string} state - Circuit breaker state\n   * @param {string} action - Action taken\n   * @param {Object} metadata - Additional metadata\n   */\n  logCircuitBreaker(service, state, action, metadata = {}) {\n    const emoji =\n      {\n        OPEN: 'ðŸš¨',\n        HALF_OPEN: 'ðŸ”„',\n        CLOSED: 'âœ…'\n      }[state] || 'ðŸ”§';\n\n    this.log('WARN', `${emoji} Circuit Breaker ${action}`, {\n      service,\n      state,\n      action,\n      ...metadata\n    });\n\n    this.recordMetric(service, `circuitBreaker_${state.toLowerCase()}`, 1);\n  }\n\n  /**\n   * Log cache events\n   * @param {string} operation - Cache operation (hit, miss, set, clear)\n   * @param {string} key - Cache key\n   * @param {Object} metadata - Additional metadata\n   */\n  logCache(operation, key, metadata = {}) {\n    const emoji =\n      {\n        hit: 'ðŸŽ¯',\n        miss: 'âŒ',\n        set: 'ðŸ’¾',\n        clear: 'ðŸ—‘ï¸'\n      }[operation] || 'ðŸ“¦';\n\n    this.log('DEBUG', `${emoji} Cache ${operation.toUpperCase()}`, {\n      operation,\n      key: this.sanitizeCacheKey(key),\n      ...metadata\n    });\n\n    this.recordMetric('cache', operation, 1);\n  }\n\n  /**\n   * Record a metric\n   * @param {string} service - Service name\n   * @param {string} metric - Metric name\n   * @param {number} value - Metric value\n   */\n  recordMetric(service, metric, value) {\n    if (!this.config.enableMetrics) return;\n\n    const key = `${service}.${metric}`;\n    const now = Date.now();\n\n    if (!this.metrics.has(key)) {\n      this.metrics.set(key, {\n        values: [],\n        total: 0,\n        count: 0,\n        min: Infinity,\n        max: -Infinity,\n        avg: 0\n      });\n    }\n\n    const metricData = this.metrics.get(key);\n    metricData.values.push({ value, timestamp: now });\n    metricData.total += value;\n    metricData.count += 1;\n    metricData.min = Math.min(metricData.min, value);\n    metricData.max = Math.max(metricData.max, value);\n    metricData.avg = metricData.total / metricData.count;\n\n    // Clean old metrics\n    this.cleanOldMetrics(key);\n  }\n\n  /**\n   * Record an error for tracking\n   * @param {string} service - Service name\n   * @param {Error} error - Error object\n   */\n  recordError(service, error) {\n    if (!this.config.enableErrorTracking || !error) return;\n\n    const errorKey = `${service}.${error.message}`;\n    const count = this.errorCounts.get(errorKey) || 0;\n    this.errorCounts.set(errorKey, count + 1);\n  }\n\n  /**\n   * Get comprehensive metrics summary\n   * @returns {Object} Metrics summary\n   */\n  getMetrics() {\n    const summary = {\n      uptime: Date.now() - this.startTime,\n      totalLogs: this.logs.length,\n      services: {},\n      cache: {},\n      errors: {}\n    };\n\n    // Process service metrics\n    for (const [key, data] of this.metrics.entries()) {\n      const [service, metric] = key.split('.');\n\n      if (service === 'cache') {\n        summary.cache[metric] = {\n          total: data.total,\n          count: data.count,\n          avg: data.avg\n        };\n      } else {\n        if (!summary.services[service]) {\n          summary.services[service] = {};\n        }\n\n        summary.services[service][metric] = {\n          total: data.total,\n          count: data.count,\n          min: data.min === Infinity ? 0 : data.min,\n          max: data.max === -Infinity ? 0 : data.max,\n          avg: data.avg\n        };\n      }\n    }\n\n    // Process error counts\n    for (const [errorKey, count] of this.errorCounts.entries()) {\n      const [service, ...messageParts] = errorKey.split('.');\n      const message = messageParts.join('.');\n\n      if (!summary.errors[service]) {\n        summary.errors[service] = {};\n      }\n\n      summary.errors[service][message] = count;\n    }\n\n    return summary;\n  }\n\n  /**\n   * Get recent logs\n   * @param {number} limit - Maximum number of logs to return\n   * @param {string} level - Filter by log level\n   * @returns {Array} Recent log entries\n   */\n  getRecentLogs(limit = 100, level = null) {\n    let logs = [...this.logs];\n\n    if (level) {\n      logs = logs.filter(log => log.level === level.toUpperCase());\n    }\n\n    return logs.slice(-limit).reverse();\n  }\n\n  /**\n   * Clear all logs and metrics\n   */\n  clear() {\n    this.logs = [];\n    this.metrics.clear();\n    this.performanceData.clear();\n    this.errorCounts.clear();\n    this.startTime = Date.now();\n  }\n\n  // Private helper methods\n  generateLogId() {\n    return `log_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  generateRequestId() {\n    return `req_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  sanitizeParams(params) {\n    const sanitized = { ...params };\n    // Remove sensitive data\n    if (sanitized.apikey) sanitized.apikey = '***';\n    if (sanitized.api_key) sanitized.api_key = '***';\n    if (sanitized.token) sanitized.token = '***';\n    return sanitized;\n  }\n\n  sanitizeCacheKey(key) {\n    // Truncate long cache keys for readability\n    return key.length > 50 ? `${key.substring(0, 47)}...` : key;\n  }\n\n  getResponseSize(response) {\n    if (!response) return 0;\n    try {\n      return JSON.stringify(response).length;\n    } catch {\n      return 0;\n    }\n  }\n\n  trimLogs() {\n    if (this.logs.length > this.config.maxLogHistory) {\n      this.logs = this.logs.slice(-this.config.maxLogHistory);\n    }\n  }\n\n  cleanOldMetrics(key) {\n    const metricData = this.metrics.get(key);\n    const cutoff = Date.now() - this.config.metricsRetentionPeriod;\n\n    metricData.values = metricData.values.filter(item => item.timestamp > cutoff);\n  }\n\n  outputToConsole(logEntry) {\n    const { level, message, metadata } = logEntry;\n    const timestamp = new Date(logEntry.timestamp).toLocaleTimeString();\n\n    const colors = {\n      ERROR: '\\x1b[31m', // Red\n      WARN: '\\x1b[33m', // Yellow\n      INFO: '\\x1b[36m', // Cyan\n      DEBUG: '\\x1b[35m', // Magenta\n      TRACE: '\\x1b[37m' // White\n    };\n\n    const reset = '\\x1b[0m';\n    const color = colors[level] || colors.INFO;\n\n    console.log(\n      `${color}[${timestamp}] ${level}:${reset} ${message}`,\n      Object.keys(metadata).length > 0 ? metadata : ''\n    );\n  }\n}\n\n// Export singleton instance\nexport const apiLogger = new ApiLogger();\nexport default ApiLogger;\n","import { apiLogger } from '../utils/apiLogger.js';\n\n/**\n * Advanced LBO (Leveraged Buyout) Modeling Engine\n * Provides comprehensive LBO analysis with debt schedules and cash flow waterfalls\n */\nclass LBOModelingEngine {\n  constructor() {\n    this.modelCache = new Map();\n    this.assumptions = this.getDefaultAssumptions();\n  }\n\n  /**\n   * Get default LBO modeling assumptions\n   */\n  getDefaultAssumptions() {\n    return {\n      transaction: {\n        holdingPeriod: 5,\n        managementRollover: 0.1, // 10% management rollover\n        transactionFees: 0.02, // 2% of transaction value\n        financingFees: 0.015 // 1.5% of debt\n      },\n      debt: {\n        seniorDebtMultiple: 4.0,\n        subordinatedDebtMultiple: 1.5,\n        totalDebtMultiple: 5.5,\n        seniorInterestRate: 0.055, // 5.5%\n        subordinatedInterestRate: 0.095, // 9.5%\n        mandatoryPaydown: 0.05, // 5% annually\n        cashSweep: 0.5 // 50% of excess cash\n      },\n      operating: {\n        ebitdaGrowthRate: 0.05, // 5% annually\n        capexAsPercentOfRevenue: 0.03,\n        nwcAsPercentOfRevenue: 0.02,\n        taxRate: 0.21\n      },\n      exit: {\n        exitMultiple: null, // Will use peer average\n        exitMultipleRange: [0.8, 1.2], // 80% to 120% of peer average\n        publicMarketDiscount: 0.1 // 10% discount for public exit\n      },\n      fees: {\n        managementFeeRate: 0.02, // 2% annually\n        carriedInterestRate: 0.2, // 20%\n        hurdle: 0.08 // 8% preferred return\n      }\n    };\n  }\n\n  /**\n   * Build comprehensive LBO model\n   * @param {Object} inputs - LBO model inputs\n   * @param {Object} scenarios - Different scenario assumptions\n   * @returns {Object} Complete LBO analysis\n   */\n  buildLBOModel(inputs, scenarios = {}) {\n    const {\n      symbol,\n      companyName,\n      purchasePrice,\n      ebitda,\n      revenue,\n      marketData = {},\n      peerData = {},\n      assumptions = {}\n    } = inputs;\n\n    // Merge with default assumptions\n    const modelAssumptions = { ...this.assumptions, ...assumptions };\n\n    // Calculate transaction structure\n    const transactionStructure = this.calculateTransactionStructure(\n      purchasePrice,\n      ebitda,\n      modelAssumptions\n    );\n\n    // Build base case scenario\n    const baseCase = this.calculateLBOScenario(\n      inputs,\n      transactionStructure,\n      modelAssumptions,\n      'Base Case'\n    );\n\n    // Build additional scenarios\n    const scenarioResults = {};\n\n    // Upside case: Higher growth and exit multiple\n    if (scenarios.upside !== false) {\n      const upsideAssumptions = {\n        ...modelAssumptions,\n        operating: {\n          ...modelAssumptions.operating,\n          ebitdaGrowthRate: modelAssumptions.operating.ebitdaGrowthRate * 1.3\n        },\n        exit: {\n          ...modelAssumptions.exit,\n          exitMultiple: (modelAssumptions.exit.exitMultiple || 10) * 1.1\n        }\n      };\n      scenarioResults.upside = this.calculateLBOScenario(\n        inputs,\n        transactionStructure,\n        upsideAssumptions,\n        'Upside Case'\n      );\n    }\n\n    // Downside case: Lower growth and exit multiple\n    if (scenarios.downside !== false) {\n      const downsideAssumptions = {\n        ...modelAssumptions,\n        operating: {\n          ...modelAssumptions.operating,\n          ebitdaGrowthRate: modelAssumptions.operating.ebitdaGrowthRate * 0.7\n        },\n        exit: {\n          ...modelAssumptions.exit,\n          exitMultiple: (modelAssumptions.exit.exitMultiple || 10) * 0.9\n        }\n      };\n      scenarioResults.downside = this.calculateLBOScenario(\n        inputs,\n        transactionStructure,\n        downsideAssumptions,\n        'Downside Case'\n      );\n    }\n\n    // Calculate sensitivity analysis\n    const sensitivityAnalysis = this.performLBOSensitivityAnalysis(\n      inputs,\n      transactionStructure,\n      modelAssumptions\n    );\n\n    return {\n      symbol,\n      companyName,\n      modelType: 'LBO',\n      timestamp: new Date().toISOString(),\n      transactionStructure,\n      baseCase,\n      scenarios: scenarioResults,\n      sensitivityAnalysis,\n      assumptions: modelAssumptions,\n      summary: this.generateLBOSummary(baseCase, scenarioResults, transactionStructure)\n    };\n  }\n\n  /**\n   * Calculate transaction structure and financing\n   * @param {number} purchasePrice - Total purchase price\n   * @param {number} ebitda - Current EBITDA\n   * @param {Object} assumptions - Model assumptions\n   * @returns {Object} Transaction structure\n   */\n  calculateTransactionStructure(purchasePrice, ebitda, assumptions) {\n    const { debt, transaction } = assumptions;\n\n    // Calculate debt capacity based on EBITDA multiples\n    const seniorDebt = ebitda * debt.seniorDebtMultiple;\n    const subordinatedDebt = ebitda * debt.subordinatedDebtMultiple;\n    const totalDebt = seniorDebt + subordinatedDebt;\n\n    // Calculate transaction costs\n    const transactionFees = purchasePrice * transaction.transactionFees;\n    const financingFees = totalDebt * transaction.financingFees;\n    const totalUses = purchasePrice + transactionFees + financingFees;\n\n    // Calculate equity requirement (ensure it's positive)\n    const equityContribution = Math.max(totalUses - totalDebt, totalUses * 0.2); // Minimum 20% equity\n    const managementRollover = purchasePrice * transaction.managementRollover;\n    const sponsorEquity = Math.max(equityContribution - managementRollover, 0);\n\n    // Recalculate total debt if equity was adjusted\n    const adjustedTotalDebt = totalUses - equityContribution;\n    const adjustedSeniorDebt = Math.min(seniorDebt, adjustedTotalDebt * 0.8); // Max 80% senior\n    const adjustedSubordinatedDebt = adjustedTotalDebt - adjustedSeniorDebt;\n\n    return {\n      purchasePrice,\n      transactionFees,\n      financingFees,\n      totalUses,\n      seniorDebt: adjustedSeniorDebt,\n      subordinatedDebt: adjustedSubordinatedDebt,\n      totalDebt: adjustedTotalDebt,\n      equityContribution,\n      sponsorEquity,\n      managementRollover,\n      debtToEbitda: adjustedTotalDebt / ebitda,\n      equityToTotalCapital: equityContribution / totalUses\n    };\n  }\n\n  /**\n   * Calculate LBO scenario with detailed cash flow projections\n   * @param {Object} inputs - Model inputs\n   * @param {Object} transactionStructure - Transaction structure\n   * @param {Object} assumptions - Scenario assumptions\n   * @param {string} scenarioName - Name of the scenario\n   * @returns {Object} LBO scenario results\n   */\n  calculateLBOScenario(inputs, transactionStructure, assumptions, scenarioName) {\n    const { ebitda, revenue } = inputs;\n    const { holdingPeriod } = assumptions.transaction;\n\n    // Project operating performance\n    const operatingProjections = this.projectLBOOperatingPerformance(\n      revenue,\n      ebitda,\n      assumptions.operating,\n      holdingPeriod\n    );\n\n    // Calculate debt schedule\n    const debtSchedule = this.calculateDebtSchedule(\n      transactionStructure,\n      operatingProjections,\n      assumptions.debt,\n      holdingPeriod\n    );\n\n    // Calculate cash flow to equity\n    const equityCashFlows = this.calculateEquityCashFlows(\n      operatingProjections,\n      debtSchedule,\n      assumptions\n    );\n\n    // Calculate exit value and returns\n    const exitAnalysis = this.calculateExitAnalysis(\n      operatingProjections[holdingPeriod - 1],\n      debtSchedule[holdingPeriod - 1],\n      transactionStructure,\n      assumptions\n    );\n\n    // Calculate returns metrics\n    const returnsAnalysis = this.calculateReturnsMetrics(\n      transactionStructure.sponsorEquity,\n      equityCashFlows,\n      exitAnalysis.netProceeds,\n      holdingPeriod\n    );\n\n    return {\n      scenarioName,\n      operatingProjections,\n      debtSchedule,\n      equityCashFlows,\n      exitAnalysis,\n      returnsAnalysis,\n      keyMetrics: this.calculateLBOKeyMetrics(\n        transactionStructure,\n        exitAnalysis,\n        returnsAnalysis\n      )\n    };\n  }\n\n  /**\n   * Project operating performance over holding period\n   * @param {number} baseRevenue - Starting revenue\n   * @param {number} baseEbitda - Starting EBITDA\n   * @param {Object} operatingAssumptions - Operating assumptions\n   * @param {number} years - Number of years\n   * @returns {Array} Operating projections\n   */\n  projectLBOOperatingPerformance(baseRevenue, baseEbitda, operatingAssumptions, years) {\n    const projections = [];\n    let currentRevenue = baseRevenue;\n    let currentEbitda = baseEbitda;\n\n    for (let year = 1; year <= years; year++) {\n      // Assume revenue grows in line with EBITDA\n      const ebitdaGrowth = operatingAssumptions.ebitdaGrowthRate;\n      currentEbitda *= (1 + ebitdaGrowth);\n      currentRevenue *= (1 + ebitdaGrowth);\n\n      const ebitdaMargin = currentEbitda / currentRevenue;\n      const capex = currentRevenue * operatingAssumptions.capexAsPercentOfRevenue;\n      const nwcChange = year === 1\n        ? currentRevenue * operatingAssumptions.nwcAsPercentOfRevenue\n        : (currentRevenue - projections[year - 2].revenue) * operatingAssumptions.nwcAsPercentOfRevenue;\n\n      const taxes = currentEbitda * operatingAssumptions.taxRate;\n      const unleveredFCF = currentEbitda - taxes - capex - nwcChange;\n\n      projections.push({\n        year,\n        revenue: currentRevenue,\n        ebitda: currentEbitda,\n        ebitdaMargin,\n        capex,\n        nwcChange,\n        taxes,\n        unleveredFCF\n      });\n    }\n\n    return projections;\n  }\n\n  /**\n   * Calculate enhanced debt schedule with detailed amortization and covenants\n   * @param {Object} transactionStructure - Transaction structure\n   * @param {Array} operatingProjections - Operating projections\n   * @param {Object} debtAssumptions - Debt assumptions\n   * @param {number} years - Number of years\n   * @returns {Array} Enhanced debt schedule with covenant testing\n   */\n  calculateDebtSchedule(transactionStructure, operatingProjections, debtAssumptions, years) {\n    const schedule = [];\n    let seniorDebtBalance = transactionStructure.seniorDebt;\n    let subordinatedDebtBalance = transactionStructure.subordinatedDebt;\n    let revolvingDebtBalance = transactionStructure.revolvingDebt || 0;\n    \n    // Enhanced debt assumptions\n    const enhancedAssumptions = {\n      ...debtAssumptions,\n      revolvingRate: debtAssumptions.revolvingRate || 0.045,\n      minCashBalance: debtAssumptions.minCashBalance || 10000000,\n      // Covenant parameters\n      maxLeverageRatio: debtAssumptions.maxLeverageRatio || 6.0,\n      minCoverageRatio: debtAssumptions.minCoverageRatio || 1.25,\n      maxCapexRatio: debtAssumptions.maxCapexRatio || 0.05\n    };\n\n    for (let year = 1; year <= years; year++) {\n      const projection = operatingProjections[year - 1];\n\n      // Calculate interest expense\n      const seniorInterest = seniorDebtBalance * debtAssumptions.seniorInterestRate;\n      const subordinatedInterest = subordinatedDebtBalance * debtAssumptions.subordinatedInterestRate;\n      const totalInterest = seniorInterest + subordinatedInterest;\n\n      // Calculate available cash for debt paydown\n      const cashAvailableForDebt = projection.unleveredFCF - totalInterest;\n\n      // Mandatory amortization\n      const mandatoryPaydown = Math.min(\n        seniorDebtBalance * debtAssumptions.mandatoryPaydown,\n        seniorDebtBalance\n      );\n\n      // Cash sweep (excess cash after mandatory paydown)\n      const excessCash = Math.max(0, cashAvailableForDebt - mandatoryPaydown);\n      const cashSweep = excessCash * debtAssumptions.cashSweep;\n\n      // Total debt paydown\n      const totalPaydown = mandatoryPaydown + cashSweep;\n      const seniorPaydown = Math.min(totalPaydown, seniorDebtBalance);\n      const subordinatedPaydown = Math.max(0, totalPaydown - seniorPaydown);\n\n      // Update balances\n      seniorDebtBalance = Math.max(0, seniorDebtBalance - seniorPaydown);\n      subordinatedDebtBalance = Math.max(0, subordinatedDebtBalance - subordinatedPaydown);\n\n      // Enhanced debt covenant testing\n      const leverageRatio = (seniorDebtBalance + subordinatedDebtBalance + revolvingDebtBalance) / projection.ebitda;\n      const coverageRatio = projection.ebitda / totalInterest;\n      const capexRatio = (projection.capex || 0) / projection.revenue;\n      \n      const covenantTests = {\n        leverageCompliance: leverageRatio <= enhancedAssumptions.maxLeverageRatio,\n        coverageCompliance: coverageRatio >= enhancedAssumptions.minCoverageRatio,\n        capexCompliance: capexRatio <= enhancedAssumptions.maxCapexRatio,\n        leverageRatio,\n        coverageRatio,\n        capexRatio\n      };\n      \n      // Calculate debt service coverage ratio (DSCR)\n      const dscr = cashAvailableForDebt / (totalInterest + mandatoryPaydown);\n      \n      schedule.push({\n        year,\n        beginningBalance: {\n          senior: year === 1 ? transactionStructure.seniorDebt : schedule[year - 2].endingBalance.senior,\n          subordinated: year === 1 ? transactionStructure.subordinatedDebt : schedule[year - 2].endingBalance.subordinated,\n          revolving: year === 1 ? (transactionStructure.revolvingDebt || 0) : schedule[year - 2].endingBalance.revolving\n        },\n        interestExpense: {\n          senior: seniorInterest,\n          subordinated: subordinatedInterest,\n          revolving: revolvingDebtBalance * enhancedAssumptions.revolvingRate,\n          total: totalInterest + (revolvingDebtBalance * enhancedAssumptions.revolvingRate)\n        },\n        principalPayment: {\n          senior: seniorPaydown,\n          subordinated: subordinatedPaydown,\n          revolving: 0, // Revolving debt typically doesn't amortize\n          total: totalPaydown\n        },\n        endingBalance: {\n          senior: seniorDebtBalance,\n          subordinated: subordinatedDebtBalance,\n          revolving: revolvingDebtBalance,\n          total: seniorDebtBalance + subordinatedDebtBalance + revolvingDebtBalance\n        },\n        cashAvailableForDebt,\n        excessCash: excessCash - cashSweep,\n        mandatoryPaydown,\n        cashSweep,\n        dscr,\n        covenantTests,\n        // Additional debt metrics\n        netDebtToEbitda: (seniorDebtBalance + subordinatedDebtBalance + revolvingDebtBalance) / projection.ebitda,\n        ebitdaToInterest: projection.ebitda / totalInterest\n      });\n    }\n\n    return schedule;\n  }\n\n  /**\n   * Calculate cash flows to equity holders\n   * @param {Array} operatingProjections - Operating projections\n   * @param {Array} debtSchedule - Debt schedule\n   * @param {Object} assumptions - Model assumptions\n   * @returns {Array} Equity cash flows\n   */\n  calculateEquityCashFlows(operatingProjections, debtSchedule, assumptions) {\n    return operatingProjections.map((projection, index) => {\n      const debt = debtSchedule[index];\n      const managementFees = assumptions.fees.managementFeeRate *\n        (assumptions.transaction.sponsorEquity || 0);\n\n      const cashFlowToEquity = debt.excessCash - managementFees;\n\n      return {\n        year: projection.year,\n        unleveredFCF: projection.unleveredFCF,\n        interestExpense: debt.interestExpense.total,\n        principalPayment: debt.principalPayment.total,\n        managementFees,\n        cashFlowToEquity: Math.max(0, cashFlowToEquity)\n      };\n    });\n  }\n\n  /**\n   * Calculate exit analysis and proceeds\n   * @param {Object} finalYearProjection - Final year operating projection\n   * @param {Object} finalYearDebt - Final year debt schedule\n   * @param {Object} transactionStructure - Transaction structure\n   * @param {Object} assumptions - Model assumptions\n   * @returns {Object} Exit analysis\n   */\n  calculateExitAnalysis(finalYearProjection, finalYearDebt, transactionStructure, assumptions) {\n    const exitMultiple = assumptions.exit.exitMultiple || 10;\n    const exitEbitda = finalYearProjection.ebitda;\n\n    const enterpriseValue = exitEbitda * exitMultiple;\n    const totalDebtAtExit = finalYearDebt.endingBalance.total;\n    const grossProceeds = enterpriseValue - totalDebtAtExit;\n\n    // Calculate carried interest\n    const totalReturn = grossProceeds;\n    const investedCapital = transactionStructure.sponsorEquity;\n    const profit = Math.max(0, totalReturn - investedCapital);\n    const carriedInterest = profit * assumptions.fees.carriedInterestRate;\n\n    const netProceeds = grossProceeds - carriedInterest;\n\n    return {\n      exitEbitda,\n      exitMultiple,\n      enterpriseValue,\n      totalDebtAtExit,\n      grossProceeds,\n      carriedInterest,\n      netProceeds,\n      managementProceeds: grossProceeds * (transactionStructure.managementRollover / transactionStructure.equityContribution)\n    };\n  }\n\n  /**\n   * Calculate returns metrics (IRR, MOIC, etc.)\n   * @param {number} initialInvestment - Initial equity investment\n   * @param {Array} equityCashFlows - Annual equity cash flows\n   * @param {number} exitProceeds - Exit proceeds\n   * @param {number} holdingPeriod - Holding period in years\n   * @returns {Object} Returns analysis\n   */\n  calculateReturnsMetrics(initialInvestment, equityCashFlows, exitProceeds, holdingPeriod) {\n    // Validate inputs\n    if (!initialInvestment || initialInvestment <= 0) {\n      return {\n        irr: NaN,\n        moic: NaN,\n        totalCashReturned: 0,\n        initialInvestment: initialInvestment || 0,\n        holdingPeriod,\n        annualizedReturn: NaN\n      };\n    }\n\n    // Calculate total cash flows (negative initial investment, positive distributions and exit)\n    const cashFlows = [-Math.abs(initialInvestment)]; // Ensure initial investment is negative\n\n    // Add annual cash flows\n    equityCashFlows.forEach(cf => {\n      cashFlows.push(cf.cashFlowToEquity || 0);\n    });\n\n    // Add exit proceeds to final year\n    if (cashFlows.length > 1) {\n      cashFlows[cashFlows.length - 1] += (exitProceeds || 0);\n    } else {\n      cashFlows.push(exitProceeds || 0);\n    }\n\n    // Calculate IRR using Newton-Raphson method\n    const irr = this.calculateIRR(cashFlows);\n\n    // Calculate MOIC (Multiple of Invested Capital)\n    const totalCashReturned = equityCashFlows.reduce((sum, cf) => sum + (cf.cashFlowToEquity || 0), 0) + (exitProceeds || 0);\n    const moic = totalCashReturned / Math.abs(initialInvestment);\n\n    return {\n      irr: isNaN(irr) ? 0 : irr, // Default to 0% if IRR calculation fails\n      moic: isNaN(moic) ? 0 : moic,\n      totalCashReturned,\n      initialInvestment: Math.abs(initialInvestment),\n      holdingPeriod,\n      annualizedReturn: isNaN(moic) || moic <= 0 ? 0 : Math.pow(moic, 1 / holdingPeriod) - 1,\n      cashFlows // Include for debugging\n    };\n  }\n\n  /**\n   * Calculate IRR using enhanced Newton-Raphson method with multiple fallbacks\n   * @param {Array} cashFlows - Array of cash flows\n   * @param {Object} options - Calculation options\n   * @returns {number} IRR as decimal\n   */\n  calculateIRR(cashFlows, options = {}) {\n    // Validate cash flows\n    if (!cashFlows || cashFlows.length < 2) {\n      return NaN;\n    }\n\n    // Check if all cash flows are zero\n    if (cashFlows.every(cf => cf === 0)) {\n      return 0;\n    }\n\n    // Check if there's no sign change (no valid IRR)\n    const signChanges = cashFlows.slice(1).reduce((count, cf, i) => {\n      return count + (Math.sign(cf) !== Math.sign(cashFlows[i]) ? 1 : 0);\n    }, 0);\n\n    if (signChanges === 0) {\n      return cashFlows[0] < 0 ? -1 : Infinity; // No valid IRR\n    }\n\n    const { tolerance = 1e-8, maxIterations = 200, initialGuess = 0.1 } = options;\n    \n    // Try Newton-Raphson method first\n    let rate = this.newtonRaphsonIRR(cashFlows, initialGuess, tolerance, maxIterations);\n    \n    // If Newton-Raphson fails, try bisection method\n    if (isNaN(rate) || !isFinite(rate)) {\n      rate = this.bisectionIRR(cashFlows, tolerance, maxIterations);\n    }\n    \n    // If both fail, try Secant method\n    if (isNaN(rate) || !isFinite(rate)) {\n      rate = this.secantIRR(cashFlows, tolerance, maxIterations);\n    }\n\n    return rate;\n  }\n  \n  /**\n   * Newton-Raphson method for IRR calculation\n   */\n  newtonRaphsonIRR(cashFlows, initialGuess, tolerance, maxIterations) {\n    let rate = initialGuess;\n\n    for (let i = 0; i < maxIterations; i++) {\n      let npv = 0;\n      let dnpv = 0;\n\n      for (let j = 0; j < cashFlows.length; j++) {\n        const factor = Math.pow(1 + rate, j);\n        npv += cashFlows[j] / factor;\n        if (j > 0) {\n          dnpv -= j * cashFlows[j] / (factor * (1 + rate));\n        }\n      }\n\n      if (Math.abs(npv) < tolerance) {\n        return rate;\n      }\n\n      if (Math.abs(dnpv) < tolerance) {\n        break; // Avoid division by zero\n      }\n\n      const newRate = rate - npv / dnpv;\n\n      // Prevent rate from going too negative or too high\n      if (newRate < -0.99) {\n        rate = -0.99;\n      } else if (newRate > 50) {\n        rate = 50;\n      } else {\n        rate = newRate;\n      }\n      \n      // Check for convergence\n      if (Math.abs(newRate - rate) < tolerance) {\n        return newRate;\n      }\n      \n      rate = newRate;\n    }\n\n    return rate;\n  }\n  \n  /**\n   * Bisection method for IRR calculation (fallback)\n   */\n  bisectionIRR(cashFlows, tolerance, maxIterations) {\n    let low = -0.99;\n    let high = 5.0;\n    \n    // Check if bounds contain a root\n    const npvLow = this.calculateNPV(cashFlows, low);\n    const npvHigh = this.calculateNPV(cashFlows, high);\n    \n    if (npvLow * npvHigh > 0) {\n      return NaN; // No root in bounds\n    }\n    \n    for (let i = 0; i < maxIterations; i++) {\n      const mid = (low + high) / 2;\n      const npvMid = this.calculateNPV(cashFlows, mid);\n      \n      if (Math.abs(npvMid) < tolerance) {\n        return mid;\n      }\n      \n      if (npvLow * npvMid < 0) {\n        high = mid;\n      } else {\n        low = mid;\n      }\n      \n      if (Math.abs(high - low) < tolerance) {\n        return (low + high) / 2;\n      }\n    }\n    \n    return (low + high) / 2;\n  }\n  \n  /**\n   * Secant method for IRR calculation (second fallback)\n   */\n  secantIRR(cashFlows, tolerance, maxIterations) {\n    let x0 = 0;\n    let x1 = 0.1;\n    \n    for (let i = 0; i < maxIterations; i++) {\n      const f0 = this.calculateNPV(cashFlows, x0);\n      const f1 = this.calculateNPV(cashFlows, x1);\n      \n      if (Math.abs(f1) < tolerance) {\n        return x1;\n      }\n      \n      if (Math.abs(f1 - f0) < tolerance) {\n        break;\n      }\n      \n      const x2 = x1 - f1 * (x1 - x0) / (f1 - f0);\n      \n      if (Math.abs(x2 - x1) < tolerance) {\n        return x2;\n      }\n      \n      x0 = x1;\n      x1 = x2;\n    }\n    \n    return x1;\n  }\n  \n  /**\n   * Calculate NPV for a given discount rate\n   */\n  calculateNPV(cashFlows, rate) {\n    return cashFlows.reduce((npv, cf, index) => {\n      return npv + cf / Math.pow(1 + rate, index);\n    }, 0);\n  }\n\n  /**\n   * Calculate comprehensive LBO metrics summary with advanced ratios\n   * @param {Object} transactionStructure - Transaction structure\n   * @param {Object} exitAnalysis - Exit analysis\n   * @param {Object} returnsAnalysis - Returns analysis\n   * @param {Array} debtSchedule - Debt schedule for additional metrics\n   * @returns {Object} Comprehensive key metrics\n   */\n  calculateLBOKeyMetrics(transactionStructure, exitAnalysis, returnsAnalysis, debtSchedule = []) {\n    // Calculate entry EBITDA multiple\n    const impliedEntryEbitda = transactionStructure.purchasePrice / (transactionStructure.entryMultiple || 10);\n    const actualEntryMultiple = impliedEntryEbitda > 0 ? transactionStructure.purchasePrice / impliedEntryEbitda : null;\n    \n    // Calculate leverage metrics\n    const peakLeverage = Math.max(...debtSchedule.map(d => d.netDebtToEbitda || 0));\n    const minCoverage = Math.min(...debtSchedule.map(d => d.ebitdaToInterest || Infinity));\n    const avgDSCR = debtSchedule.length > 0 ? \n      debtSchedule.reduce((sum, d) => sum + (d.dscr || 0), 0) / debtSchedule.length : 0;\n    \n    // Calculate multiple arbitrage components\n    const multipleExpansion = exitAnalysis.exitMultiple - (actualEntryMultiple || 10);\n    const operationalImprovement = returnsAnalysis.moic - 1 - multipleExpansion;\n    const leverage = transactionStructure.totalDebt / transactionStructure.equityContribution;\n    \n    return {\n      // Entry metrics\n      entryMultiple: actualEntryMultiple,\n      entryLeverage: transactionStructure.debtToEbitda,\n      equityContribution: transactionStructure.equityContribution,\n      debtToEquity: leverage,\n      \n      // Exit metrics\n      exitMultiple: exitAnalysis.exitMultiple,\n      exitLeverage: exitAnalysis.totalDebtAtExit / exitAnalysis.exitEbitda,\n      \n      // Returns metrics\n      irr: returnsAnalysis.irr,\n      moic: returnsAnalysis.moic,\n      totalReturn: returnsAnalysis.totalCashReturned,\n      \n      // Leverage and credit metrics\n      leverageReduction: transactionStructure.totalDebt - exitAnalysis.totalDebtAtExit,\n      peakLeverage,\n      minCoverage,\n      avgDSCR,\n      \n      // Value creation analysis\n      multipleExpansion,\n      operationalImprovement,\n      leverageContribution: leverage > 1 ? (returnsAnalysis.moic - 1) * (leverage - 1) / leverage : 0,\n      \n      // Risk metrics\n      breakdownLeverage: debtSchedule.length > 0 ? \n        Math.max(...debtSchedule.map(d => d.leverageRatio || 0)) : null,\n      covenantBreaches: debtSchedule.filter(d => \n        d.covenantTests && (!d.covenantTests.leverageCompliance || !d.covenantTests.coverageCompliance)\n      ).length,\n      \n      // Efficiency ratios\n      equityEfficiency: returnsAnalysis.totalCashReturned / transactionStructure.equityContribution,\n      timeToRecoverEquity: this.calculateTimeToRecoverEquity(returnsAnalysis.cashFlows, transactionStructure.equityContribution)\n    };\n  }\n  \n  /**\n   * Calculate time to recover initial equity investment\n   * @param {Array} cashFlows - Array of cash flows\n   * @param {number} initialEquity - Initial equity investment\n   * @returns {number} Years to recover equity\n   */\n  calculateTimeToRecoverEquity(cashFlows, initialEquity) {\n    if (!cashFlows || cashFlows.length === 0) return null;\n    \n    let cumulativeCashFlow = 0;\n    \n    for (let i = 1; i < cashFlows.length; i++) { // Skip initial investment\n      cumulativeCashFlow += cashFlows[i];\n      if (cumulativeCashFlow >= initialEquity) {\n        return i;\n      }\n    }\n    \n    return null; // Equity not recovered within holding period\n  }\n\n  /**\n   * Perform sensitivity analysis on key LBO variables\n   * @param {Object} inputs - Model inputs\n   * @param {Object} transactionStructure - Transaction structure\n   * @param {Object} baseAssumptions - Base case assumptions\n   * @returns {Object} Sensitivity analysis results\n   */\n  performLBOSensitivityAnalysis(inputs, transactionStructure, baseAssumptions) {\n    const sensitivityVars = {\n      ebitdaGrowthRate: [-0.02, -0.01, 0, 0.01, 0.02],\n      exitMultiple: [-1, -0.5, 0, 0.5, 1],\n      debtMultiple: [-0.5, -0.25, 0, 0.25, 0.5]\n    };\n\n    const results = {};\n\n    Object.entries(sensitivityVars).forEach(([variable, variations]) => {\n      results[variable] = variations.map(variation => {\n        const adjustedAssumptions = { ...baseAssumptions };\n\n        if (variable === 'ebitdaGrowthRate') {\n          adjustedAssumptions.operating.ebitdaGrowthRate += variation;\n        } else if (variable === 'exitMultiple') {\n          adjustedAssumptions.exit.exitMultiple = (adjustedAssumptions.exit.exitMultiple || 10) + variation;\n        } else if (variable === 'debtMultiple') {\n          // Adjust transaction structure for debt multiple sensitivity\n          const newDebtMultiple = transactionStructure.debtToEbitda + variation;\n          const adjustedStructure = {\n            ...transactionStructure,\n            totalDebt: (inputs.ebitda * newDebtMultiple),\n            debtToEbitda: newDebtMultiple\n          };\n          adjustedStructure.equityContribution = transactionStructure.totalUses - adjustedStructure.totalDebt;\n        }\n\n        try {\n          const scenario = this.calculateLBOScenario(inputs, transactionStructure, adjustedAssumptions, `${variable}_${variation}`);\n          return {\n            variation,\n            irr: scenario.returnsAnalysis.irr,\n            moic: scenario.returnsAnalysis.moic\n          };\n        } catch (error) {\n          return {\n            variation,\n            irr: null,\n            moic: null,\n            error: error.message\n          };\n        }\n      });\n    });\n\n    return results;\n  }\n\n  /**\n   * Generate LBO model summary\n   * @param {Object} baseCase - Base case results\n   * @param {Object} scenarios - Scenario results\n   * @param {Object} transactionStructure - Transaction structure\n   * @returns {Object} Model summary\n   */\n  generateLBOSummary(baseCase, scenarios, transactionStructure) {\n    const allScenarios = [baseCase, ...Object.values(scenarios)];\n    const irrs = allScenarios.map(s => s.returnsAnalysis.irr).filter(irr => irr !== null);\n    const moics = allScenarios.map(s => s.returnsAnalysis.moic).filter(moic => moic !== null);\n\n    return {\n      returnRange: {\n        irrMin: Math.min(...irrs),\n        irrMax: Math.max(...irrs),\n        irrAverage: irrs.reduce((sum, irr) => sum + irr, 0) / irrs.length,\n        moicMin: Math.min(...moics),\n        moicMax: Math.max(...moics),\n        moicAverage: moics.reduce((sum, moic) => sum + moic, 0) / moics.length\n      },\n      investmentHighlights: this.generateInvestmentHighlights(baseCase, transactionStructure),\n      riskFactors: this.generateRiskFactors(baseCase, transactionStructure)\n    };\n  }\n\n  /**\n   * Generate investment highlights\n   * @param {Object} baseCase - Base case results\n   * @param {Object} transactionStructure - Transaction structure\n   * @returns {Array} Investment highlights\n   */\n  generateInvestmentHighlights(baseCase, transactionStructure) {\n    const highlights = [];\n    const irr = baseCase.returnsAnalysis.irr;\n    const moic = baseCase.returnsAnalysis.moic;\n\n    if (irr > 0.2) {\n      highlights.push(`Strong projected IRR of ${(irr * 100).toFixed(1)}%`);\n    }\n\n    if (moic > 2.5) {\n      highlights.push(`Attractive multiple of ${moic.toFixed(1)}x invested capital`);\n    }\n\n    if (transactionStructure.debtToEbitda < 5) {\n      highlights.push(`Conservative leverage at ${transactionStructure.debtToEbitda.toFixed(1)}x EBITDA`);\n    }\n\n    return highlights;\n  }\n\n  /**\n   * Generate risk factors\n   * @param {Object} baseCase - Base case results\n   * @param {Object} transactionStructure - Transaction structure\n   * @returns {Array} Risk factors\n   */\n  generateRiskFactors(baseCase, transactionStructure) {\n    const risks = [];\n\n    if (transactionStructure.debtToEbitda > 6) {\n      risks.push(`High leverage at ${transactionStructure.debtToEbitda.toFixed(1)}x EBITDA`);\n    }\n\n    if (baseCase.returnsAnalysis.irr < 0.15) {\n      risks.push(`Below-target IRR of ${(baseCase.returnsAnalysis.irr * 100).toFixed(1)}%`);\n    }\n\n    return risks;\n  }\n}\n\n// Export singleton instance\nexport const lboModelingEngine = new LBOModelingEngine();\nexport default LBOModelingEngine;\n"],"names":["LOG_LEVELS","ERROR","WARN","INFO","DEBUG","TRACE","DEFAULT_CONFIG","logLevel","enableMetrics","enablePerformanceTracking","enableErrorTracking","maxLogHistory","metricsRetentionPeriod","apiLogger","constructor","config","this","logs","metrics","Map","performanceData","errorCounts","startTime","Date","now","log","level","message","metadata","toUpperCase","logEntry","timestamp","toISOString","id","generateLogId","push","trimLogs","outputToConsole","logApiRequest","service","endpoint","params","requestId","generateRequestId","sanitizeParams","set","logApiResponse","success","response","error","get","duration","responseSize","getResponseSize","recordMetric","code","status","statusText","recordError","delete","logRateLimit","waitTime","remainingRequests","action","logCircuitBreaker","state","emoji","OPEN","HALF_OPEN","CLOSED","toLowerCase","logCache","operation","key","hit","miss","clear","sanitizeCacheKey","metric","value","has","values","total","count","min","Infinity","max","avg","metricData","Math","cleanOldMetrics","errorKey","getMetrics","summary","uptime","totalLogs","length","services","cache","errors","data","entries","split","messageParts","join","getRecentLogs","limit","filter","slice","reverse","random","toString","substr","sanitized","apikey","api_key","token","substring","JSON","stringify","cutoff","item","toLocaleTimeString","lboModelingEngine","modelCache","assumptions","getDefaultAssumptions","transaction","holdingPeriod","managementRollover","transactionFees","financingFees","debt","seniorDebtMultiple","subordinatedDebtMultiple","totalDebtMultiple","seniorInterestRate","subordinatedInterestRate","mandatoryPaydown","cashSweep","operating","ebitdaGrowthRate","capexAsPercentOfRevenue","nwcAsPercentOfRevenue","taxRate","exit","exitMultiple","exitMultipleRange","publicMarketDiscount","fees","managementFeeRate","carriedInterestRate","hurdle","buildLBOModel","inputs","scenarios","symbol","companyName","purchasePrice","ebitda","revenue","marketData","peerData","modelAssumptions","transactionStructure","calculateTransactionStructure","baseCase","calculateLBOScenario","scenarioResults","upside","upsideAssumptions","downside","downsideAssumptions","sensitivityAnalysis","performLBOSensitivityAnalysis","modelType","generateLBOSummary","seniorDebt","totalDebt","totalUses","equityContribution","sponsorEquity","adjustedTotalDebt","adjustedSeniorDebt","subordinatedDebt","debtToEbitda","equityToTotalCapital","scenarioName","operatingProjections","projectLBOOperatingPerformance","debtSchedule","calculateDebtSchedule","equityCashFlows","calculateEquityCashFlows","exitAnalysis","calculateExitAnalysis","returnsAnalysis","calculateReturnsMetrics","netProceeds","keyMetrics","calculateLBOKeyMetrics","baseRevenue","baseEbitda","operatingAssumptions","years","projections","currentRevenue","currentEbitda","year","ebitdaGrowth","ebitdaMargin","capex","nwcChange","taxes","unleveredFCF","debtAssumptions","schedule","seniorDebtBalance","subordinatedDebtBalance","revolvingDebtBalance","revolvingDebt","enhancedAssumptions","revolvingRate","minCashBalance","maxLeverageRatio","minCoverageRatio","maxCapexRatio","projection","seniorInterest","subordinatedInterest","totalInterest","cashAvailableForDebt","excessCash","totalPaydown","seniorPaydown","subordinatedPaydown","leverageRatio","coverageRatio","capexRatio","covenantTests","leverageCompliance","coverageCompliance","capexCompliance","dscr","beginningBalance","senior","endingBalance","subordinated","revolving","interestExpense","principalPayment","netDebtToEbitda","ebitdaToInterest","map","index","managementFees","cashFlowToEquity","finalYearProjection","finalYearDebt","exitEbitda","enterpriseValue","totalDebtAtExit","grossProceeds","totalReturn","investedCapital","carriedInterest","managementProceeds","initialInvestment","exitProceeds","irr","NaN","moic","totalCashReturned","annualizedReturn","cashFlows","abs","forEach","cf","calculateIRR","reduce","sum","isNaN","pow","options","every","i","sign","tolerance","maxIterations","initialGuess","rate","newtonRaphsonIRR","isFinite","bisectionIRR","secantIRR","npv","dnpv","j","factor","newRate","low","high","npvLow","calculateNPV","mid","npvMid","x0","x1","f0","f1","x2","impliedEntryEbitda","entryMultiple","actualEntryMultiple","peakLeverage","d","minCoverage","avgDSCR","multipleExpansion","operationalImprovement","leverage","entryLeverage","debtToEquity","exitLeverage","leverageReduction","leverageContribution","breakdownLeverage","covenantBreaches","equityEfficiency","timeToRecoverEquity","calculateTimeToRecoverEquity","initialEquity","cumulativeCashFlow","baseAssumptions","results","Object","debtMultiple","variable","variations","variation","adjustedAssumptions","newDebtMultiple","adjustedStructure","scenario","allScenarios","irrs","s","moics","returnRange","irrMin","irrMax","irrAverage","moicMin","moicMax","moicAverage","investmentHighlights","generateInvestmentHighlights","riskFactors","generateRiskFactors","highlights","toFixed","risks"],"mappings":"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"}