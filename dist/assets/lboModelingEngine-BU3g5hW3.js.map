{"version":3,"file":"lboModelingEngine-BU3g5hW3.js","sources":["../../src/services/lboModelingEngine.js"],"sourcesContent":["// import { apiLogger } from '../utils/apiLogger.js';\n\n/**\n * Advanced LBO (Leveraged Buyout) Modeling Engine\n * Provides comprehensive LBO analysis with debt schedules and cash flow waterfalls\n */\nclass LBOModelingEngine {\n  constructor() {\n    this.modelCache = new Map();\n    this.assumptions = this.getDefaultAssumptions();\n  }\n\n  /**\n   * Get default LBO modeling assumptions\n   */\n  getDefaultAssumptions() {\n    return {\n      transaction: {\n        holdingPeriod: 5,\n        managementRollover: 0.1, // 10% management rollover\n        transactionFees: 0.02, // 2% of transaction value\n        financingFees: 0.015 // 1.5% of debt\n      },\n      debt: {\n        seniorDebtMultiple: 4.0,\n        subordinatedDebtMultiple: 1.5,\n        totalDebtMultiple: 5.5,\n        seniorInterestRate: 0.055, // 5.5%\n        subordinatedInterestRate: 0.095, // 9.5%\n        mandatoryPaydown: 0.05, // 5% annually\n        cashSweep: 0.5 // 50% of excess cash\n      },\n      operating: {\n        ebitdaGrowthRate: 0.05, // 5% annually\n        capexAsPercentOfRevenue: 0.03,\n        nwcAsPercentOfRevenue: 0.02,\n        taxRate: 0.21\n      },\n      exit: {\n        exitMultiple: null, // Will use peer average\n        exitMultipleRange: [0.8, 1.2], // 80% to 120% of peer average\n        publicMarketDiscount: 0.1 // 10% discount for public exit\n      },\n      fees: {\n        managementFeeRate: 0.02, // 2% annually\n        carriedInterestRate: 0.2, // 20%\n        hurdle: 0.08 // 8% preferred return\n      }\n    };\n  }\n\n  /**\n   * Build comprehensive LBO model\n   * @param {Object} inputs - LBO model inputs\n   * @param {Object} scenarios - Different scenario assumptions\n   * @returns {Object} Complete LBO analysis\n   */\n  buildLBOModel(inputs, scenarios = {}) {\n    const {\n      symbol,\n      companyName,\n      purchasePrice,\n      ebitda,\n      revenue: _revenue,\n      marketData: _marketData = {},\n      peerData: _peerData = {},\n      assumptions = {}\n    } = inputs;\n\n    // Merge with default assumptions\n    const modelAssumptions = { ...this.assumptions, ...assumptions };\n\n    // Calculate transaction structure\n    const transactionStructure = this.calculateTransactionStructure(\n      purchasePrice,\n      ebitda,\n      modelAssumptions\n    );\n\n    // Build base case scenario\n    const baseCase = this.calculateLBOScenario(\n      inputs,\n      transactionStructure,\n      modelAssumptions,\n      'Base Case'\n    );\n\n    // Build additional scenarios\n    const scenarioResults = {};\n\n    // Upside case: Higher growth and exit multiple\n    if (scenarios.upside !== false) {\n      const upsideAssumptions = {\n        ...modelAssumptions,\n        operating: {\n          ...modelAssumptions.operating,\n          ebitdaGrowthRate: modelAssumptions.operating.ebitdaGrowthRate * 1.3\n        },\n        exit: {\n          ...modelAssumptions.exit,\n          exitMultiple: (modelAssumptions.exit.exitMultiple || 10) * 1.1\n        }\n      };\n      scenarioResults.upside = this.calculateLBOScenario(\n        inputs,\n        transactionStructure,\n        upsideAssumptions,\n        'Upside Case'\n      );\n    }\n\n    // Downside case: Lower growth and exit multiple\n    if (scenarios.downside !== false) {\n      const downsideAssumptions = {\n        ...modelAssumptions,\n        operating: {\n          ...modelAssumptions.operating,\n          ebitdaGrowthRate: modelAssumptions.operating.ebitdaGrowthRate * 0.7\n        },\n        exit: {\n          ...modelAssumptions.exit,\n          exitMultiple: (modelAssumptions.exit.exitMultiple || 10) * 0.9\n        }\n      };\n      scenarioResults.downside = this.calculateLBOScenario(\n        inputs,\n        transactionStructure,\n        downsideAssumptions,\n        'Downside Case'\n      );\n    }\n\n    // Calculate sensitivity analysis\n    const sensitivityAnalysis = this.performLBOSensitivityAnalysis(\n      inputs,\n      transactionStructure,\n      modelAssumptions\n    );\n\n    return {\n      symbol,\n      companyName,\n      modelType: 'LBO',\n      timestamp: new Date().toISOString(),\n      transactionStructure,\n      baseCase,\n      scenarios: scenarioResults,\n      sensitivityAnalysis,\n      assumptions: modelAssumptions,\n      summary: this.generateLBOSummary(baseCase, scenarioResults, transactionStructure)\n    };\n  }\n\n  /**\n   * Calculate transaction structure and financing\n   * @param {number} purchasePrice - Total purchase price\n   * @param {number} ebitda - Current EBITDA\n   * @param {Object} assumptions - Model assumptions\n   * @returns {Object} Transaction structure\n   */\n  calculateTransactionStructure(purchasePrice, ebitda, assumptions) {\n    const { debt, transaction } = assumptions;\n\n    // Calculate debt capacity based on EBITDA multiples\n    const seniorDebt = ebitda * debt.seniorDebtMultiple;\n    const subordinatedDebt = ebitda * debt.subordinatedDebtMultiple;\n    const totalDebt = seniorDebt + subordinatedDebt;\n\n    // Calculate transaction costs\n    const transactionFees = purchasePrice * transaction.transactionFees;\n    const financingFees = totalDebt * transaction.financingFees;\n    const totalUses = purchasePrice + transactionFees + financingFees;\n\n    // Calculate equity requirement (ensure it's positive)\n    const equityContribution = Math.max(totalUses - totalDebt, totalUses * 0.2); // Minimum 20% equity\n    const managementRollover = purchasePrice * transaction.managementRollover;\n    const sponsorEquity = Math.max(equityContribution - managementRollover, 0);\n\n    // Recalculate total debt if equity was adjusted\n    const adjustedTotalDebt = totalUses - equityContribution;\n    const adjustedSeniorDebt = Math.min(seniorDebt, adjustedTotalDebt * 0.8); // Max 80% senior\n    const adjustedSubordinatedDebt = adjustedTotalDebt - adjustedSeniorDebt;\n\n    return {\n      purchasePrice,\n      transactionFees,\n      financingFees,\n      totalUses,\n      seniorDebt: adjustedSeniorDebt,\n      subordinatedDebt: adjustedSubordinatedDebt,\n      totalDebt: adjustedTotalDebt,\n      equityContribution,\n      sponsorEquity,\n      managementRollover,\n      debtToEbitda: adjustedTotalDebt / ebitda,\n      equityToTotalCapital: equityContribution / totalUses\n    };\n  }\n\n  /**\n   * Calculate LBO scenario with detailed cash flow projections\n   * @param {Object} inputs - Model inputs\n   * @param {Object} transactionStructure - Transaction structure\n   * @param {Object} assumptions - Scenario assumptions\n   * @param {string} scenarioName - Name of the scenario\n   * @returns {Object} LBO scenario results\n   */\n  calculateLBOScenario(inputs, transactionStructure, assumptions, scenarioName) {\n    const { ebitda, revenue } = inputs;\n    const { holdingPeriod } = assumptions.transaction;\n\n    // Project operating performance\n    const operatingProjections = this.projectLBOOperatingPerformance(\n      revenue,\n      ebitda,\n      assumptions.operating,\n      holdingPeriod\n    );\n\n    // Calculate debt schedule\n    const debtSchedule = this.calculateDebtSchedule(\n      transactionStructure,\n      operatingProjections,\n      assumptions.debt,\n      holdingPeriod\n    );\n\n    // Calculate cash flow to equity\n    const equityCashFlows = this.calculateEquityCashFlows(\n      operatingProjections,\n      debtSchedule,\n      assumptions\n    );\n\n    // Calculate exit value and returns\n    const exitAnalysis = this.calculateExitAnalysis(\n      operatingProjections[holdingPeriod - 1],\n      debtSchedule[holdingPeriod - 1],\n      transactionStructure,\n      assumptions\n    );\n\n    // Calculate returns metrics\n    const returnsAnalysis = this.calculateReturnsMetrics(\n      transactionStructure.sponsorEquity,\n      equityCashFlows,\n      exitAnalysis.netProceeds,\n      holdingPeriod\n    );\n\n    return {\n      scenarioName,\n      operatingProjections,\n      debtSchedule,\n      equityCashFlows,\n      exitAnalysis,\n      returnsAnalysis,\n      keyMetrics: this.calculateLBOKeyMetrics(\n        transactionStructure,\n        exitAnalysis,\n        returnsAnalysis\n      )\n    };\n  }\n\n  /**\n   * Project operating performance over holding period\n   * @param {number} baseRevenue - Starting revenue\n   * @param {number} baseEbitda - Starting EBITDA\n   * @param {Object} operatingAssumptions - Operating assumptions\n   * @param {number} years - Number of years\n   * @returns {Array} Operating projections\n   */\n  projectLBOOperatingPerformance(baseRevenue, baseEbitda, operatingAssumptions, years) {\n    const projections = [];\n    let currentRevenue = baseRevenue;\n    let currentEbitda = baseEbitda;\n\n    for (let year = 1; year <= years; year++) {\n      // Assume revenue grows in line with EBITDA\n      const ebitdaGrowth = operatingAssumptions.ebitdaGrowthRate;\n      currentEbitda *= (1 + ebitdaGrowth);\n      currentRevenue *= (1 + ebitdaGrowth);\n\n      const ebitdaMargin = currentEbitda / currentRevenue;\n      const capex = currentRevenue * operatingAssumptions.capexAsPercentOfRevenue;\n      const nwcChange = year === 1\n        ? currentRevenue * operatingAssumptions.nwcAsPercentOfRevenue\n        : (currentRevenue - projections[year - 2].revenue) * operatingAssumptions.nwcAsPercentOfRevenue;\n\n      const taxes = currentEbitda * operatingAssumptions.taxRate;\n      const unleveredFCF = currentEbitda - taxes - capex - nwcChange;\n\n      projections.push({\n        year,\n        revenue: currentRevenue,\n        ebitda: currentEbitda,\n        ebitdaMargin,\n        capex,\n        nwcChange,\n        taxes,\n        unleveredFCF\n      });\n    }\n\n    return projections;\n  }\n\n  /**\n   * Calculate enhanced debt schedule with detailed amortization and covenants\n   * @param {Object} transactionStructure - Transaction structure\n   * @param {Array} operatingProjections - Operating projections\n   * @param {Object} debtAssumptions - Debt assumptions\n   * @param {number} years - Number of years\n   * @returns {Array} Enhanced debt schedule with covenant testing\n   */\n  calculateDebtSchedule(transactionStructure, operatingProjections, debtAssumptions, years) {\n    const schedule = [];\n    let seniorDebtBalance = transactionStructure.seniorDebt;\n    let subordinatedDebtBalance = transactionStructure.subordinatedDebt;\n    const revolvingDebtBalance = transactionStructure.revolvingDebt || 0;\n\n    // Enhanced debt assumptions\n    const enhancedAssumptions = {\n      ...debtAssumptions,\n      revolvingRate: debtAssumptions.revolvingRate || 0.045,\n      minCashBalance: debtAssumptions.minCashBalance || 10000000,\n      // Covenant parameters\n      maxLeverageRatio: debtAssumptions.maxLeverageRatio || 6.0,\n      minCoverageRatio: debtAssumptions.minCoverageRatio || 1.25,\n      maxCapexRatio: debtAssumptions.maxCapexRatio || 0.05\n    };\n\n    for (let year = 1; year <= years; year++) {\n      const projection = operatingProjections[year - 1];\n\n      // Calculate interest expense\n      const seniorInterest = seniorDebtBalance * debtAssumptions.seniorInterestRate;\n      const subordinatedInterest = subordinatedDebtBalance * debtAssumptions.subordinatedInterestRate;\n      const totalInterest = seniorInterest + subordinatedInterest;\n\n      // Calculate available cash for debt paydown\n      const cashAvailableForDebt = projection.unleveredFCF - totalInterest;\n\n      // Mandatory amortization\n      const mandatoryPaydown = Math.min(\n        seniorDebtBalance * debtAssumptions.mandatoryPaydown,\n        seniorDebtBalance\n      );\n\n      // Cash sweep (excess cash after mandatory paydown)\n      const excessCash = Math.max(0, cashAvailableForDebt - mandatoryPaydown);\n      const cashSweep = excessCash * debtAssumptions.cashSweep;\n\n      // Total debt paydown\n      const totalPaydown = mandatoryPaydown + cashSweep;\n      const seniorPaydown = Math.min(totalPaydown, seniorDebtBalance);\n      const subordinatedPaydown = Math.max(0, totalPaydown - seniorPaydown);\n\n      // Update balances\n      seniorDebtBalance = Math.max(0, seniorDebtBalance - seniorPaydown);\n      subordinatedDebtBalance = Math.max(0, subordinatedDebtBalance - subordinatedPaydown);\n\n      // Enhanced debt covenant testing\n      const leverageRatio = (seniorDebtBalance + subordinatedDebtBalance + revolvingDebtBalance) / projection.ebitda;\n      const coverageRatio = projection.ebitda / totalInterest;\n      const capexRatio = (projection.capex || 0) / projection.revenue;\n\n      const covenantTests = {\n        leverageCompliance: leverageRatio <= enhancedAssumptions.maxLeverageRatio,\n        coverageCompliance: coverageRatio >= enhancedAssumptions.minCoverageRatio,\n        capexCompliance: capexRatio <= enhancedAssumptions.maxCapexRatio,\n        leverageRatio,\n        coverageRatio,\n        capexRatio\n      };\n\n      // Calculate debt service coverage ratio (DSCR)\n      const dscr = cashAvailableForDebt / (totalInterest + mandatoryPaydown);\n\n      schedule.push({\n        year,\n        beginningBalance: {\n          senior: year === 1 ? transactionStructure.seniorDebt : schedule[year - 2].endingBalance.senior,\n          subordinated: year === 1 ? transactionStructure.subordinatedDebt : schedule[year - 2].endingBalance.subordinated,\n          revolving: year === 1 ? (transactionStructure.revolvingDebt || 0) : schedule[year - 2].endingBalance.revolving\n        },\n        interestExpense: {\n          senior: seniorInterest,\n          subordinated: subordinatedInterest,\n          revolving: revolvingDebtBalance * enhancedAssumptions.revolvingRate,\n          total: totalInterest + (revolvingDebtBalance * enhancedAssumptions.revolvingRate)\n        },\n        principalPayment: {\n          senior: seniorPaydown,\n          subordinated: subordinatedPaydown,\n          revolving: 0, // Revolving debt typically doesn't amortize\n          total: totalPaydown\n        },\n        endingBalance: {\n          senior: seniorDebtBalance,\n          subordinated: subordinatedDebtBalance,\n          revolving: revolvingDebtBalance,\n          total: seniorDebtBalance + subordinatedDebtBalance + revolvingDebtBalance\n        },\n        cashAvailableForDebt,\n        excessCash: excessCash - cashSweep,\n        mandatoryPaydown,\n        cashSweep,\n        dscr,\n        covenantTests,\n        // Additional debt metrics\n        netDebtToEbitda: (seniorDebtBalance + subordinatedDebtBalance + revolvingDebtBalance) / projection.ebitda,\n        ebitdaToInterest: projection.ebitda / totalInterest\n      });\n    }\n\n    return schedule;\n  }\n\n  /**\n   * Calculate cash flows to equity holders\n   * @param {Array} operatingProjections - Operating projections\n   * @param {Array} debtSchedule - Debt schedule\n   * @param {Object} assumptions - Model assumptions\n   * @returns {Array} Equity cash flows\n   */\n  calculateEquityCashFlows(operatingProjections, debtSchedule, assumptions) {\n    return operatingProjections.map((projection, index) => {\n      const debt = debtSchedule[index];\n      const managementFees = assumptions.fees.managementFeeRate *\n        (assumptions.transaction.sponsorEquity || 0);\n\n      const cashFlowToEquity = debt.excessCash - managementFees;\n\n      return {\n        year: projection.year,\n        unleveredFCF: projection.unleveredFCF,\n        interestExpense: debt.interestExpense.total,\n        principalPayment: debt.principalPayment.total,\n        managementFees,\n        cashFlowToEquity: Math.max(0, cashFlowToEquity)\n      };\n    });\n  }\n\n  /**\n   * Calculate exit analysis and proceeds\n   * @param {Object} finalYearProjection - Final year operating projection\n   * @param {Object} finalYearDebt - Final year debt schedule\n   * @param {Object} transactionStructure - Transaction structure\n   * @param {Object} assumptions - Model assumptions\n   * @returns {Object} Exit analysis\n   */\n  calculateExitAnalysis(finalYearProjection, finalYearDebt, transactionStructure, assumptions) {\n    const exitMultiple = assumptions.exit.exitMultiple || 10;\n    const exitEbitda = finalYearProjection.ebitda;\n\n    const enterpriseValue = exitEbitda * exitMultiple;\n    const totalDebtAtExit = finalYearDebt.endingBalance.total;\n    const grossProceeds = enterpriseValue - totalDebtAtExit;\n\n    // Calculate carried interest\n    const totalReturn = grossProceeds;\n    const investedCapital = transactionStructure.sponsorEquity;\n    const profit = Math.max(0, totalReturn - investedCapital);\n    const carriedInterest = profit * assumptions.fees.carriedInterestRate;\n\n    const netProceeds = grossProceeds - carriedInterest;\n\n    return {\n      exitEbitda,\n      exitMultiple,\n      enterpriseValue,\n      totalDebtAtExit,\n      grossProceeds,\n      carriedInterest,\n      netProceeds,\n      managementProceeds: grossProceeds * (transactionStructure.managementRollover / transactionStructure.equityContribution)\n    };\n  }\n\n  /**\n   * Calculate returns metrics (IRR, MOIC, etc.)\n   * @param {number} initialInvestment - Initial equity investment\n   * @param {Array} equityCashFlows - Annual equity cash flows\n   * @param {number} exitProceeds - Exit proceeds\n   * @param {number} holdingPeriod - Holding period in years\n   * @returns {Object} Returns analysis\n   */\n  calculateReturnsMetrics(initialInvestment, equityCashFlows, exitProceeds, holdingPeriod) {\n    // Validate inputs\n    if (!initialInvestment || initialInvestment <= 0) {\n      return {\n        irr: NaN,\n        moic: NaN,\n        totalCashReturned: 0,\n        initialInvestment: initialInvestment || 0,\n        holdingPeriod,\n        annualizedReturn: NaN\n      };\n    }\n\n    // Calculate total cash flows (negative initial investment, positive distributions and exit)\n    const cashFlows = [-Math.abs(initialInvestment)]; // Ensure initial investment is negative\n\n    // Add annual cash flows\n    equityCashFlows.forEach(cf => {\n      cashFlows.push(cf.cashFlowToEquity || 0);\n    });\n\n    // Add exit proceeds to final year\n    if (cashFlows.length > 1) {\n      cashFlows[cashFlows.length - 1] += (exitProceeds || 0);\n    } else {\n      cashFlows.push(exitProceeds || 0);\n    }\n\n    // Calculate IRR using Newton-Raphson method\n    const irr = this.calculateIRR(cashFlows);\n\n    // Calculate MOIC (Multiple of Invested Capital)\n    const totalCashReturned = equityCashFlows.reduce((sum, cf) => sum + (cf.cashFlowToEquity || 0), 0) + (exitProceeds || 0);\n    const moic = totalCashReturned / Math.abs(initialInvestment);\n\n    return {\n      irr: isNaN(irr) ? 0 : irr, // Default to 0% if IRR calculation fails\n      moic: isNaN(moic) ? 0 : moic,\n      totalCashReturned,\n      initialInvestment: Math.abs(initialInvestment),\n      holdingPeriod,\n      annualizedReturn: isNaN(moic) || moic <= 0 ? 0 : Math.pow(moic, 1 / holdingPeriod) - 1,\n      cashFlows // Include for debugging\n    };\n  }\n\n  /**\n   * Calculate IRR using enhanced Newton-Raphson method with multiple fallbacks\n   * @param {Array} cashFlows - Array of cash flows\n   * @param {Object} options - Calculation options\n   * @returns {number} IRR as decimal\n   */\n  calculateIRR(cashFlows, options = {}) {\n    // Validate cash flows\n    if (!cashFlows || cashFlows.length < 2) {\n      return NaN;\n    }\n\n    // Check if all cash flows are zero\n    if (cashFlows.every(cf => cf === 0)) {\n      return 0;\n    }\n\n    // Check if there's no sign change (no valid IRR)\n    const signChanges = cashFlows.slice(1).reduce((count, cf, i) => {\n      return count + (Math.sign(cf) !== Math.sign(cashFlows[i]) ? 1 : 0);\n    }, 0);\n\n    if (signChanges === 0) {\n      return cashFlows[0] < 0 ? -1 : Infinity; // No valid IRR\n    }\n\n    const { tolerance = 1e-8, maxIterations = 200, initialGuess = 0.1 } = options;\n\n    // Try Newton-Raphson method first\n    let rate = this.newtonRaphsonIRR(cashFlows, initialGuess, tolerance, maxIterations);\n\n    // If Newton-Raphson fails, try bisection method\n    if (isNaN(rate) || !isFinite(rate)) {\n      rate = this.bisectionIRR(cashFlows, tolerance, maxIterations);\n    }\n\n    // If both fail, try Secant method\n    if (isNaN(rate) || !isFinite(rate)) {\n      rate = this.secantIRR(cashFlows, tolerance, maxIterations);\n    }\n\n    return rate;\n  }\n\n  /**\n   * Newton-Raphson method for IRR calculation\n   */\n  newtonRaphsonIRR(cashFlows, initialGuess, tolerance, maxIterations) {\n    let rate = initialGuess;\n\n    for (let i = 0; i < maxIterations; i++) {\n      let npv = 0;\n      let dnpv = 0;\n\n      for (let j = 0; j < cashFlows.length; j++) {\n        const factor = Math.pow(1 + rate, j);\n        npv += cashFlows[j] / factor;\n        if (j > 0) {\n          dnpv -= j * cashFlows[j] / (factor * (1 + rate));\n        }\n      }\n\n      if (Math.abs(npv) < tolerance) {\n        return rate;\n      }\n\n      if (Math.abs(dnpv) < tolerance) {\n        break; // Avoid division by zero\n      }\n\n      const newRate = rate - npv / dnpv;\n\n      // Check for convergence before updating rate\n      if (Math.abs(newRate - rate) < tolerance) {\n        return newRate;\n      }\n\n      // Prevent rate from going too negative or too high\n      if (newRate < -0.99) {\n        rate = -0.99;\n      } else if (newRate > 50) {\n        rate = 50;\n      } else {\n        rate = newRate;\n      }\n    }\n\n    return rate;\n  }\n\n  /**\n   * Bisection method for IRR calculation (fallback)\n   */\n  bisectionIRR(cashFlows, tolerance, maxIterations) {\n    let low = -0.99;\n    let high = 5.0;\n\n    // Check if bounds contain a root\n    const npvLow = this.calculateNPV(cashFlows, low);\n    const npvHigh = this.calculateNPV(cashFlows, high);\n\n    if (npvLow * npvHigh > 0) {\n      return NaN; // No root in bounds\n    }\n\n    for (let i = 0; i < maxIterations; i++) {\n      const mid = (low + high) / 2;\n      const npvMid = this.calculateNPV(cashFlows, mid);\n\n      if (Math.abs(npvMid) < tolerance) {\n        return mid;\n      }\n\n      if (npvLow * npvMid < 0) {\n        high = mid;\n      } else {\n        low = mid;\n      }\n\n      if (Math.abs(high - low) < tolerance) {\n        return (low + high) / 2;\n      }\n    }\n\n    return (low + high) / 2;\n  }\n\n  /**\n   * Secant method for IRR calculation (second fallback)\n   */\n  secantIRR(cashFlows, tolerance, maxIterations) {\n    let x0 = 0;\n    let x1 = 0.1;\n\n    for (let i = 0; i < maxIterations; i++) {\n      const f0 = this.calculateNPV(cashFlows, x0);\n      const f1 = this.calculateNPV(cashFlows, x1);\n\n      if (Math.abs(f1) < tolerance) {\n        return x1;\n      }\n\n      if (Math.abs(f1 - f0) < tolerance) {\n        break;\n      }\n\n      const x2 = x1 - f1 * (x1 - x0) / (f1 - f0);\n\n      if (Math.abs(x2 - x1) < tolerance) {\n        return x2;\n      }\n\n      x0 = x1;\n      x1 = x2;\n    }\n\n    return x1;\n  }\n\n  /**\n   * Calculate NPV for a given discount rate\n   */\n  calculateNPV(cashFlows, rate) {\n    return cashFlows.reduce((npv, cf, index) => {\n      return npv + cf / Math.pow(1 + rate, index);\n    }, 0);\n  }\n\n  /**\n   * Calculate comprehensive LBO metrics summary with advanced ratios\n   * @param {Object} transactionStructure - Transaction structure\n   * @param {Object} exitAnalysis - Exit analysis\n   * @param {Object} returnsAnalysis - Returns analysis\n   * @param {Array} debtSchedule - Debt schedule for additional metrics\n   * @returns {Object} Comprehensive key metrics\n   */\n  calculateLBOKeyMetrics(transactionStructure, exitAnalysis, returnsAnalysis, debtSchedule = []) {\n    // Calculate entry EBITDA multiple\n    const impliedEntryEbitda = transactionStructure.purchasePrice / (transactionStructure.entryMultiple || 10);\n    const actualEntryMultiple = impliedEntryEbitda > 0 ? transactionStructure.purchasePrice / impliedEntryEbitda : null;\n\n    // Calculate leverage metrics\n    const peakLeverage = Math.max(...debtSchedule.map(d => d.netDebtToEbitda || 0));\n    const minCoverage = Math.min(...debtSchedule.map(d => d.ebitdaToInterest || Infinity));\n    const avgDSCR = debtSchedule.length > 0 ?\n      debtSchedule.reduce((sum, d) => sum + (d.dscr || 0), 0) / debtSchedule.length : 0;\n\n    // Calculate multiple arbitrage components\n    const multipleExpansion = exitAnalysis.exitMultiple - (actualEntryMultiple || 10);\n    const operationalImprovement = returnsAnalysis.moic - 1 - multipleExpansion;\n    const leverage = transactionStructure.totalDebt / transactionStructure.equityContribution;\n\n    return {\n      // Entry metrics\n      entryMultiple: actualEntryMultiple,\n      entryLeverage: transactionStructure.debtToEbitda,\n      equityContribution: transactionStructure.equityContribution,\n      debtToEquity: leverage,\n\n      // Exit metrics\n      exitMultiple: exitAnalysis.exitMultiple,\n      exitLeverage: exitAnalysis.totalDebtAtExit / exitAnalysis.exitEbitda,\n\n      // Returns metrics\n      irr: returnsAnalysis.irr,\n      moic: returnsAnalysis.moic,\n      totalReturn: returnsAnalysis.totalCashReturned,\n\n      // Leverage and credit metrics\n      leverageReduction: transactionStructure.totalDebt - exitAnalysis.totalDebtAtExit,\n      peakLeverage,\n      minCoverage,\n      avgDSCR,\n\n      // Value creation analysis\n      multipleExpansion,\n      operationalImprovement,\n      leverageContribution: leverage > 1 ? (returnsAnalysis.moic - 1) * (leverage - 1) / leverage : 0,\n\n      // Risk metrics\n      breakdownLeverage: debtSchedule.length > 0 ?\n        Math.max(...debtSchedule.map(d => d.leverageRatio || 0)) : null,\n      covenantBreaches: debtSchedule.filter(d =>\n        d.covenantTests && (!d.covenantTests.leverageCompliance || !d.covenantTests.coverageCompliance)\n      ).length,\n\n      // Efficiency ratios\n      equityEfficiency: returnsAnalysis.totalCashReturned / transactionStructure.equityContribution,\n      timeToRecoverEquity: this.calculateTimeToRecoverEquity(returnsAnalysis.cashFlows, transactionStructure.equityContribution)\n    };\n  }\n\n  /**\n   * Calculate time to recover initial equity investment\n   * @param {Array} cashFlows - Array of cash flows\n   * @param {number} initialEquity - Initial equity investment\n   * @returns {number} Years to recover equity\n   */\n  calculateTimeToRecoverEquity(cashFlows, initialEquity) {\n    if (!cashFlows || cashFlows.length === 0) return null;\n\n    let cumulativeCashFlow = 0;\n\n    for (let i = 1; i < cashFlows.length; i++) { // Skip initial investment\n      cumulativeCashFlow += cashFlows[i];\n      if (cumulativeCashFlow >= initialEquity) {\n        return i;\n      }\n    }\n\n    return null; // Equity not recovered within holding period\n  }\n\n  /**\n   * Perform sensitivity analysis on key LBO variables\n   * @param {Object} inputs - Model inputs\n   * @param {Object} transactionStructure - Transaction structure\n   * @param {Object} baseAssumptions - Base case assumptions\n   * @returns {Object} Sensitivity analysis results\n   */\n  performLBOSensitivityAnalysis(inputs, transactionStructure, baseAssumptions) {\n    const sensitivityVars = {\n      ebitdaGrowthRate: [-0.02, -0.01, 0, 0.01, 0.02],\n      exitMultiple: [-1, -0.5, 0, 0.5, 1],\n      debtMultiple: [-0.5, -0.25, 0, 0.25, 0.5]\n    };\n\n    const results = {};\n\n    Object.entries(sensitivityVars).forEach(([variable, variations]) => {\n      results[variable] = variations.map(variation => {\n        const adjustedAssumptions = { ...baseAssumptions };\n\n        if (variable === 'ebitdaGrowthRate') {\n          adjustedAssumptions.operating.ebitdaGrowthRate += variation;\n        } else if (variable === 'exitMultiple') {\n          adjustedAssumptions.exit.exitMultiple = (adjustedAssumptions.exit.exitMultiple || 10) + variation;\n        } else if (variable === 'debtMultiple') {\n          // Adjust transaction structure for debt multiple sensitivity\n          const newDebtMultiple = transactionStructure.debtToEbitda + variation;\n          const adjustedStructure = {\n            ...transactionStructure,\n            totalDebt: (inputs.ebitda * newDebtMultiple),\n            debtToEbitda: newDebtMultiple\n          };\n          adjustedStructure.equityContribution = transactionStructure.totalUses - adjustedStructure.totalDebt;\n        }\n\n        try {\n          const scenario = this.calculateLBOScenario(inputs, transactionStructure, adjustedAssumptions, `${variable}_${variation}`);\n          return {\n            variation,\n            irr: scenario.returnsAnalysis.irr,\n            moic: scenario.returnsAnalysis.moic\n          };\n        } catch (error) {\n          return {\n            variation,\n            irr: null,\n            moic: null,\n            error: error.message\n          };\n        }\n      });\n    });\n\n    return results;\n  }\n\n  /**\n   * Generate LBO model summary\n   * @param {Object} baseCase - Base case results\n   * @param {Object} scenarios - Scenario results\n   * @param {Object} transactionStructure - Transaction structure\n   * @returns {Object} Model summary\n   */\n  generateLBOSummary(baseCase, scenarios, transactionStructure) {\n    const allScenarios = [baseCase, ...Object.values(scenarios)];\n    const irrs = allScenarios.map(s => s.returnsAnalysis.irr).filter(irr => irr !== null);\n    const moics = allScenarios.map(s => s.returnsAnalysis.moic).filter(moic => moic !== null);\n\n    return {\n      returnRange: {\n        irrMin: Math.min(...irrs),\n        irrMax: Math.max(...irrs),\n        irrAverage: irrs.reduce((sum, irr) => sum + irr, 0) / irrs.length,\n        moicMin: Math.min(...moics),\n        moicMax: Math.max(...moics),\n        moicAverage: moics.reduce((sum, moic) => sum + moic, 0) / moics.length\n      },\n      investmentHighlights: this.generateInvestmentHighlights(baseCase, transactionStructure),\n      riskFactors: this.generateRiskFactors(baseCase, transactionStructure)\n    };\n  }\n\n  /**\n   * Generate investment highlights\n   * @param {Object} baseCase - Base case results\n   * @param {Object} transactionStructure - Transaction structure\n   * @returns {Array} Investment highlights\n   */\n  generateInvestmentHighlights(baseCase, transactionStructure) {\n    const highlights = [];\n    const irr = baseCase.returnsAnalysis.irr;\n    const moic = baseCase.returnsAnalysis.moic;\n\n    if (irr > 0.2) {\n      highlights.push(`Strong projected IRR of ${(irr * 100).toFixed(1)}%`);\n    }\n\n    if (moic > 2.5) {\n      highlights.push(`Attractive multiple of ${moic.toFixed(1)}x invested capital`);\n    }\n\n    if (transactionStructure.debtToEbitda < 5) {\n      highlights.push(`Conservative leverage at ${transactionStructure.debtToEbitda.toFixed(1)}x EBITDA`);\n    }\n\n    return highlights;\n  }\n\n  /**\n   * Generate risk factors\n   * @param {Object} baseCase - Base case results\n   * @param {Object} transactionStructure - Transaction structure\n   * @returns {Array} Risk factors\n   */\n  generateRiskFactors(baseCase, transactionStructure) {\n    const risks = [];\n\n    if (transactionStructure.debtToEbitda > 6) {\n      risks.push(`High leverage at ${transactionStructure.debtToEbitda.toFixed(1)}x EBITDA`);\n    }\n\n    if (baseCase.returnsAnalysis.irr < 0.15) {\n      risks.push(`Below-target IRR of ${(baseCase.returnsAnalysis.irr * 100).toFixed(1)}%`);\n    }\n\n    return risks;\n  }\n}\n\n// Export singleton instance\nexport const lboModelingEngine = new LBOModelingEngine();\nexport default LBOModelingEngine;\n"],"names":["lboModelingEngine","constructor","this","modelCache","Map","assumptions","getDefaultAssumptions","transaction","holdingPeriod","managementRollover","transactionFees","financingFees","debt","seniorDebtMultiple","subordinatedDebtMultiple","totalDebtMultiple","seniorInterestRate","subordinatedInterestRate","mandatoryPaydown","cashSweep","operating","ebitdaGrowthRate","capexAsPercentOfRevenue","nwcAsPercentOfRevenue","taxRate","exit","exitMultiple","exitMultipleRange","publicMarketDiscount","fees","managementFeeRate","carriedInterestRate","hurdle","buildLBOModel","inputs","scenarios","symbol","companyName","purchasePrice","ebitda","revenue","_revenue","marketData","_marketData","peerData","_peerData","modelAssumptions","transactionStructure","calculateTransactionStructure","baseCase","calculateLBOScenario","scenarioResults","upside","upsideAssumptions","downside","downsideAssumptions","sensitivityAnalysis","performLBOSensitivityAnalysis","modelType","timestamp","Date","toISOString","summary","generateLBOSummary","seniorDebt","totalDebt","totalUses","equityContribution","Math","max","sponsorEquity","adjustedTotalDebt","adjustedSeniorDebt","min","subordinatedDebt","debtToEbitda","equityToTotalCapital","scenarioName","operatingProjections","projectLBOOperatingPerformance","debtSchedule","calculateDebtSchedule","equityCashFlows","calculateEquityCashFlows","exitAnalysis","calculateExitAnalysis","returnsAnalysis","calculateReturnsMetrics","netProceeds","keyMetrics","calculateLBOKeyMetrics","baseRevenue","baseEbitda","operatingAssumptions","years","projections","currentRevenue","currentEbitda","year","ebitdaGrowth","ebitdaMargin","capex","nwcChange","taxes","unleveredFCF","push","debtAssumptions","schedule","seniorDebtBalance","subordinatedDebtBalance","revolvingDebtBalance","revolvingDebt","enhancedAssumptions","revolvingRate","minCashBalance","maxLeverageRatio","minCoverageRatio","maxCapexRatio","projection","seniorInterest","subordinatedInterest","totalInterest","cashAvailableForDebt","excessCash","totalPaydown","seniorPaydown","subordinatedPaydown","leverageRatio","coverageRatio","capexRatio","covenantTests","leverageCompliance","coverageCompliance","capexCompliance","dscr","beginningBalance","senior","endingBalance","subordinated","revolving","interestExpense","total","principalPayment","netDebtToEbitda","ebitdaToInterest","map","index","managementFees","cashFlowToEquity","finalYearProjection","finalYearDebt","exitEbitda","enterpriseValue","totalDebtAtExit","grossProceeds","totalReturn","investedCapital","carriedInterest","managementProceeds","initialInvestment","exitProceeds","irr","NaN","moic","totalCashReturned","annualizedReturn","cashFlows","abs","forEach","cf","length","calculateIRR","reduce","sum","isNaN","pow","options","every","slice","count","i","sign","Infinity","tolerance","maxIterations","initialGuess","rate","newtonRaphsonIRR","isFinite","bisectionIRR","secantIRR","npv","dnpv","j","factor","newRate","low","high","npvLow","calculateNPV","mid","npvMid","x0","x1","f0","f1","x2","impliedEntryEbitda","entryMultiple","actualEntryMultiple","peakLeverage","d","minCoverage","avgDSCR","multipleExpansion","operationalImprovement","leverage","entryLeverage","debtToEquity","exitLeverage","leverageReduction","leverageContribution","breakdownLeverage","covenantBreaches","filter","equityEfficiency","timeToRecoverEquity","calculateTimeToRecoverEquity","initialEquity","cumulativeCashFlow","baseAssumptions","results","Object","entries","debtMultiple","variable","variations","variation","adjustedAssumptions","newDebtMultiple","adjustedStructure","scenario","error","message","allScenarios","values","irrs","s","moics","returnRange","irrMin","irrMax","irrAverage","moicMin","moicMax","moicAverage","investmentHighlights","generateInvestmentHighlights","riskFactors","generateRiskFactors","highlights","toFixed","risks"],"mappings":"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"}