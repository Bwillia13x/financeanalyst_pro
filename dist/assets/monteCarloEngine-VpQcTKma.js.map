{"version":3,"file":"monteCarloEngine-VpQcTKma.js","sources":["../../src/services/monteCarloEngine.js"],"sourcesContent":["import { apiLogger } from '../utils/apiLogger.js';\n\n/**\n * Monte Carlo Simulation Engine\n * Provides advanced statistical modeling and risk analysis\n */\nclass MonteCarloEngine {\n  constructor() {\n    this.workers = [];\n    this.isRunning = false;\n    this.currentSimulation = null;\n  }\n\n  /**\n   * Run Monte Carlo simulation for DCF analysis\n   * @param {Object} baseInputs - Base DCF inputs\n   * @param {Object} distributions - Variable distributions\n   * @param {Object} options - Simulation options\n   * @returns {Promise<Object>} Simulation results\n   */\n  async runDCFSimulation(baseInputs, distributions, options = {}) {\n    const {\n      iterations = 10000,\n      confidenceLevel = 0.95,\n      correlationMatrix = null,\n      randomSeed = null\n    } = options;\n\n    apiLogger.log('INFO', 'Starting DCF Monte Carlo simulation', {\n      iterations,\n      variables: Object.keys(distributions).length\n    });\n\n    this.isRunning = true;\n    const startTime = Date.now();\n\n    try {\n      // Initialize random number generator\n      if (randomSeed) {\n        this.setSeed(randomSeed);\n      }\n\n      // Generate correlated random samples\n      const samples = this.generateCorrelatedSamples(\n        distributions,\n        iterations,\n        correlationMatrix\n      );\n\n      // Run simulation iterations\n      const results = [];\n      const progressCallback = options.onProgress;\n\n      for (let i = 0; i < iterations; i++) {\n        if (!this.isRunning) {\n          throw new Error('Simulation cancelled');\n        }\n\n        // Create scenario inputs\n        const scenarioInputs = this.createScenarioInputs(baseInputs, samples[i], distributions);\n\n        // Calculate DCF for this scenario\n        const dcfResult = this.calculateDCFScenario(scenarioInputs);\n        results.push({\n          iteration: i + 1,\n          pricePerShare: dcfResult.pricePerShare,\n          enterpriseValue: dcfResult.enterpriseValue,\n          upside: dcfResult.upside,\n          inputs: scenarioInputs\n        });\n\n        // Report progress\n        if (progressCallback && i % Math.floor(iterations / 100) === 0) {\n          progressCallback((i / iterations) * 100);\n        }\n      }\n\n      // Analyze results\n      const analysis = this.analyzeResults(results, confidenceLevel);\n\n      const endTime = Date.now();\n      apiLogger.log('INFO', 'DCF Monte Carlo simulation completed', {\n        iterations,\n        duration: endTime - startTime,\n        meanPrice: analysis.statistics.mean\n      });\n\n      return {\n        type: 'DCF_MONTE_CARLO',\n        timestamp: new Date().toISOString(),\n        parameters: { iterations, confidenceLevel, randomSeed },\n        results,\n        analysis,\n        duration: endTime - startTime\n      };\n\n    } catch (error) {\n      this.isRunning = false;\n      apiLogger.log('ERROR', 'DCF Monte Carlo simulation failed', { error: error.message });\n      throw error;\n    } finally {\n      this.isRunning = false;\n    }\n  }\n\n  /**\n   * Run Monte Carlo simulation for LBO analysis\n   * @param {Object} baseInputs - Base LBO inputs\n   * @param {Object} distributions - Variable distributions\n   * @param {Object} options - Simulation options\n   * @returns {Promise<Object>} Simulation results\n   */\n  async runLBOSimulation(baseInputs, distributions, options = {}) {\n    const {\n      iterations = 10000,\n      confidenceLevel = 0.95,\n      correlationMatrix = null,\n      randomSeed = null\n    } = options;\n\n    apiLogger.log('INFO', 'Starting LBO Monte Carlo simulation', {\n      iterations,\n      variables: Object.keys(distributions).length\n    });\n\n    this.isRunning = true;\n    const startTime = Date.now();\n\n    try {\n      if (randomSeed) {\n        this.setSeed(randomSeed);\n      }\n\n      const samples = this.generateCorrelatedSamples(\n        distributions,\n        iterations,\n        correlationMatrix\n      );\n\n      const results = [];\n      const progressCallback = options.onProgress;\n\n      for (let i = 0; i < iterations; i++) {\n        if (!this.isRunning) {\n          throw new Error('Simulation cancelled');\n        }\n\n        const scenarioInputs = this.createScenarioInputs(baseInputs, samples[i], distributions);\n        const lboResult = this.calculateLBOScenario(scenarioInputs);\n\n        results.push({\n          iteration: i + 1,\n          irr: lboResult.irr,\n          moic: lboResult.moic,\n          totalReturn: lboResult.totalReturn,\n          inputs: scenarioInputs\n        });\n\n        if (progressCallback && i % Math.floor(iterations / 100) === 0) {\n          progressCallback((i / iterations) * 100);\n        }\n      }\n\n      const analysis = this.analyzeResults(results, confidenceLevel, ['irr', 'moic', 'totalReturn']);\n\n      const endTime = Date.now();\n      apiLogger.log('INFO', 'LBO Monte Carlo simulation completed', {\n        iterations,\n        duration: endTime - startTime,\n        meanIRR: analysis.statistics.irr?.mean\n      });\n\n      return {\n        type: 'LBO_MONTE_CARLO',\n        timestamp: new Date().toISOString(),\n        parameters: { iterations, confidenceLevel, randomSeed },\n        results,\n        analysis,\n        duration: endTime - startTime\n      };\n\n    } catch (error) {\n      this.isRunning = false;\n      apiLogger.log('ERROR', 'LBO Monte Carlo simulation failed', { error: error.message });\n      throw error;\n    } finally {\n      this.isRunning = false;\n    }\n  }\n\n  /**\n   * Generate correlated random samples using Cholesky decomposition\n   * @param {Object} distributions - Variable distributions\n   * @param {number} iterations - Number of iterations\n   * @param {Array} correlationMatrix - Correlation matrix\n   * @returns {Array} Array of sample sets\n   */\n  generateCorrelatedSamples(distributions, iterations, correlationMatrix) {\n    const variables = Object.keys(distributions);\n    const numVars = variables.length;\n    const samples = [];\n\n    // Generate independent samples first\n    const independentSamples = [];\n    for (let i = 0; i < iterations; i++) {\n      const sample = {};\n      variables.forEach(variable => {\n        const dist = distributions[variable];\n        sample[variable] = this.sampleFromDistribution(dist);\n      });\n      independentSamples.push(sample);\n    }\n\n    // Apply correlation if matrix is provided\n    if (correlationMatrix && correlationMatrix.length === numVars) {\n      const choleskyMatrix = this.choleskyDecomposition(correlationMatrix);\n\n      for (let i = 0; i < iterations; i++) {\n        const correlatedSample = {};\n        const independentValues = variables.map(v => independentSamples[i][v]);\n        const correlatedValues = this.applyCorrelation(independentValues, choleskyMatrix);\n\n        variables.forEach((variable, index) => {\n          correlatedSample[variable] = correlatedValues[index];\n        });\n\n        samples.push(correlatedSample);\n      }\n    } else {\n      samples.push(...independentSamples);\n    }\n\n    return samples;\n  }\n\n  /**\n   * Sample from a probability distribution with enhanced types\n   * @param {Object} distribution - Distribution parameters\n   * @returns {number} Random sample\n   */\n  sampleFromDistribution(distribution) {\n    const { type, parameters } = distribution;\n\n    switch (type) {\n      case 'normal':\n        return this.normalRandom(parameters.mean, parameters.stdDev);\n\n      case 'lognormal': {\n        const normalSample = this.normalRandom(parameters.mu, parameters.sigma);\n        return Math.exp(normalSample);\n      }\n\n      case 'uniform':\n        return parameters.min + Math.random() * (parameters.max - parameters.min);\n\n      case 'triangular':\n        return this.triangularRandom(parameters.min, parameters.mode, parameters.max);\n\n      case 'beta':\n        return this.betaRandom(parameters.alpha, parameters.beta);\n\n      case 'exponential':\n        return this.exponentialRandom(parameters.lambda);\n\n      case 'weibull':\n        return this.weibullRandom(parameters.shape, parameters.scale);\n\n      case 'pareto':\n        return this.paretoRandom(parameters.scale, parameters.shape);\n\n      case 'student_t':\n        return this.studentTRandom(parameters.df);\n\n      case 'chi_squared':\n        return this.chiSquaredRandom(parameters.df);\n\n      default:\n        throw new Error(`Unsupported distribution type: ${type}`);\n    }\n  }\n\n  /**\n   * Generate exponential random variable\n   * @param {number} lambda - Rate parameter\n   * @returns {number} Exponential random variable\n   */\n  exponentialRandom(lambda) {\n    return -Math.log(1 - Math.random()) / lambda;\n  }\n\n  /**\n   * Generate Weibull random variable\n   * @param {number} shape - Shape parameter (k)\n   * @param {number} scale - Scale parameter (lambda)\n   * @returns {number} Weibull random variable\n   */\n  weibullRandom(shape, scale) {\n    const u = Math.random();\n    return scale * Math.pow(-Math.log(1 - u), 1 / shape);\n  }\n\n  /**\n   * Generate Pareto random variable\n   * @param {number} scale - Scale parameter (xm)\n   * @param {number} shape - Shape parameter (alpha)\n   * @returns {number} Pareto random variable\n   */\n  paretoRandom(scale, shape) {\n    const u = Math.random();\n    return scale / Math.pow(u, 1 / shape);\n  }\n\n  /**\n   * Generate Student's t random variable\n   * @param {number} df - Degrees of freedom\n   * @returns {number} Student's t random variable\n   */\n  studentTRandom(df) {\n    if (df <= 0) throw new Error('Degrees of freedom must be positive');\n\n    const normal = this.normalRandom(0, 1);\n    const chiSq = this.chiSquaredRandom(df);\n\n    return normal / Math.sqrt(chiSq / df);\n  }\n\n  /**\n   * Generate Chi-squared random variable\n   * @param {number} df - Degrees of freedom\n   * @returns {number} Chi-squared random variable\n   */\n  chiSquaredRandom(df) {\n    if (df <= 0) throw new Error('Degrees of freedom must be positive');\n\n    return this.gammaRandom(df / 2) * 2;\n  }\n\n  /**\n   * Generate normal random variable using Box-Muller transform\n   * @param {number} mean - Mean\n   * @param {number} stdDev - Standard deviation\n   * @returns {number} Normal random variable\n   */\n  normalRandom(mean = 0, stdDev = 1) {\n    if (this.spareNormal !== undefined) {\n      const spare = this.spareNormal;\n      this.spareNormal = undefined;\n      return spare * stdDev + mean;\n    }\n\n    const u1 = Math.random();\n    const u2 = Math.random();\n    const z0 = Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);\n    const z1 = Math.sqrt(-2 * Math.log(u1)) * Math.sin(2 * Math.PI * u2);\n\n    this.spareNormal = z1;\n    return z0 * stdDev + mean;\n  }\n\n  /**\n   * Generate triangular random variable\n   * @param {number} min - Minimum value\n   * @param {number} mode - Mode value\n   * @param {number} max - Maximum value\n   * @returns {number} Triangular random variable\n   */\n  triangularRandom(min, mode, max) {\n    const u = Math.random();\n    const c = (mode - min) / (max - min);\n\n    if (u < c) {\n      return min + Math.sqrt(u * (max - min) * (mode - min));\n    } else {\n      return max - Math.sqrt((1 - u) * (max - min) * (max - mode));\n    }\n  }\n\n  /**\n   * Generate beta random variable\n   * @param {number} alpha - Alpha parameter\n   * @param {number} beta - Beta parameter\n   * @returns {number} Beta random variable\n   */\n  betaRandom(alpha, beta) {\n    const x = this.gammaRandom(alpha);\n    const y = this.gammaRandom(beta);\n    return x / (x + y);\n  }\n\n  /**\n   * Generate gamma random variable\n   * @param {number} shape - Shape parameter\n   * @returns {number} Gamma random variable\n   */\n  gammaRandom(shape) {\n    // Marsaglia and Tsang's method for shape >= 1\n    if (shape >= 1) {\n      const d = shape - 1 / 3;\n      const c = 1 / Math.sqrt(9 * d);\n\n      while (true) {\n        let x, v;\n        do {\n          x = this.normalRandom();\n          v = 1 + c * x;\n        } while (v <= 0);\n\n        v = v * v * v;\n        const u = Math.random();\n\n        if (u < 1 - 0.0331 * x * x * x * x) {\n          return d * v;\n        }\n\n        if (Math.log(u) < 0.5 * x * x + d * (1 - v + Math.log(v))) {\n          return d * v;\n        }\n      }\n    } else {\n      // For shape < 1, use transformation\n      return this.gammaRandom(shape + 1) * Math.pow(Math.random(), 1 / shape);\n    }\n  }\n\n  /**\n   * Perform Cholesky decomposition\n   * @param {Array} matrix - Correlation matrix\n   * @returns {Array} Lower triangular matrix\n   */\n  choleskyDecomposition(matrix) {\n    const n = matrix.length;\n    const L = Array(n).fill().map(() => Array(n).fill(0));\n\n    for (let i = 0; i < n; i++) {\n      for (let j = 0; j <= i; j++) {\n        if (i === j) {\n          let sum = 0;\n          for (let k = 0; k < j; k++) {\n            sum += L[j][k] * L[j][k];\n          }\n          L[j][j] = Math.sqrt(matrix[j][j] - sum);\n        } else {\n          let sum = 0;\n          for (let k = 0; k < j; k++) {\n            sum += L[i][k] * L[j][k];\n          }\n          L[i][j] = (matrix[i][j] - sum) / L[j][j];\n        }\n      }\n    }\n\n    return L;\n  }\n\n  /**\n   * Apply correlation using Cholesky matrix\n   * @param {Array} independentValues - Independent random values\n   * @param {Array} choleskyMatrix - Cholesky decomposition matrix\n   * @returns {Array} Correlated values\n   */\n  applyCorrelation(independentValues, choleskyMatrix) {\n    const n = independentValues.length;\n    const correlatedValues = Array(n).fill(0);\n\n    for (let i = 0; i < n; i++) {\n      for (let j = 0; j <= i; j++) {\n        correlatedValues[i] += choleskyMatrix[i][j] * independentValues[j];\n      }\n    }\n\n    return correlatedValues;\n  }\n\n  /**\n   * Create scenario inputs by applying random samples to base inputs\n   * @param {Object} baseInputs - Base model inputs\n   * @param {Object} samples - Random samples\n   * @param {Object} distributions - Distribution definitions\n   * @returns {Object} Scenario inputs\n   */\n  createScenarioInputs(baseInputs, samples, distributions) {\n    const scenarioInputs = { ...baseInputs };\n\n    Object.entries(samples).forEach(([variable, sample]) => {\n      const distribution = distributions[variable];\n\n      if (distribution.applyTo) {\n        // Apply sample to specific input field\n        scenarioInputs[distribution.applyTo] = sample;\n      } else {\n        // Direct assignment\n        scenarioInputs[variable] = sample;\n      }\n    });\n\n    return scenarioInputs;\n  }\n\n  /**\n   * Calculate DCF scenario (simplified for Monte Carlo)\n   * @param {Object} inputs - Scenario inputs\n   * @returns {Object} DCF results\n   */\n  calculateDCFScenario(inputs) {\n    // This would integrate with the financialModelingEngine\n    // Simplified calculation for demonstration\n    const {\n      currentRevenue = 1000000000,\n      revenueGrowthRate = 0.1,\n      fcfMargin = 0.15,\n      wacc = 0.1,\n      terminalGrowthRate = 0.025,\n      sharesOutstanding = 100000000,\n      currentPrice = 100\n    } = inputs;\n\n    // Simple DCF calculation\n    const projectionYears = 5;\n    let totalPV = 0;\n    let revenue = currentRevenue;\n\n    for (let year = 1; year <= projectionYears; year++) {\n      revenue *= (1 + revenueGrowthRate);\n      const fcf = revenue * fcfMargin;\n      const pv = fcf / Math.pow(1 + wacc, year);\n      totalPV += pv;\n    }\n\n    // Terminal value\n    const terminalFCF = revenue * fcfMargin * (1 + terminalGrowthRate);\n    const terminalValue = terminalFCF / (wacc - terminalGrowthRate);\n    const pvTerminal = terminalValue / Math.pow(1 + wacc, projectionYears);\n\n    const enterpriseValue = totalPV + pvTerminal;\n    const pricePerShare = enterpriseValue / sharesOutstanding;\n    const upside = ((pricePerShare - currentPrice) / currentPrice) * 100;\n\n    return {\n      pricePerShare,\n      enterpriseValue,\n      upside\n    };\n  }\n\n  /**\n   * Calculate LBO scenario (simplified for Monte Carlo)\n   * @param {Object} inputs - Scenario inputs\n   * @returns {Object} LBO results\n   */\n  calculateLBOScenario(inputs) {\n    // Simplified LBO calculation for demonstration\n    const {\n      ebitda = 100000000,\n      ebitdaGrowthRate = 0.05,\n      exitMultiple = 10,\n      debtMultiple = 5,\n      holdingPeriod = 5\n    } = inputs;\n\n    const purchasePrice = ebitda * 10; // Assume 10x entry multiple\n    const debt = ebitda * debtMultiple;\n    const equity = purchasePrice - debt;\n\n    // Project exit EBITDA\n    const exitEbitda = ebitda * Math.pow(1 + ebitdaGrowthRate, holdingPeriod);\n    const exitValue = exitEbitda * exitMultiple;\n    const remainingDebt = debt * 0.5; // Assume 50% paydown\n    const exitProceeds = exitValue - remainingDebt;\n\n    const totalReturn = exitProceeds / equity;\n    const irr = Math.pow(totalReturn, 1 / holdingPeriod) - 1;\n\n    return {\n      irr,\n      moic: totalReturn,\n      totalReturn: exitProceeds\n    };\n  }\n\n  /**\n   * Analyze simulation results with enhanced statistical measures\n   * @param {Array} results - Simulation results\n   * @param {number} confidenceLevel - Confidence level\n   * @param {Array} metrics - Metrics to analyze\n   * @returns {Object} Comprehensive statistical analysis\n   */\n  analyzeResults(results, confidenceLevel, metrics = ['pricePerShare', 'enterpriseValue', 'upside']) {\n    const analysis = {\n      statistics: {},\n      percentiles: {},\n      confidenceIntervals: {},\n      riskMetrics: {},\n      distributionTests: {},\n      correlations: {}\n    };\n\n    metrics.forEach(metric => {\n      const values = results.map(r => r[metric]).filter(v => v !== null && !isNaN(v)).sort((a, b) => a - b);\n\n      if (values.length === 0) return;\n\n      const mean = values.reduce((sum, v) => sum + v, 0) / values.length;\n      const variance = values.reduce((sum, v) => sum + Math.pow(v - mean, 2), 0) / values.length;\n      const stdDev = Math.sqrt(variance);\n      const sampleStdDev = Math.sqrt(variance * values.length / (values.length - 1)); // Bessel's correction\n\n      analysis.statistics[metric] = {\n        mean,\n        median: this.percentile(values, 0.5),\n        mode: this.calculateMode(values),\n        stdDev,\n        sampleStdDev,\n        variance,\n        min: values[0],\n        max: values[values.length - 1],\n        range: values[values.length - 1] - values[0],\n        count: values.length,\n        // Additional robust statistics\n        trimmedMean: this.calculateTrimmedMean(values, 0.1), // 10% trimmed mean\n        mad: this.calculateMAD(values), // Median Absolute Deviation\n        iqr: this.percentile(values, 0.75) - this.percentile(values, 0.25)\n      };\n\n      analysis.percentiles[metric] = {\n        p1: this.percentile(values, 0.01),\n        p5: this.percentile(values, 0.05),\n        p10: this.percentile(values, 0.10),\n        p25: this.percentile(values, 0.25),\n        p50: this.percentile(values, 0.5),\n        p75: this.percentile(values, 0.75),\n        p90: this.percentile(values, 0.90),\n        p95: this.percentile(values, 0.95),\n        p99: this.percentile(values, 0.99)\n      };\n\n      const alpha = 1 - confidenceLevel;\n      const lowerBound = this.percentile(values, alpha / 2);\n      const upperBound = this.percentile(values, 1 - alpha / 2);\n\n      analysis.confidenceIntervals[metric] = {\n        level: confidenceLevel,\n        lowerBound,\n        upperBound,\n        width: upperBound - lowerBound,\n        // Bootstrap confidence intervals\n        bootstrapCI: this.calculateBootstrapCI(values, confidenceLevel)\n      };\n\n      const var95 = this.percentile(values, 0.05);\n      const var99 = this.percentile(values, 0.01);\n      const cvar95 = values.slice(0, Math.floor(values.length * 0.05)).reduce((sum, v) => sum + v, 0) / Math.floor(values.length * 0.05);\n      const cvar99 = values.slice(0, Math.floor(values.length * 0.01)).reduce((sum, v) => sum + v, 0) / Math.floor(values.length * 0.01);\n\n      analysis.riskMetrics[metric] = {\n        var95, // Value at Risk (5%)\n        var99, // Value at Risk (1%)\n        cvar95, // Conditional VaR (5%)\n        cvar99, // Conditional VaR (1%)\n        skewness: this.calculateSkewness(values, mean, stdDev),\n        kurtosis: this.calculateKurtosis(values, mean, stdDev),\n        excessKurtosis: this.calculateKurtosis(values, mean, stdDev) - 3,\n        // Tail risk measures\n        expectedShortfall: cvar95,\n        maxDrawdown: this.calculateMaxDrawdown(values),\n        // Risk-adjusted returns\n        sharpeRatio: this.calculateSharpeRatio(values, 0.02), // Assuming 2% risk-free rate\n        sortinoRatio: this.calculateSortinoRatio(values, mean)\n      };\n\n      // Distribution fitting tests\n      analysis.distributionTests[metric] = {\n        jarqueBera: this.jarqueBeraTest(values),\n        kolmogorovSmirnov: this.ksTestNormality(values),\n        shapiroWilk: values.length <= 5000 ? this.shapiroWilkTest(values) : null\n      };\n    });\n\n    // Calculate correlation matrix between metrics\n    if (metrics.length > 1) {\n      analysis.correlations = this.calculateCorrelationMatrix(results, metrics);\n    }\n\n    return analysis;\n  }\n\n  /**\n   * Calculate mode of dataset\n   */\n  calculateMode(values) {\n    const frequency = {};\n    values.forEach(v => {\n      const rounded = Math.round(v * 100) / 100; // Round to avoid floating point issues\n      frequency[rounded] = (frequency[rounded] || 0) + 1;\n    });\n\n    const maxFreq = Math.max(...Object.values(frequency));\n    const modes = Object.keys(frequency).filter(k => frequency[k] === maxFreq);\n\n    return modes.length === 1 ? parseFloat(modes[0]) : null;\n  }\n\n  /**\n   * Calculate trimmed mean\n   */\n  calculateTrimmedMean(sortedValues, trimProportion = 0.1) {\n    const trimCount = Math.floor(sortedValues.length * trimProportion);\n    const trimmedValues = sortedValues.slice(trimCount, -trimCount || undefined);\n    return trimmedValues.reduce((sum, v) => sum + v, 0) / trimmedValues.length;\n  }\n\n  /**\n   * Calculate Median Absolute Deviation\n   */\n  calculateMAD(values) {\n    const median = this.percentile(values, 0.5);\n    const deviations = values.map(v => Math.abs(v - median)).sort((a, b) => a - b);\n    return this.percentile(deviations, 0.5);\n  }\n\n  /**\n   * Calculate bootstrap confidence interval\n   */\n  calculateBootstrapCI(values, confidenceLevel, bootstrapSamples = 1000) {\n    const bootstrapMeans = [];\n\n    for (let i = 0; i < bootstrapSamples; i++) {\n      const sample = [];\n      for (let j = 0; j < values.length; j++) {\n        sample.push(values[Math.floor(Math.random() * values.length)]);\n      }\n      bootstrapMeans.push(sample.reduce((sum, v) => sum + v, 0) / sample.length);\n    }\n\n    bootstrapMeans.sort((a, b) => a - b);\n    const alpha = 1 - confidenceLevel;\n\n    return {\n      lowerBound: this.percentile(bootstrapMeans, alpha / 2),\n      upperBound: this.percentile(bootstrapMeans, 1 - alpha / 2)\n    };\n  }\n\n  /**\n   * Calculate maximum drawdown\n   */\n  calculateMaxDrawdown(values) {\n    let peak = values[0];\n    let maxDrawdown = 0;\n\n    for (const value of values) {\n      if (value > peak) {\n        peak = value;\n      }\n      const drawdown = (peak - value) / peak;\n      if (drawdown > maxDrawdown) {\n        maxDrawdown = drawdown;\n      }\n    }\n\n    return maxDrawdown;\n  }\n\n  /**\n   * Calculate Sharpe ratio approximation\n   */\n  calculateSharpeRatio(values, riskFreeRate = 0.02) {\n    const mean = values.reduce((sum, v) => sum + v, 0) / values.length;\n    const variance = values.reduce((sum, v) => sum + Math.pow(v - mean, 2), 0) / values.length;\n    const stdDev = Math.sqrt(variance);\n\n    return stdDev > 0 ? (mean - riskFreeRate) / stdDev : 0;\n  }\n\n  /**\n   * Calculate Sortino ratio\n   */\n  calculateSortinoRatio(values, targetReturn) {\n    const excessReturns = values.map(v => v - targetReturn);\n    const negativeReturns = excessReturns.filter(r => r < 0);\n\n    if (negativeReturns.length === 0) return Infinity;\n\n    const downsideDeviation = Math.sqrt(\n      negativeReturns.reduce((sum, r) => sum + r * r, 0) / negativeReturns.length\n    );\n\n    const meanExcessReturn = excessReturns.reduce((sum, r) => sum + r, 0) / excessReturns.length;\n\n    return downsideDeviation > 0 ? meanExcessReturn / downsideDeviation : 0;\n  }\n\n  /**\n   * Jarque-Bera test for normality\n   */\n  jarqueBeraTest(values) {\n    const n = values.length;\n    const mean = values.reduce((sum, v) => sum + v, 0) / n;\n    const variance = values.reduce((sum, v) => sum + Math.pow(v - mean, 2), 0) / n;\n    const stdDev = Math.sqrt(variance);\n\n    const skewness = this.calculateSkewness(values, mean, stdDev);\n    const kurtosis = this.calculateKurtosis(values, mean, stdDev);\n\n    const jb = (n / 6) * (Math.pow(skewness, 2) + Math.pow(kurtosis - 3, 2) / 4);\n    const pValue = 1 - this.chiSquaredCDF(jb, 2); // Approximate p-value\n\n    return {\n      statistic: jb,\n      pValue,\n      isNormal: pValue > 0.05\n    };\n  }\n\n  /**\n   * Approximate chi-squared CDF\n   */\n  chiSquaredCDF(x, df) {\n    if (x <= 0) return 0;\n    return this.incompleteGamma(df / 2, x / 2);\n  }\n\n  /**\n   * Incomplete gamma function approximation\n   */\n  incompleteGamma(a, x) {\n    // Simple approximation for demonstration\n    if (x === 0) return 0;\n    if (x < 0) return 0;\n    if (a <= 0) return 0;\n\n    // Use series expansion for small x relative to a\n    if (x < a + 1) {\n      let sum = 1 / a;\n      let term = 1 / a;\n      for (let n = 1; n < 100; n++) {\n        term *= x / (a + n);\n        sum += term;\n        if (Math.abs(term) < 1e-15) break;\n      }\n      return Math.exp(-x + a * Math.log(x) - this.logGamma(a)) * sum;\n    } else {\n      // Use continued fraction for large x\n      let b = x + 1 - a;\n      let c = 1e30;\n      let d = 1 / b;\n      let h = d;\n\n      for (let i = 1; i <= 100; i++) {\n        const an = -i * (i - a);\n        b += 2;\n        d = an * d + b;\n        if (Math.abs(d) < 1e-30) d = 1e-30;\n        c = b + an / c;\n        if (Math.abs(c) < 1e-30) c = 1e-30;\n        d = 1 / d;\n        const del = d * c;\n        h *= del;\n        if (Math.abs(del - 1) < 1e-15) break;\n      }\n\n      const gammacf = Math.exp(-x + a * Math.log(x) - this.logGamma(a)) * h;\n      return 1 - gammacf;\n    }\n  }\n\n  /**\n   * Log gamma function approximation\n   */\n  logGamma(x) {\n    const coef = [\n      76.18009172947144, -86.50532032941676, 24.01409824083091,\n      -1.231739572450155, 0.1208650973866179e-2, -0.5395239384953e-5\n    ];\n\n    let j = 0;\n    let ser = 1.0000000001900151;\n    let xx = x;\n    let y = xx = x;\n    let tmp = x + 5.5;\n    tmp -= (x + 0.5) * Math.log(tmp);\n\n    for (; j < 6; j++) {\n      ser += coef[j] / ++y;\n    }\n\n    return -tmp + Math.log(2.506628274631001 * ser / xx);\n  }\n\n  /**\n   * Kolmogorov-Smirnov test for normality\n   */\n  ksTestNormality(values) {\n    const n = values.length;\n    const mean = values.reduce((sum, v) => sum + v, 0) / n;\n    const variance = values.reduce((sum, v) => sum + Math.pow(v - mean, 2), 0) / n;\n    const stdDev = Math.sqrt(variance);\n\n    let maxD = 0;\n\n    for (let i = 0; i < n; i++) {\n      const empirical = (i + 1) / n;\n      const theoretical = this.normalCDF((values[i] - mean) / stdDev);\n      const d = Math.abs(empirical - theoretical);\n      if (d > maxD) maxD = d;\n    }\n\n    const critical = 1.36 / Math.sqrt(n); // Critical value at 5% significance\n\n    return {\n      statistic: maxD,\n      critical,\n      isNormal: maxD < critical\n    };\n  }\n\n  /**\n   * Normal CDF approximation\n   */\n  normalCDF(x) {\n    return 0.5 * (1 + this.erf(x / Math.sqrt(2)));\n  }\n\n  /**\n   * Error function approximation\n   */\n  erf(x) {\n    const a1 =  0.254829592;\n    const a2 = -0.284496736;\n    const a3 =  1.421413741;\n    const a4 = -1.453152027;\n    const a5 =  1.061405429;\n    const p  =  0.3275911;\n\n    const sign = x < 0 ? -1 : 1;\n    x = Math.abs(x);\n\n    const t = 1.0 / (1.0 + p * x);\n    const y = 1.0 - (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1) * t * Math.exp(-x * x);\n\n    return sign * y;\n  }\n\n  /**\n   * Shapiro-Wilk test for normality (simplified)\n   */\n  shapiroWilkTest(values) {\n    // Simplified implementation - in practice, would use lookup tables\n    const n = values.length;\n    if (n < 3 || n > 5000) return null;\n\n    const sortedValues = [...values].sort((a, b) => a - b);\n    const mean = values.reduce((sum, v) => sum + v, 0) / n;\n\n    // This is a very simplified approximation\n    const numerator = 0;\n    let denominator = 0;\n\n    for (let i = 0; i < n; i++) {\n      denominator += Math.pow(sortedValues[i] - mean, 2);\n    }\n\n    // Simplified calculation - real implementation would use Shapiro-Wilk coefficients\n    const w = numerator / denominator;\n\n    return {\n      statistic: w,\n      isNormal: w > 0.9 // Very rough approximation\n    };\n  }\n\n  /**\n   * Calculate correlation matrix between metrics\n   */\n  calculateCorrelationMatrix(results, metrics) {\n    const correlationMatrix = {};\n\n    for (let i = 0; i < metrics.length; i++) {\n      correlationMatrix[metrics[i]] = {};\n      for (let j = 0; j < metrics.length; j++) {\n        if (i === j) {\n          correlationMatrix[metrics[i]][metrics[j]] = 1.0;\n        } else {\n          const valuesI = results.map(r => r[metrics[i]]).filter(v => v !== null && !isNaN(v));\n          const valuesJ = results.map(r => r[metrics[j]]).filter(v => v !== null && !isNaN(v));\n\n          correlationMatrix[metrics[i]][metrics[j]] = this.calculateCorrelation(valuesI, valuesJ);\n        }\n      }\n    }\n\n    return correlationMatrix;\n  }\n\n  /**\n   * Calculate Pearson correlation coefficient\n   */\n  calculateCorrelation(x, y) {\n    if (x.length !== y.length || x.length === 0) return 0;\n\n    const n = x.length;\n    const meanX = x.reduce((sum, v) => sum + v, 0) / n;\n    const meanY = y.reduce((sum, v) => sum + v, 0) / n;\n\n    let numerator = 0;\n    let sumXX = 0;\n    let sumYY = 0;\n\n    for (let i = 0; i < n; i++) {\n      const dx = x[i] - meanX;\n      const dy = y[i] - meanY;\n      numerator += dx * dy;\n      sumXX += dx * dx;\n      sumYY += dy * dy;\n    }\n\n    const denominator = Math.sqrt(sumXX * sumYY);\n    return denominator > 0 ? numerator / denominator : 0;\n  }\n\n  /**\n   * Calculate percentile\n   * @param {Array} sortedValues - Sorted array of values\n   * @param {number} p - Percentile (0-1)\n   * @returns {number} Percentile value\n   */\n  percentile(sortedValues, p) {\n    const index = p * (sortedValues.length - 1);\n    const lower = Math.floor(index);\n    const upper = Math.ceil(index);\n    const weight = index - lower;\n\n    if (lower === upper) {\n      return sortedValues[lower];\n    }\n\n    return sortedValues[lower] * (1 - weight) + sortedValues[upper] * weight;\n  }\n\n  /**\n   * Calculate skewness\n   * @param {Array} values - Array of values\n   * @param {number} mean - Mean\n   * @param {number} stdDev - Standard deviation\n   * @returns {number} Skewness\n   */\n  calculateSkewness(values, mean, stdDev) {\n    const n = values.length;\n    const sum = values.reduce((sum, v) => sum + Math.pow((v - mean) / stdDev, 3), 0);\n    return (n / ((n - 1) * (n - 2))) * sum;\n  }\n\n  /**\n   * Calculate kurtosis\n   * @param {Array} values - Array of values\n   * @param {number} mean - Mean\n   * @param {number} stdDev - Standard deviation\n   * @returns {number} Kurtosis\n   */\n  calculateKurtosis(values, mean, stdDev) {\n    const n = values.length;\n    const sum = values.reduce((sum, v) => sum + Math.pow((v - mean) / stdDev, 4), 0);\n    return ((n * (n + 1)) / ((n - 1) * (n - 2) * (n - 3))) * sum - (3 * Math.pow(n - 1, 2)) / ((n - 2) * (n - 3));\n  }\n\n  /**\n   * Set random seed for reproducible results\n   * @param {number} seed - Random seed\n   */\n  setSeed(seed) {\n    // Simple linear congruential generator for reproducible results\n    this.seed = seed;\n    this.random = () => {\n      this.seed = (this.seed * 9301 + 49297) % 233280;\n      return this.seed / 233280;\n    };\n    Math.random = this.random;\n  }\n\n  /**\n   * Stop running simulation\n   */\n  stopSimulation() {\n    this.isRunning = false;\n  }\n\n  /**\n   * Check if simulation is running\n   * @returns {boolean} True if running\n   */\n  isSimulationRunning() {\n    return this.isRunning;\n  }\n}\n\n// Export singleton instance\nexport const monteCarloEngine = new MonteCarloEngine();\nexport default MonteCarloEngine;\n"],"names":["monteCarloEngine","constructor","this","workers","isRunning","currentSimulation","runDCFSimulation","baseInputs","distributions","options","iterations","confidenceLevel","correlationMatrix","randomSeed","apiLogger","log","variables","Object","keys","length","startTime","Date","now","setSeed","samples","generateCorrelatedSamples","results","progressCallback","onProgress","i","Error","scenarioInputs","createScenarioInputs","dcfResult","calculateDCFScenario","push","iteration","pricePerShare","enterpriseValue","upside","inputs","Math","floor","analysis","analyzeResults","endTime","duration","meanPrice","statistics","mean","type","timestamp","toISOString","parameters","error","message","runLBOSimulation","lboResult","calculateLBOScenario","irr","moic","totalReturn","meanIRR","numVars","independentSamples","sample","forEach","variable","dist","sampleFromDistribution","choleskyMatrix","choleskyDecomposition","correlatedSample","independentValues","map","v","correlatedValues","applyCorrelation","index","distribution","normalRandom","stdDev","normalSample","mu","sigma","exp","min","random","max","triangularRandom","mode","betaRandom","alpha","beta","exponentialRandom","lambda","weibullRandom","shape","scale","paretoRandom","studentTRandom","df","chiSquaredRandom","u","pow","normal","chiSq","sqrt","gammaRandom","undefined","spareNormal","spare","u1","u2","z0","cos","PI","z1","sin","x","d","c","matrix","n","L","Array","fill","j","sum","k","entries","applyTo","currentRevenue","revenueGrowthRate","fcfMargin","wacc","terminalGrowthRate","sharesOutstanding","currentPrice","totalPV","revenue","year","ebitda","ebitdaGrowthRate","exitMultiple","debtMultiple","holdingPeriod","debt","equity","exitProceeds","metrics","percentiles","confidenceIntervals","riskMetrics","distributionTests","correlations","metric","values","r","filter","isNaN","sort","a","b","reduce","variance","sampleStdDev","median","percentile","calculateMode","range","count","trimmedMean","calculateTrimmedMean","mad","calculateMAD","iqr","p1","p5","p10","p25","p50","p75","p90","p95","p99","lowerBound","upperBound","level","width","bootstrapCI","calculateBootstrapCI","var95","var99","cvar95","slice","cvar99","skewness","calculateSkewness","kurtosis","calculateKurtosis","excessKurtosis","expectedShortfall","maxDrawdown","calculateMaxDrawdown","sharpeRatio","calculateSharpeRatio","sortinoRatio","calculateSortinoRatio","jarqueBera","jarqueBeraTest","kolmogorovSmirnov","ksTestNormality","shapiroWilk","shapiroWilkTest","calculateCorrelationMatrix","frequency","rounded","round","maxFreq","modes","parseFloat","sortedValues","trimProportion","trimCount","trimmedValues","deviations","abs","bootstrapSamples","bootstrapMeans","peak","value","drawdown","riskFreeRate","targetReturn","excessReturns","negativeReturns","Infinity","downsideDeviation","meanExcessReturn","jb","pValue","chiSquaredCDF","statistic","isNormal","incompleteGamma","term","logGamma","h","an","del","coef","ser","xx","y","tmp","maxD","empirical","theoretical","normalCDF","critical","erf","sign","t","denominator","w","valuesI","valuesJ","calculateCorrelation","meanX","meanY","numerator","sumXX","sumYY","dx","dy","p","lower","upper","ceil","weight","seed","stopSimulation","isSimulationRunning"],"mappings":"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"}