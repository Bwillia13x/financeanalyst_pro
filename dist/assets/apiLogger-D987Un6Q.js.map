{"version":3,"file":"apiLogger-D987Un6Q.js","sources":["../../src/utils/apiLogger.js"],"sourcesContent":["/**\n * Enhanced API logging and monitoring utility\n * Provides comprehensive logging, metrics collection, and performance monitoring\n */\n\n// Log levels\nconst LOG_LEVELS = {\n  ERROR: 0,\n  WARN: 1,\n  INFO: 2,\n  DEBUG: 3,\n  TRACE: 4\n};\n\n// Default configuration\nconst DEFAULT_CONFIG = {\n  logLevel: LOG_LEVELS.INFO,\n  enableMetrics: true,\n  enablePerformanceTracking: true,\n  enableErrorTracking: true,\n  maxLogHistory: 1000,\n  metricsRetentionPeriod: 24 * 60 * 60 * 1000 // 24 hours\n};\n\n/**\n * API Logger class for comprehensive monitoring\n */\nclass ApiLogger {\n  constructor(config = {}) {\n    this.config = { ...DEFAULT_CONFIG, ...config };\n    this.logs = [];\n    this.metrics = new Map();\n    this.performanceData = new Map();\n    this.errorCounts = new Map();\n    this.startTime = Date.now();\n  }\n\n  /**\n   * Log a message with specified level\n   * @param {string} level - Log level\n   * @param {string} message - Log message\n   * @param {Object} metadata - Additional metadata\n   */\n  log(level, message, metadata = {}) {\n    const levelValue = LOG_LEVELS[level.toUpperCase()] || LOG_LEVELS.INFO;\n\n    if (levelValue <= this.config.logLevel) {\n      const logEntry = {\n        timestamp: new Date().toISOString(),\n        level: level.toUpperCase(),\n        message,\n        metadata,\n        id: this.generateLogId()\n      };\n\n      this.logs.push(logEntry);\n      this.trimLogs();\n\n      // Console output with formatting\n      this.outputToConsole(logEntry);\n    }\n  }\n\n  /**\n   * Log API request start\n   * @param {string} service - Service name (e.g., 'FMP', 'ALPHA_VANTAGE')\n   * @param {string} endpoint - API endpoint\n   * @param {Object} params - Request parameters\n   * @returns {string} Request ID for tracking\n   */\n  logApiRequest(service, endpoint, params = {}) {\n    const requestId = this.generateRequestId();\n    const startTime = Date.now();\n\n    this.log('INFO', '🚀 API Request Started', {\n      requestId,\n      service,\n      endpoint,\n      params: this.sanitizeParams(params),\n      startTime\n    });\n\n    // Store performance tracking data\n    this.performanceData.set(requestId, {\n      service,\n      endpoint,\n      startTime,\n      params: this.sanitizeParams(params)\n    });\n\n    return requestId;\n  }\n\n  /**\n   * Log API request completion\n   * @param {string} requestId - Request ID from logApiRequest\n   * @param {boolean} success - Whether request was successful\n   * @param {Object} response - Response data (will be sanitized)\n   * @param {Error} error - Error object if request failed\n   */\n  logApiResponse(requestId, success, response = null, error = null) {\n    const performanceData = this.performanceData.get(requestId);\n    if (!performanceData) {\n      this.log('WARN', 'No performance data found for request', { requestId });\n      return;\n    }\n\n    const endTime = Date.now();\n    const duration = endTime - performanceData.startTime;\n    const { service, endpoint } = performanceData;\n\n    if (success) {\n      this.log('INFO', '✅ API Request Completed', {\n        requestId,\n        service,\n        endpoint,\n        duration,\n        responseSize: this.getResponseSize(response),\n        success: true\n      });\n\n      this.recordMetric(service, 'success', 1);\n    } else {\n      this.log('ERROR', '❌ API Request Failed', {\n        requestId,\n        service,\n        endpoint,\n        duration,\n        error: error\n          ? {\n              message: error.message,\n              code: error.code,\n              status: error.response?.status,\n              statusText: error.response?.statusText\n            }\n          : null,\n        success: false\n      });\n\n      this.recordMetric(service, 'error', 1);\n      this.recordError(service, error);\n    }\n\n    // Record performance metrics\n    this.recordMetric(service, 'duration', duration);\n    this.recordMetric(service, 'requests', 1);\n\n    // Clean up performance data\n    this.performanceData.delete(requestId);\n  }\n\n  /**\n   * Log rate limiting events\n   * @param {string} service - Service name\n   * @param {number} waitTime - Time to wait in milliseconds\n   * @param {number} remainingRequests - Remaining requests in current period\n   */\n  logRateLimit(service, waitTime, remainingRequests = null) {\n    this.log('WARN', '⏱️ Rate Limit Hit', {\n      service,\n      waitTime,\n      remainingRequests,\n      action: 'throttling'\n    });\n\n    this.recordMetric(service, 'rateLimitHits', 1);\n  }\n\n  /**\n   * Log circuit breaker events\n   * @param {string} service - Service name\n   * @param {string} state - Circuit breaker state\n   * @param {string} action - Action taken\n   * @param {Object} metadata - Additional metadata\n   */\n  logCircuitBreaker(service, state, action, metadata = {}) {\n    const emoji =\n      {\n        OPEN: '🚨',\n        HALF_OPEN: '🔄',\n        CLOSED: '✅'\n      }[state] || '🔧';\n\n    this.log('WARN', `${emoji} Circuit Breaker ${action}`, {\n      service,\n      state,\n      action,\n      ...metadata\n    });\n\n    this.recordMetric(service, `circuitBreaker_${state.toLowerCase()}`, 1);\n  }\n\n  /**\n   * Log cache events\n   * @param {string} operation - Cache operation (hit, miss, set, clear)\n   * @param {string} key - Cache key\n   * @param {Object} metadata - Additional metadata\n   */\n  logCache(operation, key, metadata = {}) {\n    const emoji =\n      {\n        hit: '🎯',\n        miss: '❌',\n        set: '💾',\n        clear: '🗑️'\n      }[operation] || '📦';\n\n    this.log('DEBUG', `${emoji} Cache ${operation.toUpperCase()}`, {\n      operation,\n      key: this.sanitizeCacheKey(key),\n      ...metadata\n    });\n\n    this.recordMetric('cache', operation, 1);\n  }\n\n  /**\n   * Record a metric\n   * @param {string} service - Service name\n   * @param {string} metric - Metric name\n   * @param {number} value - Metric value\n   */\n  recordMetric(service, metric, value) {\n    if (!this.config.enableMetrics) return;\n\n    const key = `${service}.${metric}`;\n    const now = Date.now();\n\n    if (!this.metrics.has(key)) {\n      this.metrics.set(key, {\n        values: [],\n        total: 0,\n        count: 0,\n        min: Infinity,\n        max: -Infinity,\n        avg: 0\n      });\n    }\n\n    const metricData = this.metrics.get(key);\n    metricData.values.push({ value, timestamp: now });\n    metricData.total += value;\n    metricData.count += 1;\n    metricData.min = Math.min(metricData.min, value);\n    metricData.max = Math.max(metricData.max, value);\n    metricData.avg = metricData.total / metricData.count;\n\n    // Clean old metrics\n    this.cleanOldMetrics(key);\n  }\n\n  /**\n   * Record an error for tracking\n   * @param {string} service - Service name\n   * @param {Error} error - Error object\n   */\n  recordError(service, error) {\n    if (!this.config.enableErrorTracking || !error) return;\n\n    const errorKey = `${service}.${error.message}`;\n    const count = this.errorCounts.get(errorKey) || 0;\n    this.errorCounts.set(errorKey, count + 1);\n  }\n\n  /**\n   * Get comprehensive metrics summary\n   * @returns {Object} Metrics summary\n   */\n  getMetrics() {\n    const summary = {\n      uptime: Date.now() - this.startTime,\n      totalLogs: this.logs.length,\n      services: {},\n      cache: {},\n      errors: {}\n    };\n\n    // Process service metrics\n    for (const [key, data] of this.metrics.entries()) {\n      const [service, metric] = key.split('.');\n\n      if (service === 'cache') {\n        summary.cache[metric] = {\n          total: data.total,\n          count: data.count,\n          avg: data.avg\n        };\n      } else {\n        if (!summary.services[service]) {\n          summary.services[service] = {};\n        }\n\n        summary.services[service][metric] = {\n          total: data.total,\n          count: data.count,\n          min: data.min === Infinity ? 0 : data.min,\n          max: data.max === -Infinity ? 0 : data.max,\n          avg: data.avg\n        };\n      }\n    }\n\n    // Process error counts\n    for (const [errorKey, count] of this.errorCounts.entries()) {\n      const [service, ...messageParts] = errorKey.split('.');\n      const message = messageParts.join('.');\n\n      if (!summary.errors[service]) {\n        summary.errors[service] = {};\n      }\n\n      summary.errors[service][message] = count;\n    }\n\n    return summary;\n  }\n\n  /**\n   * Get recent logs\n   * @param {number} limit - Maximum number of logs to return\n   * @param {string} level - Filter by log level\n   * @returns {Array} Recent log entries\n   */\n  getRecentLogs(limit = 100, level = null) {\n    let logs = [...this.logs];\n\n    if (level) {\n      logs = logs.filter(log => log.level === level.toUpperCase());\n    }\n\n    return logs.slice(-limit).reverse();\n  }\n\n  /**\n   * Clear all logs and metrics\n   */\n  clear() {\n    this.logs = [];\n    this.metrics.clear();\n    this.performanceData.clear();\n    this.errorCounts.clear();\n    this.startTime = Date.now();\n  }\n\n  // Private helper methods\n  generateLogId() {\n    return `log_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  generateRequestId() {\n    return `req_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  sanitizeParams(params) {\n    const sanitized = { ...params };\n    // Remove sensitive data\n    if (sanitized.apikey) sanitized.apikey = '***';\n    if (sanitized.api_key) sanitized.api_key = '***';\n    if (sanitized.token) sanitized.token = '***';\n    return sanitized;\n  }\n\n  sanitizeCacheKey(key) {\n    // Truncate long cache keys for readability\n    return key.length > 50 ? `${key.substring(0, 47)}...` : key;\n  }\n\n  getResponseSize(response) {\n    if (!response) return 0;\n    try {\n      return JSON.stringify(response).length;\n    } catch {\n      return 0;\n    }\n  }\n\n  trimLogs() {\n    if (this.logs.length > this.config.maxLogHistory) {\n      this.logs = this.logs.slice(-this.config.maxLogHistory);\n    }\n  }\n\n  cleanOldMetrics(key) {\n    const metricData = this.metrics.get(key);\n    const cutoff = Date.now() - this.config.metricsRetentionPeriod;\n\n    metricData.values = metricData.values.filter(item => item.timestamp > cutoff);\n  }\n\n  outputToConsole(logEntry) {\n    const { level, message, metadata } = logEntry;\n    const timestamp = new Date(logEntry.timestamp).toLocaleTimeString();\n\n    const colors = {\n      ERROR: '\\x1b[31m', // Red\n      WARN: '\\x1b[33m', // Yellow\n      INFO: '\\x1b[36m', // Cyan\n      DEBUG: '\\x1b[35m', // Magenta\n      TRACE: '\\x1b[37m' // White\n    };\n\n    const reset = '\\x1b[0m';\n    const color = colors[level] || colors.INFO;\n\n    console.log(\n      `${color}[${timestamp}] ${level}:${reset} ${message}`,\n      Object.keys(metadata).length > 0 ? metadata : ''\n    );\n  }\n}\n\n// Export singleton instance\nexport const apiLogger = new ApiLogger();\nexport default ApiLogger;\n"],"names":["LOG_LEVELS","ERROR","WARN","INFO","DEBUG","TRACE","DEFAULT_CONFIG","logLevel","enableMetrics","enablePerformanceTracking","enableErrorTracking","maxLogHistory","metricsRetentionPeriod","apiLogger","constructor","config","this","logs","metrics","Map","performanceData","errorCounts","startTime","Date","now","log","level","message","metadata","toUpperCase","logEntry","timestamp","toISOString","id","generateLogId","push","trimLogs","outputToConsole","logApiRequest","service","endpoint","params","requestId","generateRequestId","sanitizeParams","set","logApiResponse","success","response","error","get","duration","responseSize","getResponseSize","recordMetric","code","status","statusText","recordError","delete","logRateLimit","waitTime","remainingRequests","action","logCircuitBreaker","state","emoji","OPEN","HALF_OPEN","CLOSED","toLowerCase","logCache","operation","key","hit","miss","clear","sanitizeCacheKey","metric","value","has","values","total","count","min","Infinity","max","avg","metricData","Math","cleanOldMetrics","errorKey","getMetrics","summary","uptime","totalLogs","length","services","cache","errors","data","entries","split","messageParts","join","getRecentLogs","limit","filter","slice","reverse","random","toString","substr","sanitized","apikey","api_key","token","substring","JSON","stringify","cutoff","item","toLocaleTimeString"],"mappings":"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"}