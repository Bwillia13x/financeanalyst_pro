{"version":3,"file":"financial-engines-DJoNW2Bz.js","sources":["../../src/utils/apiLogger.js","../../src/services/financialModelingEngine.js","../../src/services/lboModelingEngine.js","../../src/services/monteCarloEngine.js"],"sourcesContent":["/**\n * Enhanced API logging and monitoring utility\n * Provides comprehensive logging, metrics collection, and performance monitoring\n */\n\n// Log levels\nconst LOG_LEVELS = {\n  ERROR: 0,\n  WARN: 1,\n  INFO: 2,\n  DEBUG: 3,\n  TRACE: 4\n};\n\n// Default configuration\nconst DEFAULT_CONFIG = {\n  logLevel: LOG_LEVELS.INFO,\n  enableMetrics: true,\n  enablePerformanceTracking: true,\n  enableErrorTracking: true,\n  maxLogHistory: 1000,\n  metricsRetentionPeriod: 24 * 60 * 60 * 1000 // 24 hours\n};\n\n/**\n * API Logger class for comprehensive monitoring\n */\nclass ApiLogger {\n  constructor(config = {}) {\n    this.config = { ...DEFAULT_CONFIG, ...config };\n    this.logs = [];\n    this.metrics = new Map();\n    this.performanceData = new Map();\n    this.errorCounts = new Map();\n    this.startTime = Date.now();\n  }\n\n  /**\n   * Log a message with specified level\n   * @param {string} level - Log level\n   * @param {string} message - Log message\n   * @param {Object} metadata - Additional metadata\n   */\n  log(level, message, metadata = {}) {\n    const levelValue = LOG_LEVELS[level.toUpperCase()] || LOG_LEVELS.INFO;\n\n    if (levelValue <= this.config.logLevel) {\n      const logEntry = {\n        timestamp: new Date().toISOString(),\n        level: level.toUpperCase(),\n        message,\n        metadata,\n        id: this.generateLogId()\n      };\n\n      this.logs.push(logEntry);\n      this.trimLogs();\n\n      // Console output with formatting\n      this.outputToConsole(logEntry);\n    }\n  }\n\n  /**\n   * Log API request start\n   * @param {string} service - Service name (e.g., 'FMP', 'ALPHA_VANTAGE')\n   * @param {string} endpoint - API endpoint\n   * @param {Object} params - Request parameters\n   * @returns {string} Request ID for tracking\n   */\n  logApiRequest(service, endpoint, params = {}) {\n    const requestId = this.generateRequestId();\n    const startTime = Date.now();\n\n    this.log('INFO', 'ðŸš€ API Request Started', {\n      requestId,\n      service,\n      endpoint,\n      params: this.sanitizeParams(params),\n      startTime\n    });\n\n    // Store performance tracking data\n    this.performanceData.set(requestId, {\n      service,\n      endpoint,\n      startTime,\n      params: this.sanitizeParams(params)\n    });\n\n    return requestId;\n  }\n\n  /**\n   * Log API request completion\n   * @param {string} requestId - Request ID from logApiRequest\n   * @param {boolean} success - Whether request was successful\n   * @param {Object} response - Response data (will be sanitized)\n   * @param {Error} error - Error object if request failed\n   */\n  logApiResponse(requestId, success, response = null, error = null) {\n    const performanceData = this.performanceData.get(requestId);\n    if (!performanceData) {\n      this.log('WARN', 'No performance data found for request', { requestId });\n      return;\n    }\n\n    const endTime = Date.now();\n    const duration = endTime - performanceData.startTime;\n    const { service, endpoint } = performanceData;\n\n    if (success) {\n      this.log('INFO', 'âœ… API Request Completed', {\n        requestId,\n        service,\n        endpoint,\n        duration,\n        responseSize: this.getResponseSize(response),\n        success: true\n      });\n\n      this.recordMetric(service, 'success', 1);\n    } else {\n      this.log('ERROR', 'âŒ API Request Failed', {\n        requestId,\n        service,\n        endpoint,\n        duration,\n        error: error\n          ? {\n            message: error.message,\n            code: error.code,\n            status: error.response?.status,\n            statusText: error.response?.statusText\n          }\n          : null,\n        success: false\n      });\n\n      this.recordMetric(service, 'error', 1);\n      this.recordError(service, error);\n    }\n\n    // Record performance metrics\n    this.recordMetric(service, 'duration', duration);\n    this.recordMetric(service, 'requests', 1);\n\n    // Clean up performance data\n    this.performanceData.delete(requestId);\n  }\n\n  /**\n   * Log rate limiting events\n   * @param {string} service - Service name\n   * @param {number} waitTime - Time to wait in milliseconds\n   * @param {number} remainingRequests - Remaining requests in current period\n   */\n  logRateLimit(service, waitTime, remainingRequests = null) {\n    this.log('WARN', 'â±ï¸ Rate Limit Hit', {\n      service,\n      waitTime,\n      remainingRequests,\n      action: 'throttling'\n    });\n\n    this.recordMetric(service, 'rateLimitHits', 1);\n  }\n\n  /**\n   * Log circuit breaker events\n   * @param {string} service - Service name\n   * @param {string} state - Circuit breaker state\n   * @param {string} action - Action taken\n   * @param {Object} metadata - Additional metadata\n   */\n  logCircuitBreaker(service, state, action, metadata = {}) {\n    const emoji =\n      {\n        OPEN: 'ðŸš¨',\n        HALF_OPEN: 'ðŸ”„',\n        CLOSED: 'âœ…'\n      }[state] || 'ðŸ”§';\n\n    this.log('WARN', `${emoji} Circuit Breaker ${action}`, {\n      service,\n      state,\n      action,\n      ...metadata\n    });\n\n    this.recordMetric(service, `circuitBreaker_${state.toLowerCase()}`, 1);\n  }\n\n  /**\n   * Log cache events\n   * @param {string} operation - Cache operation (hit, miss, set, clear)\n   * @param {string} key - Cache key\n   * @param {Object} metadata - Additional metadata\n   */\n  logCache(operation, key, metadata = {}) {\n    const emoji =\n      {\n        hit: 'ðŸŽ¯',\n        miss: 'âŒ',\n        set: 'ðŸ’¾',\n        clear: 'ðŸ—‘ï¸'\n      }[operation] || 'ðŸ“¦';\n\n    this.log('DEBUG', `${emoji} Cache ${operation.toUpperCase()}`, {\n      operation,\n      key: this.sanitizeCacheKey(key),\n      ...metadata\n    });\n\n    this.recordMetric('cache', operation, 1);\n  }\n\n  /**\n   * Record a metric\n   * @param {string} service - Service name\n   * @param {string} metric - Metric name\n   * @param {number} value - Metric value\n   */\n  recordMetric(service, metric, value) {\n    if (!this.config.enableMetrics) return;\n\n    const key = `${service}.${metric}`;\n    const now = Date.now();\n\n    if (!this.metrics.has(key)) {\n      this.metrics.set(key, {\n        values: [],\n        total: 0,\n        count: 0,\n        min: Infinity,\n        max: -Infinity,\n        avg: 0\n      });\n    }\n\n    const metricData = this.metrics.get(key);\n    metricData.values.push({ value, timestamp: now });\n    metricData.total += value;\n    metricData.count += 1;\n    metricData.min = Math.min(metricData.min, value);\n    metricData.max = Math.max(metricData.max, value);\n    metricData.avg = metricData.total / metricData.count;\n\n    // Clean old metrics\n    this.cleanOldMetrics(key);\n  }\n\n  /**\n   * Record an error for tracking\n   * @param {string} service - Service name\n   * @param {Error} error - Error object\n   */\n  recordError(service, error) {\n    if (!this.config.enableErrorTracking || !error) return;\n\n    const errorKey = `${service}.${error.message}`;\n    const count = this.errorCounts.get(errorKey) || 0;\n    this.errorCounts.set(errorKey, count + 1);\n  }\n\n  /**\n   * Get comprehensive metrics summary\n   * @returns {Object} Metrics summary\n   */\n  getMetrics() {\n    const summary = {\n      uptime: Date.now() - this.startTime,\n      totalLogs: this.logs.length,\n      services: {},\n      cache: {},\n      errors: {}\n    };\n\n    // Process service metrics\n    for (const [key, data] of this.metrics.entries()) {\n      const [service, metric] = key.split('.');\n\n      if (service === 'cache') {\n        summary.cache[metric] = {\n          total: data.total,\n          count: data.count,\n          avg: data.avg\n        };\n      } else {\n        if (!summary.services[service]) {\n          summary.services[service] = {};\n        }\n\n        summary.services[service][metric] = {\n          total: data.total,\n          count: data.count,\n          min: data.min === Infinity ? 0 : data.min,\n          max: data.max === -Infinity ? 0 : data.max,\n          avg: data.avg\n        };\n      }\n    }\n\n    // Process error counts\n    for (const [errorKey, count] of this.errorCounts.entries()) {\n      const [service, ...messageParts] = errorKey.split('.');\n      const message = messageParts.join('.');\n\n      if (!summary.errors[service]) {\n        summary.errors[service] = {};\n      }\n\n      summary.errors[service][message] = count;\n    }\n\n    return summary;\n  }\n\n  /**\n   * Get recent logs\n   * @param {number} limit - Maximum number of logs to return\n   * @param {string} level - Filter by log level\n   * @returns {Array} Recent log entries\n   */\n  getRecentLogs(limit = 100, level = null) {\n    let logs = [...this.logs];\n\n    if (level) {\n      logs = logs.filter(log => log.level === level.toUpperCase());\n    }\n\n    return logs.slice(-limit).reverse();\n  }\n\n  /**\n   * Clear all logs and metrics\n   */\n  clear() {\n    this.logs = [];\n    this.metrics.clear();\n    this.performanceData.clear();\n    this.errorCounts.clear();\n    this.startTime = Date.now();\n  }\n\n  // Private helper methods\n  generateLogId() {\n    return `log_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  generateRequestId() {\n    return `req_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  sanitizeParams(params) {\n    const sanitized = { ...params };\n    // Remove sensitive data\n    if (sanitized.apikey) sanitized.apikey = '***';\n    if (sanitized.api_key) sanitized.api_key = '***';\n    if (sanitized.token) sanitized.token = '***';\n    return sanitized;\n  }\n\n  sanitizeCacheKey(key) {\n    // Truncate long cache keys for readability\n    return key.length > 50 ? `${key.substring(0, 47)}...` : key;\n  }\n\n  getResponseSize(response) {\n    if (!response) return 0;\n    try {\n      return JSON.stringify(response).length;\n    } catch {\n      return 0;\n    }\n  }\n\n  trimLogs() {\n    if (this.logs.length > this.config.maxLogHistory) {\n      this.logs = this.logs.slice(-this.config.maxLogHistory);\n    }\n  }\n\n  cleanOldMetrics(key) {\n    const metricData = this.metrics.get(key);\n    const cutoff = Date.now() - this.config.metricsRetentionPeriod;\n\n    metricData.values = metricData.values.filter(item => item.timestamp > cutoff);\n  }\n\n  outputToConsole(logEntry) {\n    const { level, message, metadata } = logEntry;\n    const timestamp = new Date(logEntry.timestamp).toLocaleTimeString();\n\n    const colors = {\n      ERROR: '\\x1b[31m', // Red\n      WARN: '\\x1b[33m', // Yellow\n      INFO: '\\x1b[36m', // Cyan\n      DEBUG: '\\x1b[35m', // Magenta\n      TRACE: '\\x1b[37m' // White\n    };\n\n    const reset = '\\x1b[0m';\n    const color = colors[level] || colors.INFO;\n\n    console.log(\n      `${color}[${timestamp}] ${level}:${reset} ${message}`,\n      Object.keys(metadata).length > 0 ? metadata : ''\n    );\n  }\n}\n\n// Export singleton instance\nexport const apiLogger = new ApiLogger();\nexport default ApiLogger;\n","import { apiLogger } from '../utils/apiLogger.js';\n\n/**\n * Advanced Financial Modeling Engine\n * Provides comprehensive DCF, LBO, and valuation modeling capabilities\n */\nclass FinancialModelingEngine {\n  constructor() {\n    this.modelCache = new Map();\n    this.assumptions = this.getDefaultAssumptions();\n  }\n\n  /**\n   * Get default financial modeling assumptions\n   */\n  getDefaultAssumptions() {\n    return {\n      dcf: {\n        projectionYears: 5,\n        terminalGrowthRate: 0.025,\n        riskFreeRate: 0.045,\n        marketPremium: 0.065,\n        taxRate: 0.21,\n        capexAsPercentOfRevenue: 0.03,\n        nwcAsPercentOfRevenue: 0.05,\n        depreciationAsPercentOfRevenue: 0.025,\n        // Enhanced DCF parameters\n        normalizedMarginTarget: null, // For margin normalization\n        cyclicalAdjustment: false,\n        industryBeta: 1.0,\n        sizeAdjustment: 0.0, // Small company premium\n        countryRiskPremium: 0.0,\n        liquidityDiscount: 0.0\n      },\n      lbo: {\n        holdingPeriod: 5,\n        debtMultiples: { senior: 4.0, subordinated: 1.5, total: 5.5 },\n        interestRates: { senior: 0.055, subordinated: 0.095 },\n        managementFeeRate: 0.02,\n        carriedInterestRate: 0.2,\n        ebitdaGrowthRate: 0.05,\n        debtPaydownRate: 0.5\n      },\n      monte_carlo: {\n        iterations: 10000,\n        confidenceIntervals: [0.05, 0.25, 0.5, 0.75, 0.95],\n        correlationMatrix: null\n      }\n    };\n  }\n\n  /**\n   * Build comprehensive DCF model with multiple scenarios\n   * @param {Object} inputs - DCF model inputs\n   * @param {Object} scenarios - Different scenario assumptions\n   * @returns {Object} Complete DCF analysis\n   */\n  buildDCFModel(inputs, scenarios = {}) {\n    const {\n      symbol,\n      companyName,\n      currentRevenue,\n      historicalGrowthRates = [],\n      margins = {},\n      balanceSheetData = {},\n      marketData = {},\n      assumptions = {}\n    } = inputs;\n\n    // Merge with default assumptions\n    const modelAssumptions = { ...this.assumptions.dcf, ...assumptions };\n\n    // Build base case scenario\n    const baseCase = this.calculateDCFScenario(inputs, modelAssumptions, 'Base Case');\n\n    // Build additional scenarios\n    const scenarioResults = {};\n\n    // Bull case: Higher growth, lower discount rate\n    if (scenarios.bull !== false) {\n      const bullAssumptions = {\n        ...modelAssumptions,\n        revenueGrowthRate: (modelAssumptions.revenueGrowthRate || 0.1) * 1.3,\n        terminalGrowthRate: Math.min(modelAssumptions.terminalGrowthRate * 1.2, 0.04),\n        wacc: (modelAssumptions.wacc || 0.1) * 0.9\n      };\n      scenarioResults.bull = this.calculateDCFScenario(inputs, bullAssumptions, 'Bull Case');\n    }\n\n    // Bear case: Lower growth, higher discount rate\n    if (scenarios.bear !== false) {\n      const bearAssumptions = {\n        ...modelAssumptions,\n        revenueGrowthRate: (modelAssumptions.revenueGrowthRate || 0.1) * 0.7,\n        terminalGrowthRate: Math.max(modelAssumptions.terminalGrowthRate * 0.8, 0.015),\n        wacc: (modelAssumptions.wacc || 0.1) * 1.1\n      };\n      scenarioResults.bear = this.calculateDCFScenario(inputs, bearAssumptions, 'Bear Case');\n    }\n\n    // Calculate sensitivity analysis\n    const sensitivityAnalysis = this.performDCFSensitivityAnalysis(inputs, modelAssumptions);\n\n    return {\n      symbol,\n      companyName,\n      modelType: 'DCF',\n      timestamp: new Date().toISOString(),\n      baseCase,\n      scenarios: scenarioResults,\n      sensitivityAnalysis,\n      assumptions: modelAssumptions,\n      summary: this.generateDCFSummary(baseCase, scenarioResults, inputs.currentPrice)\n    };\n  }\n\n  /**\n   * Calculate WACC (Weighted Average Cost of Capital)\n   * @param {Object} inputs - Financial inputs\n   * @param {Object} assumptions - Model assumptions\n   * @returns {number} WACC as decimal\n   */\n  calculateWACC(inputs, assumptions) {\n    const {\n      marketCap = 0,\n      totalDebt = 0,\n      cash = 0,\n      beta = 1.0,\n      riskFreeRate = assumptions.riskFreeRate || 0.045,\n      marketPremium = assumptions.marketPremium || 0.065,\n      taxRate = assumptions.taxRate || 0.21,\n      costOfDebt = assumptions.costOfDebt || 0.055\n    } = inputs;\n\n    // Calculate cost of equity using CAPM\n    const costOfEquity = riskFreeRate + beta * marketPremium;\n\n    // Calculate net debt\n    const netDebt = Math.max(0, totalDebt - cash);\n\n    // Calculate total value\n    const totalValue = marketCap + netDebt;\n\n    if (totalValue === 0) {\n      // Fallback to a reasonable WACC estimate\n      return costOfEquity;\n    }\n\n    // Calculate weights\n    const equityWeight = marketCap / totalValue;\n    const debtWeight = netDebt / totalValue;\n\n    // Calculate WACC\n    const wacc = (equityWeight * costOfEquity) + (debtWeight * costOfDebt * (1 - taxRate));\n\n    return Math.max(0.02, Math.min(0.25, wacc)); // Bound between 2% and 25%\n  }\n\n  /**\n   * Calculate DCF for a specific scenario\n   * @param {Object} inputs - Model inputs\n   * @param {Object} assumptions - Scenario assumptions\n   * @param {string} scenarioName - Name of the scenario\n   * @returns {Object} DCF calculation results\n   */\n  calculateDCFScenario(inputs, assumptions, scenarioName) {\n    const {\n      currentRevenue,\n      currentPrice,\n      sharesOutstanding,\n      totalDebt = 0,\n      cash = 0\n    } = inputs;\n\n    // Calculate WACC if not provided or use discountRate as fallback\n    let wacc = assumptions.wacc;\n    if (!wacc && assumptions.discountRate) {\n      wacc = assumptions.discountRate;\n    } else if (!wacc) {\n      wacc = this.calculateWACC(inputs, assumptions);\n    }\n\n    // Validate WACC\n    if (isNaN(wacc) || wacc <= 0) {\n      wacc = 0.1; // Default 10% WACC\n    }\n\n    // Project revenues\n    const revenueProjections = this.projectRevenues(\n      currentRevenue,\n      assumptions.revenueGrowthRate || 0.1,\n      assumptions.projectionYears\n    );\n\n    // Project operating metrics\n    const operatingProjections = this.projectOperatingMetrics(\n      revenueProjections,\n      assumptions\n    );\n\n    // Calculate free cash flows\n    const fcfProjections = this.calculateFreeCashFlows(\n      operatingProjections,\n      assumptions\n    );\n\n    // Get final FCF for terminal value calculation\n    const finalFCF = fcfProjections[fcfProjections.length - 1]?.unleveredFCF || 0;\n\n    // Calculate terminal value\n    const terminalValue = this.calculateTerminalValue(\n      finalFCF,\n      assumptions.terminalGrowthRate,\n      wacc\n    );\n\n    // Extract FCF values for present value calculation\n    const fcfValues = fcfProjections.map(fcf => fcf.unleveredFCF);\n\n    // Calculate present values\n    const pvOfCashFlows = this.calculatePresentValue(fcfValues, wacc);\n    const pvOfTerminalValue = this.calculatePresentValue([terminalValue], wacc, assumptions.projectionYears);\n\n    // Calculate enterprise and equity values\n    const enterpriseValue = pvOfCashFlows + pvOfTerminalValue;\n    const equityValue = enterpriseValue - totalDebt + cash;\n    const pricePerShare = sharesOutstanding > 0 ? equityValue / sharesOutstanding : 0;\n\n    // Calculate valuation metrics\n    const upside = currentPrice ? ((pricePerShare - currentPrice) / currentPrice) * 100 : null;\n\n    return {\n      scenarioName,\n      revenueProjections,\n      operatingProjections,\n      fcfProjections,\n      terminalValue,\n      pvOfCashFlows,\n      pvOfTerminalValue,\n      enterpriseValue,\n      equityValue,\n      pricePerShare,\n      currentPrice,\n      upside,\n      wacc,\n      terminalGrowthRate: assumptions.terminalGrowthRate,\n      impliedMultiples: this.calculateImpliedMultiples(enterpriseValue, operatingProjections, fcfProjections, currentRevenue)\n    };\n  }\n\n  /**\n   * Project revenue growth over multiple years\n   * @param {number} baseRevenue - Starting revenue\n   * @param {number|Array} growthRates - Growth rate(s)\n   * @param {number} years - Number of years to project\n   * @returns {Array} Revenue projections\n   */\n  projectRevenues(baseRevenue, growthRates, years) {\n    const projections = [];\n    let currentRevenue = baseRevenue;\n\n    for (let i = 0; i < years; i++) {\n      const growthRate = Array.isArray(growthRates)\n        ? growthRates[i] || growthRates[growthRates.length - 1]\n        : growthRates * Math.pow(0.95, i); // Declining growth rate\n\n      currentRevenue *= (1 + growthRate);\n      projections.push({\n        year: i + 1,\n        revenue: currentRevenue,\n        growthRate\n      });\n    }\n\n    return projections;\n  }\n\n  /**\n   * Project operating metrics (EBITDA, margins, etc.)\n   * @param {Array} revenueProjections - Revenue projections\n   * @param {Object} assumptions - Model assumptions\n   * @returns {Array} Operating projections\n   */\n  projectOperatingMetrics(revenueProjections, assumptions) {\n    return revenueProjections.map((projection, index) => {\n      const ebitdaMargin = assumptions.ebitdaMargin || 0.2;\n      const ebitda = projection.revenue * ebitdaMargin;\n      const depreciation = projection.revenue * assumptions.depreciationAsPercentOfRevenue;\n      const ebit = ebitda - depreciation;\n      const taxes = ebit * assumptions.taxRate;\n      const nopat = ebit - taxes;\n\n      return {\n        ...projection,\n        ebitda,\n        ebitdaMargin,\n        depreciation,\n        ebit,\n        taxes,\n        nopat\n      };\n    });\n  }\n\n  /**\n   * Calculate free cash flows with enhanced methodology\n   * @param {Array} operatingProjections - Operating projections\n   * @param {Object} assumptions - Model assumptions\n   * @returns {Array} Free cash flow projections with detailed breakdown\n   */\n  calculateFreeCashFlows(operatingProjections, assumptions) {\n    return operatingProjections.map((projection, index) => {\n      // More sophisticated CapEx modeling\n      const maintenanceCapex = projection.revenue * (assumptions.maintenanceCapexRate || 0.015);\n      const growthCapex = index > 0 ?\n        (projection.revenue - operatingProjections[index - 1].revenue) * (assumptions.growthCapexRate || 0.8) : 0;\n      const totalCapex = maintenanceCapex + growthCapex;\n\n      // Enhanced working capital calculation\n      const nwcChange = this.calculateWorkingCapitalChange(projection, operatingProjections[index - 1], assumptions);\n\n      // Add non-cash charges beyond depreciation\n      const stockBasedComp = projection.revenue * (assumptions.stockBasedCompRate || 0.005);\n      const otherNonCash = projection.revenue * (assumptions.otherNonCashRate || 0.001);\n      const totalNonCash = projection.depreciation + stockBasedComp + otherNonCash;\n\n      // Calculate unlevered FCF\n      const fcf = projection.nopat + totalNonCash - totalCapex - nwcChange;\n\n      return {\n        year: index + 1,\n        nopat: projection.nopat,\n        depreciation: projection.depreciation,\n        stockBasedComp,\n        otherNonCash,\n        totalNonCash,\n        maintenanceCapex,\n        growthCapex,\n        totalCapex,\n        nwcChange,\n        unleveredFCF: fcf,\n        fcfMargin: projection.revenue > 0 ? fcf / projection.revenue : 0\n      };\n    });\n  }\n\n  /**\n   * Calculate working capital change with detailed components\n   * @param {Object} currentProjection - Current year projection\n   * @param {Object} priorProjection - Prior year projection\n   * @param {Object} assumptions - Model assumptions\n   * @returns {number} Working capital change\n   */\n  calculateWorkingCapitalChange(currentProjection, priorProjection, assumptions) {\n    if (!priorProjection) {\n      return currentProjection.revenue * assumptions.nwcAsPercentOfRevenue;\n    }\n\n    // Component-based NWC calculation\n    const receivablesDays = assumptions.receivablesDays || 45;\n    const inventoryDays = assumptions.inventoryDays || 30;\n    const payablesDays = assumptions.payablesDays || 35;\n\n    const currentReceivables = (currentProjection.revenue * receivablesDays) / 365;\n    const currentInventory = (currentProjection.revenue * inventoryDays) / 365 * (assumptions.cogsPct || 0.6);\n    const currentPayables = (currentProjection.revenue * payablesDays) / 365 * (assumptions.cogsPct || 0.6);\n    const currentNWC = currentReceivables + currentInventory - currentPayables;\n\n    const priorReceivables = (priorProjection.revenue * receivablesDays) / 365;\n    const priorInventory = (priorProjection.revenue * inventoryDays) / 365 * (assumptions.cogsPct || 0.6);\n    const priorPayables = (priorProjection.revenue * payablesDays) / 365 * (assumptions.cogsPct || 0.6);\n    const priorNWC = priorReceivables + priorInventory - priorPayables;\n\n    return currentNWC - priorNWC;\n  }\n\n  /**\n   * Calculate terminal value using Gordon Growth Model with validation\n   * @param {number} finalFCF - Final year free cash flow\n   * @param {number} terminalGrowthRate - Terminal growth rate\n   * @param {number} discountRate - Discount rate (WACC)\n   * @param {Object} options - Additional options for terminal value calculation\n   * @returns {number} Terminal value\n   */\n  calculateTerminalValue(finalFCF, terminalGrowthRate, discountRate, options = {}) {\n    // Enhanced validation\n    if (discountRate <= terminalGrowthRate) {\n      throw new Error(`Discount rate (${(discountRate * 100).toFixed(2)}%) must be greater than terminal growth rate (${(terminalGrowthRate * 100).toFixed(2)}%)`);\n    }\n\n    if (terminalGrowthRate < 0 || terminalGrowthRate > 0.05) {\n      console.warn(`Terminal growth rate ${(terminalGrowthRate * 100).toFixed(2)}% is outside typical range (0-5%)`);\n    }\n\n    if (finalFCF <= 0) {\n      console.warn('Final year FCF is negative or zero, terminal value calculation may be unreliable');\n    }\n\n    // Multiple terminal value methods\n    const { method = 'gordon', exitMultiple = null, fadeToGrowth = false } = options;\n\n    switch (method) {\n      case 'gordon':\n        return (finalFCF * (1 + terminalGrowthRate)) / (discountRate - terminalGrowthRate);\n\n      case 'exit_multiple':\n        if (exitMultiple && finalFCF > 0) {\n          // Assume FCF approximates EBITDA for multiple calculation\n          return finalFCF * exitMultiple;\n        }\n        return (finalFCF * (1 + terminalGrowthRate)) / (discountRate - terminalGrowthRate);\n\n      case 'fade_to_growth':\n        // Implement fade-to-growth model where high growth fades to long-term rate\n        const fadeYears = options.fadeYears || 5;\n        const longTermGrowth = options.longTermGrowth || 0.025;\n        let terminalValue = 0;\n\n        for (let year = 1; year <= fadeYears; year++) {\n          const fadeRate = terminalGrowthRate * Math.pow((fadeYears - year + 1) / fadeYears, 2) +\n                          longTermGrowth * Math.pow(year / fadeYears, 2);\n          const yearFCF = finalFCF * Math.pow(1 + fadeRate, year);\n          terminalValue += yearFCF / Math.pow(1 + discountRate, year);\n        }\n\n        // Add perpetual value after fade period\n        const finalFadeFCF = finalFCF * Math.pow(1 + longTermGrowth, fadeYears);\n        const perpetualValue = finalFadeFCF / (discountRate - longTermGrowth);\n        terminalValue += perpetualValue / Math.pow(1 + discountRate, fadeYears);\n\n        return terminalValue;\n\n      default:\n        return (finalFCF * (1 + terminalGrowthRate)) / (discountRate - terminalGrowthRate);\n    }\n  }\n\n  /**\n   * Calculate present value of cash flows\n   * @param {Array} cashFlows - Array of cash flows\n   * @param {number} discountRate - Discount rate\n   * @param {number} startYear - Starting year for discounting\n   * @returns {number} Present value\n   */\n  calculatePresentValue(cashFlows, discountRate, startYear = 0) {\n    return cashFlows.reduce((pv, cf, index) => {\n      const year = startYear + index + 1;\n      return pv + cf / Math.pow(1 + discountRate, year);\n    }, 0);\n  }\n\n  /**\n   * Calculate comprehensive implied valuation multiples\n   * @param {number} enterpriseValue - Enterprise value\n   * @param {Array} operatingProjections - Operating projections\n   * @param {Array} fcfProjections - Free cash flow projections\n   * @param {number} currentRevenue - Current year revenue\n   * @returns {Object} Comprehensive implied multiples\n   */\n  calculateImpliedMultiples(enterpriseValue, operatingProjections, fcfProjections = [], currentRevenue = 0) {\n    const currentYearEbitda = operatingProjections[0]?.ebitda || 0;\n    const nextYearEbitda = operatingProjections[1]?.ebitda || 0;\n    const currentYearEbit = operatingProjections[0]?.ebit || 0;\n    const nextYearEbit = operatingProjections[1]?.ebit || 0;\n    const nextYearRevenue = operatingProjections[1]?.revenue || 0;\n    const currentYearFCF = fcfProjections[0]?.unleveredFCF || 0;\n    const nextYearFCF = fcfProjections[1]?.unleveredFCF || 0;\n\n    return {\n      // Revenue multiples\n      evToCurrentRevenue: currentRevenue ? enterpriseValue / currentRevenue : null,\n      evToForwardRevenue: nextYearRevenue ? enterpriseValue / nextYearRevenue : null,\n\n      // EBITDA multiples\n      evToCurrentEbitda: currentYearEbitda ? enterpriseValue / currentYearEbitda : null,\n      evToForwardEbitda: nextYearEbitda ? enterpriseValue / nextYearEbitda : null,\n\n      // EBIT multiples\n      evToCurrentEbit: currentYearEbit ? enterpriseValue / currentYearEbit : null,\n      evToForwardEbit: nextYearEbit ? enterpriseValue / nextYearEbit : null,\n\n      // FCF multiples\n      evToCurrentFCF: currentYearFCF ? enterpriseValue / currentYearFCF : null,\n      evToForwardFCF: nextYearFCF ? enterpriseValue / nextYearFCF : null,\n\n      // PEG ratio approximation (P/E to Growth)\n      pegRatio: this.calculatePEGRatio(operatingProjections, enterpriseValue)\n    };\n  }\n\n  /**\n   * Calculate PEG ratio approximation\n   * @param {Array} operatingProjections - Operating projections\n   * @param {number} enterpriseValue - Enterprise value\n   * @returns {number} PEG ratio\n   */\n  calculatePEGRatio(operatingProjections, enterpriseValue) {\n    if (operatingProjections.length < 2) return null;\n\n    const currentEarnings = operatingProjections[0]?.nopat || 0;\n    const futureEarnings = operatingProjections[operatingProjections.length - 1]?.nopat || 0;\n\n    if (currentEarnings <= 0 || futureEarnings <= 0) return null;\n\n    const growthRate = Math.pow(futureEarnings / currentEarnings, 1 / (operatingProjections.length - 1)) - 1;\n    const peRatio = enterpriseValue / currentEarnings;\n\n    return growthRate > 0 ? peRatio / (growthRate * 100) : null;\n  }\n\n  /**\n   * Perform sensitivity analysis on key variables\n   * @param {Object} inputs - Model inputs\n   * @param {Object} baseAssumptions - Base case assumptions\n   * @returns {Object} Sensitivity analysis results\n   */\n  performDCFSensitivityAnalysis(inputs, baseAssumptions) {\n    const sensitivityVars = {\n      revenueGrowthRate: [-0.02, -0.01, 0, 0.01, 0.02],\n      wacc: [-0.005, -0.0025, 0, 0.0025, 0.005],\n      terminalGrowthRate: [-0.005, -0.0025, 0, 0.0025, 0.005],\n      ebitdaMargin: [-0.02, -0.01, 0, 0.01, 0.02]\n    };\n\n    const results = {};\n\n    Object.entries(sensitivityVars).forEach(([variable, variations]) => {\n      results[variable] = variations.map(variation => {\n        const adjustedAssumptions = {\n          ...baseAssumptions,\n          [variable]: (baseAssumptions[variable] || 0) + variation\n        };\n\n        try {\n          const scenario = this.calculateDCFScenario(inputs, adjustedAssumptions, `${variable}_${variation}`);\n          return {\n            variation,\n            pricePerShare: scenario.pricePerShare,\n            upside: scenario.upside\n          };\n        } catch (error) {\n          return {\n            variation,\n            pricePerShare: null,\n            upside: null,\n            error: error.message\n          };\n        }\n      });\n    });\n\n    return results;\n  }\n\n  /**\n   * Generate DCF model summary\n   * @param {Object} baseCase - Base case results\n   * @param {Object} scenarios - Scenario results\n   * @param {number} currentPrice - Current stock price\n   * @returns {Object} Model summary\n   */\n  generateDCFSummary(baseCase, scenarios, currentPrice) {\n    const allScenarios = [baseCase, ...Object.values(scenarios)];\n    const pricesPerShare = allScenarios.map(s => s.pricePerShare).filter(p => p !== null);\n\n    return {\n      priceRange: {\n        min: Math.min(...pricesPerShare),\n        max: Math.max(...pricesPerShare),\n        average: pricesPerShare.reduce((sum, p) => sum + p, 0) / pricesPerShare.length\n      },\n      recommendation: this.generateRecommendation(baseCase, currentPrice),\n      keyMetrics: {\n        baseCase: {\n          pricePerShare: baseCase.pricePerShare,\n          upside: baseCase.upside,\n          enterpriseValue: baseCase.enterpriseValue\n        },\n        currentPrice,\n        impliedReturn: baseCase.upside\n      }\n    };\n  }\n\n  /**\n   * Generate investment recommendation\n   * @param {Object} baseCase - Base case DCF results\n   * @param {number} currentPrice - Current stock price\n   * @returns {Object} Investment recommendation\n   */\n  generateRecommendation(baseCase, currentPrice) {\n    if (!currentPrice || !baseCase.pricePerShare) {\n      return { rating: 'INSUFFICIENT_DATA', confidence: 0 };\n    }\n\n    const upside = baseCase.upside;\n    let rating, confidence;\n\n    if (upside > 20) {\n      rating = 'STRONG_BUY';\n      confidence = Math.min(95, 70 + (upside - 20) * 1.25);\n    } else if (upside > 10) {\n      rating = 'BUY';\n      confidence = Math.min(85, 60 + (upside - 10) * 2);\n    } else if (upside > -10) {\n      rating = 'HOLD';\n      confidence = Math.min(75, 50 + Math.abs(upside) * 2.5);\n    } else if (upside > -20) {\n      rating = 'SELL';\n      confidence = Math.min(85, 60 + Math.abs(upside + 10) * 2);\n    } else {\n      rating = 'STRONG_SELL';\n      confidence = Math.min(95, 70 + Math.abs(upside + 20) * 1.25);\n    }\n\n    return {\n      rating,\n      confidence: Math.round(confidence),\n      upside,\n      reasoning: this.generateRecommendationReasoning(rating, upside)\n    };\n  }\n\n  /**\n   * Generate reasoning for investment recommendation\n   * @param {string} rating - Investment rating\n   * @param {number} upside - Upside percentage\n   * @returns {string} Recommendation reasoning\n   */\n  generateRecommendationReasoning(rating, upside) {\n    const upsideAbs = Math.abs(upside);\n\n    switch (rating) {\n      case 'STRONG_BUY':\n        return `Strong upside potential of ${upside.toFixed(1)}% suggests significant undervaluation based on DCF analysis.`;\n      case 'BUY':\n        return `Moderate upside of ${upside.toFixed(1)}% indicates the stock is undervalued relative to intrinsic value.`;\n      case 'HOLD':\n        return `Fair valuation with ${upside >= 0 ? 'limited upside' : 'modest downside'} of ${upsideAbs.toFixed(1)}%.`;\n      case 'SELL':\n        return `Downside risk of ${upsideAbs.toFixed(1)}% suggests the stock is overvalued based on fundamental analysis.`;\n      case 'STRONG_SELL':\n        return `Significant downside of ${upsideAbs.toFixed(1)}% indicates substantial overvaluation.`;\n      default:\n        return 'Insufficient data for reliable recommendation.';\n    }\n  }\n}\n\n// Export singleton instance\nexport const financialModelingEngine = new FinancialModelingEngine();\nexport default FinancialModelingEngine;\n","import { apiLogger } from '../utils/apiLogger.js';\n\n/**\n * Advanced LBO (Leveraged Buyout) Modeling Engine\n * Provides comprehensive LBO analysis with debt schedules and cash flow waterfalls\n */\nclass LBOModelingEngine {\n  constructor() {\n    this.modelCache = new Map();\n    this.assumptions = this.getDefaultAssumptions();\n  }\n\n  /**\n   * Get default LBO modeling assumptions\n   */\n  getDefaultAssumptions() {\n    return {\n      transaction: {\n        holdingPeriod: 5,\n        managementRollover: 0.1, // 10% management rollover\n        transactionFees: 0.02, // 2% of transaction value\n        financingFees: 0.015 // 1.5% of debt\n      },\n      debt: {\n        seniorDebtMultiple: 4.0,\n        subordinatedDebtMultiple: 1.5,\n        totalDebtMultiple: 5.5,\n        seniorInterestRate: 0.055, // 5.5%\n        subordinatedInterestRate: 0.095, // 9.5%\n        mandatoryPaydown: 0.05, // 5% annually\n        cashSweep: 0.5 // 50% of excess cash\n      },\n      operating: {\n        ebitdaGrowthRate: 0.05, // 5% annually\n        capexAsPercentOfRevenue: 0.03,\n        nwcAsPercentOfRevenue: 0.02,\n        taxRate: 0.21\n      },\n      exit: {\n        exitMultiple: null, // Will use peer average\n        exitMultipleRange: [0.8, 1.2], // 80% to 120% of peer average\n        publicMarketDiscount: 0.1 // 10% discount for public exit\n      },\n      fees: {\n        managementFeeRate: 0.02, // 2% annually\n        carriedInterestRate: 0.2, // 20%\n        hurdle: 0.08 // 8% preferred return\n      }\n    };\n  }\n\n  /**\n   * Build comprehensive LBO model\n   * @param {Object} inputs - LBO model inputs\n   * @param {Object} scenarios - Different scenario assumptions\n   * @returns {Object} Complete LBO analysis\n   */\n  buildLBOModel(inputs, scenarios = {}) {\n    const {\n      symbol,\n      companyName,\n      purchasePrice,\n      ebitda,\n      revenue,\n      marketData = {},\n      peerData = {},\n      assumptions = {}\n    } = inputs;\n\n    // Merge with default assumptions\n    const modelAssumptions = { ...this.assumptions, ...assumptions };\n\n    // Calculate transaction structure\n    const transactionStructure = this.calculateTransactionStructure(\n      purchasePrice,\n      ebitda,\n      modelAssumptions\n    );\n\n    // Build base case scenario\n    const baseCase = this.calculateLBOScenario(\n      inputs,\n      transactionStructure,\n      modelAssumptions,\n      'Base Case'\n    );\n\n    // Build additional scenarios\n    const scenarioResults = {};\n\n    // Upside case: Higher growth and exit multiple\n    if (scenarios.upside !== false) {\n      const upsideAssumptions = {\n        ...modelAssumptions,\n        operating: {\n          ...modelAssumptions.operating,\n          ebitdaGrowthRate: modelAssumptions.operating.ebitdaGrowthRate * 1.3\n        },\n        exit: {\n          ...modelAssumptions.exit,\n          exitMultiple: (modelAssumptions.exit.exitMultiple || 10) * 1.1\n        }\n      };\n      scenarioResults.upside = this.calculateLBOScenario(\n        inputs,\n        transactionStructure,\n        upsideAssumptions,\n        'Upside Case'\n      );\n    }\n\n    // Downside case: Lower growth and exit multiple\n    if (scenarios.downside !== false) {\n      const downsideAssumptions = {\n        ...modelAssumptions,\n        operating: {\n          ...modelAssumptions.operating,\n          ebitdaGrowthRate: modelAssumptions.operating.ebitdaGrowthRate * 0.7\n        },\n        exit: {\n          ...modelAssumptions.exit,\n          exitMultiple: (modelAssumptions.exit.exitMultiple || 10) * 0.9\n        }\n      };\n      scenarioResults.downside = this.calculateLBOScenario(\n        inputs,\n        transactionStructure,\n        downsideAssumptions,\n        'Downside Case'\n      );\n    }\n\n    // Calculate sensitivity analysis\n    const sensitivityAnalysis = this.performLBOSensitivityAnalysis(\n      inputs,\n      transactionStructure,\n      modelAssumptions\n    );\n\n    return {\n      symbol,\n      companyName,\n      modelType: 'LBO',\n      timestamp: new Date().toISOString(),\n      transactionStructure,\n      baseCase,\n      scenarios: scenarioResults,\n      sensitivityAnalysis,\n      assumptions: modelAssumptions,\n      summary: this.generateLBOSummary(baseCase, scenarioResults, transactionStructure)\n    };\n  }\n\n  /**\n   * Calculate transaction structure and financing\n   * @param {number} purchasePrice - Total purchase price\n   * @param {number} ebitda - Current EBITDA\n   * @param {Object} assumptions - Model assumptions\n   * @returns {Object} Transaction structure\n   */\n  calculateTransactionStructure(purchasePrice, ebitda, assumptions) {\n    const { debt, transaction } = assumptions;\n\n    // Calculate debt capacity based on EBITDA multiples\n    const seniorDebt = ebitda * debt.seniorDebtMultiple;\n    const subordinatedDebt = ebitda * debt.subordinatedDebtMultiple;\n    const totalDebt = seniorDebt + subordinatedDebt;\n\n    // Calculate transaction costs\n    const transactionFees = purchasePrice * transaction.transactionFees;\n    const financingFees = totalDebt * transaction.financingFees;\n    const totalUses = purchasePrice + transactionFees + financingFees;\n\n    // Calculate equity requirement (ensure it's positive)\n    const equityContribution = Math.max(totalUses - totalDebt, totalUses * 0.2); // Minimum 20% equity\n    const managementRollover = purchasePrice * transaction.managementRollover;\n    const sponsorEquity = Math.max(equityContribution - managementRollover, 0);\n\n    // Recalculate total debt if equity was adjusted\n    const adjustedTotalDebt = totalUses - equityContribution;\n    const adjustedSeniorDebt = Math.min(seniorDebt, adjustedTotalDebt * 0.8); // Max 80% senior\n    const adjustedSubordinatedDebt = adjustedTotalDebt - adjustedSeniorDebt;\n\n    return {\n      purchasePrice,\n      transactionFees,\n      financingFees,\n      totalUses,\n      seniorDebt: adjustedSeniorDebt,\n      subordinatedDebt: adjustedSubordinatedDebt,\n      totalDebt: adjustedTotalDebt,\n      equityContribution,\n      sponsorEquity,\n      managementRollover,\n      debtToEbitda: adjustedTotalDebt / ebitda,\n      equityToTotalCapital: equityContribution / totalUses\n    };\n  }\n\n  /**\n   * Calculate LBO scenario with detailed cash flow projections\n   * @param {Object} inputs - Model inputs\n   * @param {Object} transactionStructure - Transaction structure\n   * @param {Object} assumptions - Scenario assumptions\n   * @param {string} scenarioName - Name of the scenario\n   * @returns {Object} LBO scenario results\n   */\n  calculateLBOScenario(inputs, transactionStructure, assumptions, scenarioName) {\n    const { ebitda, revenue } = inputs;\n    const { holdingPeriod } = assumptions.transaction;\n\n    // Project operating performance\n    const operatingProjections = this.projectLBOOperatingPerformance(\n      revenue,\n      ebitda,\n      assumptions.operating,\n      holdingPeriod\n    );\n\n    // Calculate debt schedule\n    const debtSchedule = this.calculateDebtSchedule(\n      transactionStructure,\n      operatingProjections,\n      assumptions.debt,\n      holdingPeriod\n    );\n\n    // Calculate cash flow to equity\n    const equityCashFlows = this.calculateEquityCashFlows(\n      operatingProjections,\n      debtSchedule,\n      assumptions\n    );\n\n    // Calculate exit value and returns\n    const exitAnalysis = this.calculateExitAnalysis(\n      operatingProjections[holdingPeriod - 1],\n      debtSchedule[holdingPeriod - 1],\n      transactionStructure,\n      assumptions\n    );\n\n    // Calculate returns metrics\n    const returnsAnalysis = this.calculateReturnsMetrics(\n      transactionStructure.sponsorEquity,\n      equityCashFlows,\n      exitAnalysis.netProceeds,\n      holdingPeriod\n    );\n\n    return {\n      scenarioName,\n      operatingProjections,\n      debtSchedule,\n      equityCashFlows,\n      exitAnalysis,\n      returnsAnalysis,\n      keyMetrics: this.calculateLBOKeyMetrics(\n        transactionStructure,\n        exitAnalysis,\n        returnsAnalysis\n      )\n    };\n  }\n\n  /**\n   * Project operating performance over holding period\n   * @param {number} baseRevenue - Starting revenue\n   * @param {number} baseEbitda - Starting EBITDA\n   * @param {Object} operatingAssumptions - Operating assumptions\n   * @param {number} years - Number of years\n   * @returns {Array} Operating projections\n   */\n  projectLBOOperatingPerformance(baseRevenue, baseEbitda, operatingAssumptions, years) {\n    const projections = [];\n    let currentRevenue = baseRevenue;\n    let currentEbitda = baseEbitda;\n\n    for (let year = 1; year <= years; year++) {\n      // Assume revenue grows in line with EBITDA\n      const ebitdaGrowth = operatingAssumptions.ebitdaGrowthRate;\n      currentEbitda *= (1 + ebitdaGrowth);\n      currentRevenue *= (1 + ebitdaGrowth);\n\n      const ebitdaMargin = currentEbitda / currentRevenue;\n      const capex = currentRevenue * operatingAssumptions.capexAsPercentOfRevenue;\n      const nwcChange = year === 1\n        ? currentRevenue * operatingAssumptions.nwcAsPercentOfRevenue\n        : (currentRevenue - projections[year - 2].revenue) * operatingAssumptions.nwcAsPercentOfRevenue;\n\n      const taxes = currentEbitda * operatingAssumptions.taxRate;\n      const unleveredFCF = currentEbitda - taxes - capex - nwcChange;\n\n      projections.push({\n        year,\n        revenue: currentRevenue,\n        ebitda: currentEbitda,\n        ebitdaMargin,\n        capex,\n        nwcChange,\n        taxes,\n        unleveredFCF\n      });\n    }\n\n    return projections;\n  }\n\n  /**\n   * Calculate enhanced debt schedule with detailed amortization and covenants\n   * @param {Object} transactionStructure - Transaction structure\n   * @param {Array} operatingProjections - Operating projections\n   * @param {Object} debtAssumptions - Debt assumptions\n   * @param {number} years - Number of years\n   * @returns {Array} Enhanced debt schedule with covenant testing\n   */\n  calculateDebtSchedule(transactionStructure, operatingProjections, debtAssumptions, years) {\n    const schedule = [];\n    let seniorDebtBalance = transactionStructure.seniorDebt;\n    let subordinatedDebtBalance = transactionStructure.subordinatedDebt;\n    const revolvingDebtBalance = transactionStructure.revolvingDebt || 0;\n\n    // Enhanced debt assumptions\n    const enhancedAssumptions = {\n      ...debtAssumptions,\n      revolvingRate: debtAssumptions.revolvingRate || 0.045,\n      minCashBalance: debtAssumptions.minCashBalance || 10000000,\n      // Covenant parameters\n      maxLeverageRatio: debtAssumptions.maxLeverageRatio || 6.0,\n      minCoverageRatio: debtAssumptions.minCoverageRatio || 1.25,\n      maxCapexRatio: debtAssumptions.maxCapexRatio || 0.05\n    };\n\n    for (let year = 1; year <= years; year++) {\n      const projection = operatingProjections[year - 1];\n\n      // Calculate interest expense\n      const seniorInterest = seniorDebtBalance * debtAssumptions.seniorInterestRate;\n      const subordinatedInterest = subordinatedDebtBalance * debtAssumptions.subordinatedInterestRate;\n      const totalInterest = seniorInterest + subordinatedInterest;\n\n      // Calculate available cash for debt paydown\n      const cashAvailableForDebt = projection.unleveredFCF - totalInterest;\n\n      // Mandatory amortization\n      const mandatoryPaydown = Math.min(\n        seniorDebtBalance * debtAssumptions.mandatoryPaydown,\n        seniorDebtBalance\n      );\n\n      // Cash sweep (excess cash after mandatory paydown)\n      const excessCash = Math.max(0, cashAvailableForDebt - mandatoryPaydown);\n      const cashSweep = excessCash * debtAssumptions.cashSweep;\n\n      // Total debt paydown\n      const totalPaydown = mandatoryPaydown + cashSweep;\n      const seniorPaydown = Math.min(totalPaydown, seniorDebtBalance);\n      const subordinatedPaydown = Math.max(0, totalPaydown - seniorPaydown);\n\n      // Update balances\n      seniorDebtBalance = Math.max(0, seniorDebtBalance - seniorPaydown);\n      subordinatedDebtBalance = Math.max(0, subordinatedDebtBalance - subordinatedPaydown);\n\n      // Enhanced debt covenant testing\n      const leverageRatio = (seniorDebtBalance + subordinatedDebtBalance + revolvingDebtBalance) / projection.ebitda;\n      const coverageRatio = projection.ebitda / totalInterest;\n      const capexRatio = (projection.capex || 0) / projection.revenue;\n\n      const covenantTests = {\n        leverageCompliance: leverageRatio <= enhancedAssumptions.maxLeverageRatio,\n        coverageCompliance: coverageRatio >= enhancedAssumptions.minCoverageRatio,\n        capexCompliance: capexRatio <= enhancedAssumptions.maxCapexRatio,\n        leverageRatio,\n        coverageRatio,\n        capexRatio\n      };\n\n      // Calculate debt service coverage ratio (DSCR)\n      const dscr = cashAvailableForDebt / (totalInterest + mandatoryPaydown);\n\n      schedule.push({\n        year,\n        beginningBalance: {\n          senior: year === 1 ? transactionStructure.seniorDebt : schedule[year - 2].endingBalance.senior,\n          subordinated: year === 1 ? transactionStructure.subordinatedDebt : schedule[year - 2].endingBalance.subordinated,\n          revolving: year === 1 ? (transactionStructure.revolvingDebt || 0) : schedule[year - 2].endingBalance.revolving\n        },\n        interestExpense: {\n          senior: seniorInterest,\n          subordinated: subordinatedInterest,\n          revolving: revolvingDebtBalance * enhancedAssumptions.revolvingRate,\n          total: totalInterest + (revolvingDebtBalance * enhancedAssumptions.revolvingRate)\n        },\n        principalPayment: {\n          senior: seniorPaydown,\n          subordinated: subordinatedPaydown,\n          revolving: 0, // Revolving debt typically doesn't amortize\n          total: totalPaydown\n        },\n        endingBalance: {\n          senior: seniorDebtBalance,\n          subordinated: subordinatedDebtBalance,\n          revolving: revolvingDebtBalance,\n          total: seniorDebtBalance + subordinatedDebtBalance + revolvingDebtBalance\n        },\n        cashAvailableForDebt,\n        excessCash: excessCash - cashSweep,\n        mandatoryPaydown,\n        cashSweep,\n        dscr,\n        covenantTests,\n        // Additional debt metrics\n        netDebtToEbitda: (seniorDebtBalance + subordinatedDebtBalance + revolvingDebtBalance) / projection.ebitda,\n        ebitdaToInterest: projection.ebitda / totalInterest\n      });\n    }\n\n    return schedule;\n  }\n\n  /**\n   * Calculate cash flows to equity holders\n   * @param {Array} operatingProjections - Operating projections\n   * @param {Array} debtSchedule - Debt schedule\n   * @param {Object} assumptions - Model assumptions\n   * @returns {Array} Equity cash flows\n   */\n  calculateEquityCashFlows(operatingProjections, debtSchedule, assumptions) {\n    return operatingProjections.map((projection, index) => {\n      const debt = debtSchedule[index];\n      const managementFees = assumptions.fees.managementFeeRate *\n        (assumptions.transaction.sponsorEquity || 0);\n\n      const cashFlowToEquity = debt.excessCash - managementFees;\n\n      return {\n        year: projection.year,\n        unleveredFCF: projection.unleveredFCF,\n        interestExpense: debt.interestExpense.total,\n        principalPayment: debt.principalPayment.total,\n        managementFees,\n        cashFlowToEquity: Math.max(0, cashFlowToEquity)\n      };\n    });\n  }\n\n  /**\n   * Calculate exit analysis and proceeds\n   * @param {Object} finalYearProjection - Final year operating projection\n   * @param {Object} finalYearDebt - Final year debt schedule\n   * @param {Object} transactionStructure - Transaction structure\n   * @param {Object} assumptions - Model assumptions\n   * @returns {Object} Exit analysis\n   */\n  calculateExitAnalysis(finalYearProjection, finalYearDebt, transactionStructure, assumptions) {\n    const exitMultiple = assumptions.exit.exitMultiple || 10;\n    const exitEbitda = finalYearProjection.ebitda;\n\n    const enterpriseValue = exitEbitda * exitMultiple;\n    const totalDebtAtExit = finalYearDebt.endingBalance.total;\n    const grossProceeds = enterpriseValue - totalDebtAtExit;\n\n    // Calculate carried interest\n    const totalReturn = grossProceeds;\n    const investedCapital = transactionStructure.sponsorEquity;\n    const profit = Math.max(0, totalReturn - investedCapital);\n    const carriedInterest = profit * assumptions.fees.carriedInterestRate;\n\n    const netProceeds = grossProceeds - carriedInterest;\n\n    return {\n      exitEbitda,\n      exitMultiple,\n      enterpriseValue,\n      totalDebtAtExit,\n      grossProceeds,\n      carriedInterest,\n      netProceeds,\n      managementProceeds: grossProceeds * (transactionStructure.managementRollover / transactionStructure.equityContribution)\n    };\n  }\n\n  /**\n   * Calculate returns metrics (IRR, MOIC, etc.)\n   * @param {number} initialInvestment - Initial equity investment\n   * @param {Array} equityCashFlows - Annual equity cash flows\n   * @param {number} exitProceeds - Exit proceeds\n   * @param {number} holdingPeriod - Holding period in years\n   * @returns {Object} Returns analysis\n   */\n  calculateReturnsMetrics(initialInvestment, equityCashFlows, exitProceeds, holdingPeriod) {\n    // Validate inputs\n    if (!initialInvestment || initialInvestment <= 0) {\n      return {\n        irr: NaN,\n        moic: NaN,\n        totalCashReturned: 0,\n        initialInvestment: initialInvestment || 0,\n        holdingPeriod,\n        annualizedReturn: NaN\n      };\n    }\n\n    // Calculate total cash flows (negative initial investment, positive distributions and exit)\n    const cashFlows = [-Math.abs(initialInvestment)]; // Ensure initial investment is negative\n\n    // Add annual cash flows\n    equityCashFlows.forEach(cf => {\n      cashFlows.push(cf.cashFlowToEquity || 0);\n    });\n\n    // Add exit proceeds to final year\n    if (cashFlows.length > 1) {\n      cashFlows[cashFlows.length - 1] += (exitProceeds || 0);\n    } else {\n      cashFlows.push(exitProceeds || 0);\n    }\n\n    // Calculate IRR using Newton-Raphson method\n    const irr = this.calculateIRR(cashFlows);\n\n    // Calculate MOIC (Multiple of Invested Capital)\n    const totalCashReturned = equityCashFlows.reduce((sum, cf) => sum + (cf.cashFlowToEquity || 0), 0) + (exitProceeds || 0);\n    const moic = totalCashReturned / Math.abs(initialInvestment);\n\n    return {\n      irr: isNaN(irr) ? 0 : irr, // Default to 0% if IRR calculation fails\n      moic: isNaN(moic) ? 0 : moic,\n      totalCashReturned,\n      initialInvestment: Math.abs(initialInvestment),\n      holdingPeriod,\n      annualizedReturn: isNaN(moic) || moic <= 0 ? 0 : Math.pow(moic, 1 / holdingPeriod) - 1,\n      cashFlows // Include for debugging\n    };\n  }\n\n  /**\n   * Calculate IRR using enhanced Newton-Raphson method with multiple fallbacks\n   * @param {Array} cashFlows - Array of cash flows\n   * @param {Object} options - Calculation options\n   * @returns {number} IRR as decimal\n   */\n  calculateIRR(cashFlows, options = {}) {\n    // Validate cash flows\n    if (!cashFlows || cashFlows.length < 2) {\n      return NaN;\n    }\n\n    // Check if all cash flows are zero\n    if (cashFlows.every(cf => cf === 0)) {\n      return 0;\n    }\n\n    // Check if there's no sign change (no valid IRR)\n    const signChanges = cashFlows.slice(1).reduce((count, cf, i) => {\n      return count + (Math.sign(cf) !== Math.sign(cashFlows[i]) ? 1 : 0);\n    }, 0);\n\n    if (signChanges === 0) {\n      return cashFlows[0] < 0 ? -1 : Infinity; // No valid IRR\n    }\n\n    const { tolerance = 1e-8, maxIterations = 200, initialGuess = 0.1 } = options;\n\n    // Try Newton-Raphson method first\n    let rate = this.newtonRaphsonIRR(cashFlows, initialGuess, tolerance, maxIterations);\n\n    // If Newton-Raphson fails, try bisection method\n    if (isNaN(rate) || !isFinite(rate)) {\n      rate = this.bisectionIRR(cashFlows, tolerance, maxIterations);\n    }\n\n    // If both fail, try Secant method\n    if (isNaN(rate) || !isFinite(rate)) {\n      rate = this.secantIRR(cashFlows, tolerance, maxIterations);\n    }\n\n    return rate;\n  }\n\n  /**\n   * Newton-Raphson method for IRR calculation\n   */\n  newtonRaphsonIRR(cashFlows, initialGuess, tolerance, maxIterations) {\n    let rate = initialGuess;\n\n    for (let i = 0; i < maxIterations; i++) {\n      let npv = 0;\n      let dnpv = 0;\n\n      for (let j = 0; j < cashFlows.length; j++) {\n        const factor = Math.pow(1 + rate, j);\n        npv += cashFlows[j] / factor;\n        if (j > 0) {\n          dnpv -= (j * cashFlows[j]) / (factor * (1 + rate));\n        }\n      }\n\n      if (Math.abs(npv) < tolerance) {\n        return rate;\n      }\n\n      if (Math.abs(dnpv) < Number.EPSILON) {\n        break; // Avoid division by near-zero derivative\n      }\n\n      const proposed = rate - npv / dnpv;\n\n      // Clamp to sane bounds\n      const clamped = Math.max(-0.99, Math.min(proposed, 50));\n\n      // Check for convergence against previous iterate\n      if (Math.abs(clamped - rate) < tolerance) {\n        return clamped;\n      }\n\n      rate = clamped;\n    }\n\n    return rate;\n  }\n\n  /**\n   * Bisection method for IRR calculation (fallback)\n   */\n  bisectionIRR(cashFlows, tolerance, maxIterations) {\n    let low = -0.99;\n    let high = 5.0;\n\n    // Check if bounds contain a root\n    let npvLow = this.calculateNPV(cashFlows, low);\n    let npvHigh = this.calculateNPV(cashFlows, high);\n\n    if (npvLow * npvHigh > 0) {\n      return NaN; // No root in bounds\n    }\n\n    for (let i = 0; i < maxIterations; i++) {\n      const mid = (low + high) / 2;\n      const npvMid = this.calculateNPV(cashFlows, mid);\n\n      if (Math.abs(npvMid) < tolerance) {\n        return mid;\n      }\n\n      // Decide which subinterval contains the root and update both bound and its NPV\n      if (npvLow * npvMid < 0) {\n        high = mid;\n        npvHigh = npvMid;\n      } else {\n        low = mid;\n        npvLow = npvMid;\n      }\n\n      if (Math.abs(high - low) < tolerance) {\n        return (low + high) / 2;\n      }\n    }\n\n    return (low + high) / 2;\n  }\n\n  /**\n   * Secant method for IRR calculation (second fallback)\n   */\n  secantIRR(cashFlows, tolerance, maxIterations) {\n    let x0 = 0;\n    let x1 = 0.1;\n\n    for (let i = 0; i < maxIterations; i++) {\n      const f0 = this.calculateNPV(cashFlows, x0);\n      const f1 = this.calculateNPV(cashFlows, x1);\n\n      if (Math.abs(f1) < tolerance) {\n        return x1;\n      }\n\n      if (Math.abs(f1 - f0) < tolerance) {\n        break;\n      }\n\n      const x2 = x1 - f1 * (x1 - x0) / (f1 - f0);\n\n      if (Math.abs(x2 - x1) < tolerance) {\n        return x2;\n      }\n\n      x0 = x1;\n      x1 = x2;\n    }\n\n    return x1;\n  }\n\n  /**\n   * Calculate NPV for a given discount rate\n   */\n  calculateNPV(cashFlows, rate) {\n    return cashFlows.reduce((npv, cf, index) => {\n      return npv + cf / Math.pow(1 + rate, index);\n    }, 0);\n  }\n\n  /**\n   * Calculate comprehensive LBO metrics summary with advanced ratios\n   * @param {Object} transactionStructure - Transaction structure\n   * @param {Object} exitAnalysis - Exit analysis\n   * @param {Object} returnsAnalysis - Returns analysis\n   * @param {Array} debtSchedule - Debt schedule for additional metrics\n   * @returns {Object} Comprehensive key metrics\n   */\n  calculateLBOKeyMetrics(transactionStructure, exitAnalysis, returnsAnalysis, debtSchedule = []) {\n    // Calculate entry EBITDA multiple\n    const impliedEntryEbitda = transactionStructure.purchasePrice / (transactionStructure.entryMultiple || 10);\n    const actualEntryMultiple = impliedEntryEbitda > 0 ? transactionStructure.purchasePrice / impliedEntryEbitda : null;\n\n    // Calculate leverage metrics\n    const peakLeverage = Math.max(...debtSchedule.map(d => d.netDebtToEbitda || 0));\n    const minCoverage = Math.min(...debtSchedule.map(d => d.ebitdaToInterest || Infinity));\n    const avgDSCR = debtSchedule.length > 0 ?\n      debtSchedule.reduce((sum, d) => sum + (d.dscr || 0), 0) / debtSchedule.length : 0;\n\n    // Calculate multiple arbitrage components\n    const multipleExpansion = exitAnalysis.exitMultiple - (actualEntryMultiple || 10);\n    const operationalImprovement = returnsAnalysis.moic - 1 - multipleExpansion;\n    const leverage = transactionStructure.totalDebt / transactionStructure.equityContribution;\n\n    return {\n      // Entry metrics\n      entryMultiple: actualEntryMultiple,\n      entryLeverage: transactionStructure.debtToEbitda,\n      equityContribution: transactionStructure.equityContribution,\n      debtToEquity: leverage,\n\n      // Exit metrics\n      exitMultiple: exitAnalysis.exitMultiple,\n      exitLeverage: exitAnalysis.totalDebtAtExit / exitAnalysis.exitEbitda,\n\n      // Returns metrics\n      irr: returnsAnalysis.irr,\n      moic: returnsAnalysis.moic,\n      totalReturn: returnsAnalysis.totalCashReturned,\n\n      // Leverage and credit metrics\n      leverageReduction: transactionStructure.totalDebt - exitAnalysis.totalDebtAtExit,\n      peakLeverage,\n      minCoverage,\n      avgDSCR,\n\n      // Value creation analysis\n      multipleExpansion,\n      operationalImprovement,\n      leverageContribution: leverage > 1 ? (returnsAnalysis.moic - 1) * (leverage - 1) / leverage : 0,\n\n      // Risk metrics\n      breakdownLeverage: debtSchedule.length > 0 ?\n        Math.max(...debtSchedule.map(d => d.leverageRatio || 0)) : null,\n      covenantBreaches: debtSchedule.filter(d =>\n        d.covenantTests && (!d.covenantTests.leverageCompliance || !d.covenantTests.coverageCompliance)\n      ).length,\n\n      // Efficiency ratios\n      equityEfficiency: returnsAnalysis.totalCashReturned / transactionStructure.equityContribution,\n      timeToRecoverEquity: this.calculateTimeToRecoverEquity(returnsAnalysis.cashFlows, transactionStructure.equityContribution)\n    };\n  }\n\n  /**\n   * Calculate time to recover initial equity investment\n   * @param {Array} cashFlows - Array of cash flows\n   * @param {number} initialEquity - Initial equity investment\n   * @returns {number} Years to recover equity\n   */\n  calculateTimeToRecoverEquity(cashFlows, initialEquity) {\n    if (!cashFlows || cashFlows.length === 0) return null;\n\n    let cumulativeCashFlow = 0;\n\n    for (let i = 1; i < cashFlows.length; i++) { // Skip initial investment\n      cumulativeCashFlow += cashFlows[i];\n      if (cumulativeCashFlow >= initialEquity) {\n        return i;\n      }\n    }\n\n    return null; // Equity not recovered within holding period\n  }\n\n  /**\n   * Perform sensitivity analysis on key LBO variables\n   * @param {Object} inputs - Model inputs\n   * @param {Object} transactionStructure - Transaction structure\n   * @param {Object} baseAssumptions - Base case assumptions\n   * @returns {Object} Sensitivity analysis results\n   */\n  performLBOSensitivityAnalysis(inputs, transactionStructure, baseAssumptions) {\n    const sensitivityVars = {\n      ebitdaGrowthRate: [-0.02, -0.01, 0, 0.01, 0.02],\n      exitMultiple: [-1, -0.5, 0, 0.5, 1],\n      debtMultiple: [-0.5, -0.25, 0, 0.25, 0.5]\n    };\n\n    const results = {};\n\n    Object.entries(sensitivityVars).forEach(([variable, variations]) => {\n      results[variable] = variations.map(variation => {\n        const adjustedAssumptions = { ...baseAssumptions };\n\n        if (variable === 'ebitdaGrowthRate') {\n          adjustedAssumptions.operating.ebitdaGrowthRate += variation;\n        } else if (variable === 'exitMultiple') {\n          adjustedAssumptions.exit.exitMultiple = (adjustedAssumptions.exit.exitMultiple || 10) + variation;\n        } else if (variable === 'debtMultiple') {\n          // Adjust transaction structure for debt multiple sensitivity\n          const newDebtMultiple = transactionStructure.debtToEbitda + variation;\n          const adjustedStructure = {\n            ...transactionStructure,\n            totalDebt: (inputs.ebitda * newDebtMultiple),\n            debtToEbitda: newDebtMultiple\n          };\n          adjustedStructure.equityContribution = transactionStructure.totalUses - adjustedStructure.totalDebt;\n        }\n\n        try {\n          const scenario = this.calculateLBOScenario(inputs, transactionStructure, adjustedAssumptions, `${variable}_${variation}`);\n          return {\n            variation,\n            irr: scenario.returnsAnalysis.irr,\n            moic: scenario.returnsAnalysis.moic\n          };\n        } catch (error) {\n          return {\n            variation,\n            irr: null,\n            moic: null,\n            error: error.message\n          };\n        }\n      });\n    });\n\n    return results;\n  }\n\n  /**\n   * Generate LBO model summary\n   * @param {Object} baseCase - Base case results\n   * @param {Object} scenarios - Scenario results\n   * @param {Object} transactionStructure - Transaction structure\n   * @returns {Object} Model summary\n   */\n  generateLBOSummary(baseCase, scenarios, transactionStructure) {\n    const allScenarios = [baseCase, ...Object.values(scenarios)];\n    const irrs = allScenarios.map(s => s.returnsAnalysis.irr).filter(irr => irr !== null);\n    const moics = allScenarios.map(s => s.returnsAnalysis.moic).filter(moic => moic !== null);\n\n    return {\n      returnRange: {\n        irrMin: Math.min(...irrs),\n        irrMax: Math.max(...irrs),\n        irrAverage: irrs.reduce((sum, irr) => sum + irr, 0) / irrs.length,\n        moicMin: Math.min(...moics),\n        moicMax: Math.max(...moics),\n        moicAverage: moics.reduce((sum, moic) => sum + moic, 0) / moics.length\n      },\n      investmentHighlights: this.generateInvestmentHighlights(baseCase, transactionStructure),\n      riskFactors: this.generateRiskFactors(baseCase, transactionStructure)\n    };\n  }\n\n  /**\n   * Generate investment highlights\n   * @param {Object} baseCase - Base case results\n   * @param {Object} transactionStructure - Transaction structure\n   * @returns {Array} Investment highlights\n   */\n  generateInvestmentHighlights(baseCase, transactionStructure) {\n    const highlights = [];\n    const irr = baseCase.returnsAnalysis.irr;\n    const moic = baseCase.returnsAnalysis.moic;\n\n    if (irr > 0.2) {\n      highlights.push(`Strong projected IRR of ${(irr * 100).toFixed(1)}%`);\n    }\n\n    if (moic > 2.5) {\n      highlights.push(`Attractive multiple of ${moic.toFixed(1)}x invested capital`);\n    }\n\n    if (transactionStructure.debtToEbitda < 5) {\n      highlights.push(`Conservative leverage at ${transactionStructure.debtToEbitda.toFixed(1)}x EBITDA`);\n    }\n\n    return highlights;\n  }\n\n  /**\n   * Generate risk factors\n   * @param {Object} baseCase - Base case results\n   * @param {Object} transactionStructure - Transaction structure\n   * @returns {Array} Risk factors\n   */\n  generateRiskFactors(baseCase, transactionStructure) {\n    const risks = [];\n\n    if (transactionStructure.debtToEbitda > 6) {\n      risks.push(`High leverage at ${transactionStructure.debtToEbitda.toFixed(1)}x EBITDA`);\n    }\n\n    if (baseCase.returnsAnalysis.irr < 0.15) {\n      risks.push(`Below-target IRR of ${(baseCase.returnsAnalysis.irr * 100).toFixed(1)}%`);\n    }\n\n    return risks;\n  }\n}\n\n// Export singleton instance\nexport const lboModelingEngine = new LBOModelingEngine();\nexport default LBOModelingEngine;\n","import { apiLogger } from '../utils/apiLogger.js';\n\n/**\n * Monte Carlo Simulation Engine\n * Provides advanced statistical modeling and risk analysis\n */\nclass MonteCarloEngine {\n  constructor() {\n    this.workers = [];\n    this.isRunning = false;\n    this.currentSimulation = null;\n  }\n\n  /**\n   * Run Monte Carlo simulation for DCF analysis\n   * @param {Object} baseInputs - Base DCF inputs\n   * @param {Object} distributions - Variable distributions\n   * @param {Object} options - Simulation options\n   * @returns {Promise<Object>} Simulation results\n   */\n  async runDCFSimulation(baseInputs, distributions, options = {}) {\n    const {\n      iterations = 10000,\n      confidenceLevel = 0.95,\n      correlationMatrix = null,\n      randomSeed = null\n    } = options;\n\n    apiLogger.log('INFO', 'Starting DCF Monte Carlo simulation', {\n      iterations,\n      variables: Object.keys(distributions).length\n    });\n\n    this.isRunning = true;\n    const startTime = Date.now();\n\n    try {\n      // Initialize random number generator\n      if (randomSeed) {\n        this.setSeed(randomSeed);\n      }\n\n      // Generate correlated random samples\n      const samples = this.generateCorrelatedSamples(\n        distributions,\n        iterations,\n        correlationMatrix\n      );\n\n      // Run simulation iterations\n      const results = [];\n      const progressCallback = options.onProgress;\n\n      for (let i = 0; i < iterations; i++) {\n        if (!this.isRunning) {\n          throw new Error('Simulation cancelled');\n        }\n\n        // Create scenario inputs\n        const scenarioInputs = this.createScenarioInputs(baseInputs, samples[i], distributions);\n\n        // Calculate DCF for this scenario\n        const dcfResult = this.calculateDCFScenario(scenarioInputs);\n        results.push({\n          iteration: i + 1,\n          pricePerShare: dcfResult.pricePerShare,\n          enterpriseValue: dcfResult.enterpriseValue,\n          upside: dcfResult.upside,\n          inputs: scenarioInputs\n        });\n\n        // Report progress\n        if (progressCallback && i % Math.floor(iterations / 100) === 0) {\n          progressCallback((i / iterations) * 100);\n        }\n      }\n\n      // Analyze results\n      const analysis = this.analyzeResults(results, confidenceLevel);\n\n      const endTime = Date.now();\n      apiLogger.log('INFO', 'DCF Monte Carlo simulation completed', {\n        iterations,\n        duration: endTime - startTime,\n        meanPrice: analysis.statistics.mean\n      });\n\n      return {\n        type: 'DCF_MONTE_CARLO',\n        timestamp: new Date().toISOString(),\n        parameters: { iterations, confidenceLevel, randomSeed },\n        results,\n        analysis,\n        duration: endTime - startTime\n      };\n\n    } catch (error) {\n      this.isRunning = false;\n      apiLogger.log('ERROR', 'DCF Monte Carlo simulation failed', { error: error.message });\n      throw error;\n    } finally {\n      this.isRunning = false;\n    }\n  }\n\n  /**\n   * Run Monte Carlo simulation for LBO analysis\n   * @param {Object} baseInputs - Base LBO inputs\n   * @param {Object} distributions - Variable distributions\n   * @param {Object} options - Simulation options\n   * @returns {Promise<Object>} Simulation results\n   */\n  async runLBOSimulation(baseInputs, distributions, options = {}) {\n    const {\n      iterations = 10000,\n      confidenceLevel = 0.95,\n      correlationMatrix = null,\n      randomSeed = null\n    } = options;\n\n    apiLogger.log('INFO', 'Starting LBO Monte Carlo simulation', {\n      iterations,\n      variables: Object.keys(distributions).length\n    });\n\n    this.isRunning = true;\n    const startTime = Date.now();\n\n    try {\n      if (randomSeed) {\n        this.setSeed(randomSeed);\n      }\n\n      const samples = this.generateCorrelatedSamples(\n        distributions,\n        iterations,\n        correlationMatrix\n      );\n\n      const results = [];\n      const progressCallback = options.onProgress;\n\n      for (let i = 0; i < iterations; i++) {\n        if (!this.isRunning) {\n          throw new Error('Simulation cancelled');\n        }\n\n        const scenarioInputs = this.createScenarioInputs(baseInputs, samples[i], distributions);\n        const lboResult = this.calculateLBOScenario(scenarioInputs);\n\n        results.push({\n          iteration: i + 1,\n          irr: lboResult.irr,\n          moic: lboResult.moic,\n          totalReturn: lboResult.totalReturn,\n          inputs: scenarioInputs\n        });\n\n        if (progressCallback && i % Math.floor(iterations / 100) === 0) {\n          progressCallback((i / iterations) * 100);\n        }\n      }\n\n      const analysis = this.analyzeResults(results, confidenceLevel, ['irr', 'moic', 'totalReturn']);\n\n      const endTime = Date.now();\n      apiLogger.log('INFO', 'LBO Monte Carlo simulation completed', {\n        iterations,\n        duration: endTime - startTime,\n        meanIRR: analysis.statistics.irr?.mean\n      });\n\n      return {\n        type: 'LBO_MONTE_CARLO',\n        timestamp: new Date().toISOString(),\n        parameters: { iterations, confidenceLevel, randomSeed },\n        results,\n        analysis,\n        duration: endTime - startTime\n      };\n\n    } catch (error) {\n      this.isRunning = false;\n      apiLogger.log('ERROR', 'LBO Monte Carlo simulation failed', { error: error.message });\n      throw error;\n    } finally {\n      this.isRunning = false;\n    }\n  }\n\n  /**\n   * Generate correlated random samples using Cholesky decomposition\n   * @param {Object} distributions - Variable distributions\n   * @param {number} iterations - Number of iterations\n   * @param {Array} correlationMatrix - Correlation matrix\n   * @returns {Array} Array of sample sets\n   */\n  generateCorrelatedSamples(distributions, iterations, correlationMatrix) {\n    const variables = Object.keys(distributions);\n    const numVars = variables.length;\n    const samples = [];\n\n    // Generate independent samples first\n    const independentSamples = [];\n    for (let i = 0; i < iterations; i++) {\n      const sample = {};\n      variables.forEach(variable => {\n        const dist = distributions[variable];\n        sample[variable] = this.sampleFromDistribution(dist);\n      });\n      independentSamples.push(sample);\n    }\n\n    // Apply correlation if matrix is provided\n    if (correlationMatrix && correlationMatrix.length === numVars) {\n      const choleskyMatrix = this.choleskyDecomposition(correlationMatrix);\n\n      for (let i = 0; i < iterations; i++) {\n        const correlatedSample = {};\n        const independentValues = variables.map(v => independentSamples[i][v]);\n        const correlatedValues = this.applyCorrelation(independentValues, choleskyMatrix);\n\n        variables.forEach((variable, index) => {\n          correlatedSample[variable] = correlatedValues[index];\n        });\n\n        samples.push(correlatedSample);\n      }\n    } else {\n      samples.push(...independentSamples);\n    }\n\n    return samples;\n  }\n\n  /**\n   * Sample from a probability distribution with enhanced types\n   * @param {Object} distribution - Distribution parameters\n   * @returns {number} Random sample\n   */\n  sampleFromDistribution(distribution) {\n    const { type, parameters } = distribution;\n\n    switch (type) {\n      case 'normal':\n        return this.normalRandom(parameters.mean, parameters.stdDev);\n\n      case 'lognormal':\n        const normalSample = this.normalRandom(parameters.mu, parameters.sigma);\n        return Math.exp(normalSample);\n\n      case 'uniform':\n        return parameters.min + Math.random() * (parameters.max - parameters.min);\n\n      case 'triangular':\n        return this.triangularRandom(parameters.min, parameters.mode, parameters.max);\n\n      case 'beta':\n        return this.betaRandom(parameters.alpha, parameters.beta);\n\n      case 'exponential':\n        return this.exponentialRandom(parameters.lambda);\n\n      case 'weibull':\n        return this.weibullRandom(parameters.shape, parameters.scale);\n\n      case 'pareto':\n        return this.paretoRandom(parameters.scale, parameters.shape);\n\n      case 'student_t':\n        return this.studentTRandom(parameters.df);\n\n      case 'chi_squared':\n        return this.chiSquaredRandom(parameters.df);\n\n      default:\n        throw new Error(`Unsupported distribution type: ${type}`);\n    }\n  }\n\n  /**\n   * Generate exponential random variable\n   * @param {number} lambda - Rate parameter\n   * @returns {number} Exponential random variable\n   */\n  exponentialRandom(lambda) {\n    return -Math.log(1 - Math.random()) / lambda;\n  }\n\n  /**\n   * Generate Weibull random variable\n   * @param {number} shape - Shape parameter (k)\n   * @param {number} scale - Scale parameter (lambda)\n   * @returns {number} Weibull random variable\n   */\n  weibullRandom(shape, scale) {\n    const u = Math.random();\n    return scale * Math.pow(-Math.log(1 - u), 1 / shape);\n  }\n\n  /**\n   * Generate Pareto random variable\n   * @param {number} scale - Scale parameter (xm)\n   * @param {number} shape - Shape parameter (alpha)\n   * @returns {number} Pareto random variable\n   */\n  paretoRandom(scale, shape) {\n    const u = Math.random();\n    return scale / Math.pow(u, 1 / shape);\n  }\n\n  /**\n   * Generate Student's t random variable\n   * @param {number} df - Degrees of freedom\n   * @returns {number} Student's t random variable\n   */\n  studentTRandom(df) {\n    if (df <= 0) throw new Error('Degrees of freedom must be positive');\n\n    const normal = this.normalRandom(0, 1);\n    const chiSq = this.chiSquaredRandom(df);\n\n    return normal / Math.sqrt(chiSq / df);\n  }\n\n  /**\n   * Generate Chi-squared random variable\n   * @param {number} df - Degrees of freedom\n   * @returns {number} Chi-squared random variable\n   */\n  chiSquaredRandom(df) {\n    if (df <= 0) throw new Error('Degrees of freedom must be positive');\n\n    return this.gammaRandom(df / 2) * 2;\n  }\n\n  /**\n   * Generate normal random variable using Box-Muller transform\n   * @param {number} mean - Mean\n   * @param {number} stdDev - Standard deviation\n   * @returns {number} Normal random variable\n   */\n  normalRandom(mean = 0, stdDev = 1) {\n    if (this.spareNormal !== undefined) {\n      const spare = this.spareNormal;\n      this.spareNormal = undefined;\n      return spare * stdDev + mean;\n    }\n\n    const u1 = Math.random();\n    const u2 = Math.random();\n    const z0 = Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);\n    const z1 = Math.sqrt(-2 * Math.log(u1)) * Math.sin(2 * Math.PI * u2);\n\n    this.spareNormal = z1;\n    return z0 * stdDev + mean;\n  }\n\n  /**\n   * Generate triangular random variable\n   * @param {number} min - Minimum value\n   * @param {number} mode - Mode value\n   * @param {number} max - Maximum value\n   * @returns {number} Triangular random variable\n   */\n  triangularRandom(min, mode, max) {\n    const u = Math.random();\n    const c = (mode - min) / (max - min);\n\n    if (u < c) {\n      return min + Math.sqrt(u * (max - min) * (mode - min));\n    } else {\n      return max - Math.sqrt((1 - u) * (max - min) * (max - mode));\n    }\n  }\n\n  /**\n   * Generate beta random variable\n   * @param {number} alpha - Alpha parameter\n   * @param {number} beta - Beta parameter\n   * @returns {number} Beta random variable\n   */\n  betaRandom(alpha, beta) {\n    const x = this.gammaRandom(alpha);\n    const y = this.gammaRandom(beta);\n    return x / (x + y);\n  }\n\n  /**\n   * Generate gamma random variable\n   * @param {number} shape - Shape parameter\n   * @returns {number} Gamma random variable\n   */\n  gammaRandom(shape) {\n    // Marsaglia and Tsang's method for shape >= 1\n    if (shape >= 1) {\n      const d = shape - 1 / 3;\n      const c = 1 / Math.sqrt(9 * d);\n\n      while (true) {\n        let x, v;\n        do {\n          x = this.normalRandom();\n          v = 1 + c * x;\n        } while (v <= 0);\n\n        v = v * v * v;\n        const u = Math.random();\n\n        if (u < 1 - 0.0331 * x * x * x * x) {\n          return d * v;\n        }\n\n        if (Math.log(u) < 0.5 * x * x + d * (1 - v + Math.log(v))) {\n          return d * v;\n        }\n      }\n    } else {\n      // For shape < 1, use transformation\n      return this.gammaRandom(shape + 1) * Math.pow(Math.random(), 1 / shape);\n    }\n  }\n\n  /**\n   * Perform Cholesky decomposition\n   * @param {Array} matrix - Correlation matrix\n   * @returns {Array} Lower triangular matrix\n   */\n  choleskyDecomposition(matrix) {\n    const n = matrix.length;\n    const L = Array(n).fill().map(() => Array(n).fill(0));\n\n    for (let i = 0; i < n; i++) {\n      for (let j = 0; j <= i; j++) {\n        if (i === j) {\n          let sum = 0;\n          for (let k = 0; k < j; k++) {\n            sum += L[j][k] * L[j][k];\n          }\n          L[j][j] = Math.sqrt(matrix[j][j] - sum);\n        } else {\n          let sum = 0;\n          for (let k = 0; k < j; k++) {\n            sum += L[i][k] * L[j][k];\n          }\n          L[i][j] = (matrix[i][j] - sum) / L[j][j];\n        }\n      }\n    }\n\n    return L;\n  }\n\n  /**\n   * Apply correlation using Cholesky matrix\n   * @param {Array} independentValues - Independent random values\n   * @param {Array} choleskyMatrix - Cholesky decomposition matrix\n   * @returns {Array} Correlated values\n   */\n  applyCorrelation(independentValues, choleskyMatrix) {\n    const n = independentValues.length;\n    const correlatedValues = Array(n).fill(0);\n\n    for (let i = 0; i < n; i++) {\n      for (let j = 0; j <= i; j++) {\n        correlatedValues[i] += choleskyMatrix[i][j] * independentValues[j];\n      }\n    }\n\n    return correlatedValues;\n  }\n\n  /**\n   * Create scenario inputs by applying random samples to base inputs\n   * @param {Object} baseInputs - Base model inputs\n   * @param {Object} samples - Random samples\n   * @param {Object} distributions - Distribution definitions\n   * @returns {Object} Scenario inputs\n   */\n  createScenarioInputs(baseInputs, samples, distributions) {\n    const scenarioInputs = { ...baseInputs };\n\n    Object.entries(samples).forEach(([variable, sample]) => {\n      const distribution = distributions[variable];\n\n      if (distribution.applyTo) {\n        // Apply sample to specific input field\n        scenarioInputs[distribution.applyTo] = sample;\n      } else {\n        // Direct assignment\n        scenarioInputs[variable] = sample;\n      }\n    });\n\n    return scenarioInputs;\n  }\n\n  /**\n   * Calculate DCF scenario (simplified for Monte Carlo)\n   * @param {Object} inputs - Scenario inputs\n   * @returns {Object} DCF results\n   */\n  calculateDCFScenario(inputs) {\n    // This would integrate with the financialModelingEngine\n    // Simplified calculation for demonstration\n    const {\n      currentRevenue = 1000000000,\n      revenueGrowthRate = 0.1,\n      fcfMargin = 0.15,\n      wacc = 0.1,\n      terminalGrowthRate = 0.025,\n      sharesOutstanding = 100000000,\n      currentPrice = 100\n    } = inputs;\n\n    // Simple DCF calculation\n    const projectionYears = 5;\n    let totalPV = 0;\n    let revenue = currentRevenue;\n\n    for (let year = 1; year <= projectionYears; year++) {\n      revenue *= (1 + revenueGrowthRate);\n      const fcf = revenue * fcfMargin;\n      const pv = fcf / Math.pow(1 + wacc, year);\n      totalPV += pv;\n    }\n\n    // Terminal value\n    const terminalFCF = revenue * fcfMargin * (1 + terminalGrowthRate);\n    const terminalValue = terminalFCF / (wacc - terminalGrowthRate);\n    const pvTerminal = terminalValue / Math.pow(1 + wacc, projectionYears);\n\n    const enterpriseValue = totalPV + pvTerminal;\n    const pricePerShare = enterpriseValue / sharesOutstanding;\n    const upside = ((pricePerShare - currentPrice) / currentPrice) * 100;\n\n    return {\n      pricePerShare,\n      enterpriseValue,\n      upside\n    };\n  }\n\n  /**\n   * Calculate LBO scenario (simplified for Monte Carlo)\n   * @param {Object} inputs - Scenario inputs\n   * @returns {Object} LBO results\n   */\n  calculateLBOScenario(inputs) {\n    // Simplified LBO calculation for demonstration\n    const {\n      ebitda = 100000000,\n      ebitdaGrowthRate = 0.05,\n      exitMultiple = 10,\n      debtMultiple = 5,\n      holdingPeriod = 5\n    } = inputs;\n\n    const purchasePrice = ebitda * 10; // Assume 10x entry multiple\n    const debt = ebitda * debtMultiple;\n    const equity = purchasePrice - debt;\n\n    // Project exit EBITDA\n    const exitEbitda = ebitda * Math.pow(1 + ebitdaGrowthRate, holdingPeriod);\n    const exitValue = exitEbitda * exitMultiple;\n    const remainingDebt = debt * 0.5; // Assume 50% paydown\n    const exitProceeds = exitValue - remainingDebt;\n\n    const totalReturn = exitProceeds / equity;\n    const irr = Math.pow(totalReturn, 1 / holdingPeriod) - 1;\n\n    return {\n      irr,\n      moic: totalReturn,\n      totalReturn: exitProceeds\n    };\n  }\n\n  /**\n   * Analyze simulation results with enhanced statistical measures\n   * @param {Array} results - Simulation results\n   * @param {number} confidenceLevel - Confidence level\n   * @param {Array} metrics - Metrics to analyze\n   * @returns {Object} Comprehensive statistical analysis\n   */\n  analyzeResults(results, confidenceLevel, metrics = ['pricePerShare', 'enterpriseValue', 'upside']) {\n    const analysis = {\n      statistics: {},\n      percentiles: {},\n      confidenceIntervals: {},\n      riskMetrics: {},\n      distributionTests: {},\n      correlations: {}\n    };\n\n    metrics.forEach(metric => {\n      const values = results.map(r => r[metric]).filter(v => v !== null && !isNaN(v)).sort((a, b) => a - b);\n\n      if (values.length === 0) return;\n\n      const mean = values.reduce((sum, v) => sum + v, 0) / values.length;\n      const variance = values.reduce((sum, v) => sum + Math.pow(v - mean, 2), 0) / values.length;\n      const stdDev = Math.sqrt(variance);\n      const sampleStdDev = Math.sqrt(variance * values.length / (values.length - 1)); // Bessel's correction\n\n      analysis.statistics[metric] = {\n        mean,\n        median: this.percentile(values, 0.5),\n        mode: this.calculateMode(values),\n        stdDev,\n        sampleStdDev,\n        variance,\n        min: values[0],\n        max: values[values.length - 1],\n        range: values[values.length - 1] - values[0],\n        count: values.length,\n        // Additional robust statistics\n        trimmedMean: this.calculateTrimmedMean(values, 0.1), // 10% trimmed mean\n        mad: this.calculateMAD(values), // Median Absolute Deviation\n        iqr: this.percentile(values, 0.75) - this.percentile(values, 0.25)\n      };\n\n      analysis.percentiles[metric] = {\n        p1: this.percentile(values, 0.01),\n        p5: this.percentile(values, 0.05),\n        p10: this.percentile(values, 0.10),\n        p25: this.percentile(values, 0.25),\n        p50: this.percentile(values, 0.5),\n        p75: this.percentile(values, 0.75),\n        p90: this.percentile(values, 0.90),\n        p95: this.percentile(values, 0.95),\n        p99: this.percentile(values, 0.99)\n      };\n\n      const alpha = 1 - confidenceLevel;\n      const lowerBound = this.percentile(values, alpha / 2);\n      const upperBound = this.percentile(values, 1 - alpha / 2);\n\n      analysis.confidenceIntervals[metric] = {\n        level: confidenceLevel,\n        lowerBound,\n        upperBound,\n        width: upperBound - lowerBound,\n        // Bootstrap confidence intervals\n        bootstrapCI: this.calculateBootstrapCI(values, confidenceLevel)\n      };\n\n      const var95 = this.percentile(values, 0.05);\n      const var99 = this.percentile(values, 0.01);\n      const cvar95 = values.slice(0, Math.floor(values.length * 0.05)).reduce((sum, v) => sum + v, 0) / Math.floor(values.length * 0.05);\n      const cvar99 = values.slice(0, Math.floor(values.length * 0.01)).reduce((sum, v) => sum + v, 0) / Math.floor(values.length * 0.01);\n\n      analysis.riskMetrics[metric] = {\n        var95, // Value at Risk (5%)\n        var99, // Value at Risk (1%)\n        cvar95, // Conditional VaR (5%)\n        cvar99, // Conditional VaR (1%)\n        skewness: this.calculateSkewness(values, mean, stdDev),\n        kurtosis: this.calculateKurtosis(values, mean, stdDev),\n        excessKurtosis: this.calculateKurtosis(values, mean, stdDev) - 3,\n        // Tail risk measures\n        expectedShortfall: cvar95,\n        maxDrawdown: this.calculateMaxDrawdown(values),\n        // Risk-adjusted returns\n        sharpeRatio: this.calculateSharpeRatio(values, 0.02), // Assuming 2% risk-free rate\n        sortinoRatio: this.calculateSortinoRatio(values, mean)\n      };\n\n      // Distribution fitting tests\n      analysis.distributionTests[metric] = {\n        jarqueBera: this.jarqueBeraTest(values),\n        kolmogorovSmirnov: this.ksTestNormality(values),\n        shapiroWilk: values.length <= 5000 ? this.shapiroWilkTest(values) : null\n      };\n    });\n\n    // Calculate correlation matrix between metrics\n    if (metrics.length > 1) {\n      analysis.correlations = this.calculateCorrelationMatrix(results, metrics);\n    }\n\n    return analysis;\n  }\n\n  /**\n   * Calculate mode of dataset\n   */\n  calculateMode(values) {\n    const frequency = {};\n    values.forEach(v => {\n      const rounded = Math.round(v * 100) / 100; // Round to avoid floating point issues\n      frequency[rounded] = (frequency[rounded] || 0) + 1;\n    });\n\n    const maxFreq = Math.max(...Object.values(frequency));\n    const modes = Object.keys(frequency).filter(k => frequency[k] === maxFreq);\n\n    return modes.length === 1 ? parseFloat(modes[0]) : null;\n  }\n\n  /**\n   * Calculate trimmed mean\n   */\n  calculateTrimmedMean(sortedValues, trimProportion = 0.1) {\n    const trimCount = Math.floor(sortedValues.length * trimProportion);\n    const trimmedValues = sortedValues.slice(trimCount, -trimCount || undefined);\n    return trimmedValues.reduce((sum, v) => sum + v, 0) / trimmedValues.length;\n  }\n\n  /**\n   * Calculate Median Absolute Deviation\n   */\n  calculateMAD(values) {\n    const median = this.percentile(values, 0.5);\n    const deviations = values.map(v => Math.abs(v - median)).sort((a, b) => a - b);\n    return this.percentile(deviations, 0.5);\n  }\n\n  /**\n   * Calculate bootstrap confidence interval\n   */\n  calculateBootstrapCI(values, confidenceLevel, bootstrapSamples = 1000) {\n    const bootstrapMeans = [];\n\n    for (let i = 0; i < bootstrapSamples; i++) {\n      const sample = [];\n      for (let j = 0; j < values.length; j++) {\n        sample.push(values[Math.floor(Math.random() * values.length)]);\n      }\n      bootstrapMeans.push(sample.reduce((sum, v) => sum + v, 0) / sample.length);\n    }\n\n    bootstrapMeans.sort((a, b) => a - b);\n    const alpha = 1 - confidenceLevel;\n\n    return {\n      lowerBound: this.percentile(bootstrapMeans, alpha / 2),\n      upperBound: this.percentile(bootstrapMeans, 1 - alpha / 2)\n    };\n  }\n\n  /**\n   * Calculate maximum drawdown\n   */\n  calculateMaxDrawdown(values) {\n    let peak = values[0];\n    let maxDrawdown = 0;\n\n    for (const value of values) {\n      if (value > peak) {\n        peak = value;\n      }\n      const drawdown = (peak - value) / peak;\n      if (drawdown > maxDrawdown) {\n        maxDrawdown = drawdown;\n      }\n    }\n\n    return maxDrawdown;\n  }\n\n  /**\n   * Calculate Sharpe ratio approximation\n   */\n  calculateSharpeRatio(values, riskFreeRate = 0.02) {\n    const mean = values.reduce((sum, v) => sum + v, 0) / values.length;\n    const variance = values.reduce((sum, v) => sum + Math.pow(v - mean, 2), 0) / values.length;\n    const stdDev = Math.sqrt(variance);\n\n    return stdDev > 0 ? (mean - riskFreeRate) / stdDev : 0;\n  }\n\n  /**\n   * Calculate Sortino ratio\n   */\n  calculateSortinoRatio(values, targetReturn) {\n    const excessReturns = values.map(v => v - targetReturn);\n    const negativeReturns = excessReturns.filter(r => r < 0);\n\n    if (negativeReturns.length === 0) return Infinity;\n\n    const downsideDeviation = Math.sqrt(\n      negativeReturns.reduce((sum, r) => sum + r * r, 0) / negativeReturns.length\n    );\n\n    const meanExcessReturn = excessReturns.reduce((sum, r) => sum + r, 0) / excessReturns.length;\n\n    return downsideDeviation > 0 ? meanExcessReturn / downsideDeviation : 0;\n  }\n\n  /**\n   * Jarque-Bera test for normality\n   */\n  jarqueBeraTest(values) {\n    const n = values.length;\n    const mean = values.reduce((sum, v) => sum + v, 0) / n;\n    const variance = values.reduce((sum, v) => sum + Math.pow(v - mean, 2), 0) / n;\n    const stdDev = Math.sqrt(variance);\n\n    const skewness = this.calculateSkewness(values, mean, stdDev);\n    const kurtosis = this.calculateKurtosis(values, mean, stdDev);\n\n    const jb = (n / 6) * (Math.pow(skewness, 2) + Math.pow(kurtosis - 3, 2) / 4);\n    const pValue = 1 - this.chiSquaredCDF(jb, 2); // Approximate p-value\n\n    return {\n      statistic: jb,\n      pValue,\n      isNormal: pValue > 0.05\n    };\n  }\n\n  /**\n   * Approximate chi-squared CDF\n   */\n  chiSquaredCDF(x, df) {\n    if (x <= 0) return 0;\n    return this.incompleteGamma(df / 2, x / 2);\n  }\n\n  /**\n   * Incomplete gamma function approximation\n   */\n  incompleteGamma(a, x) {\n    // Returns the regularized lower incomplete gamma P(a, x)\n    if (x <= 0) return 0;\n    if (a <= 0) return NaN;\n\n    if (x < a + 1) {\n      // Series expansion for P(a, x)\n      return this.incompleteGammaLowerSeries(a, x);\n    }\n    // Continued fraction for Q(a, x), then P = 1 - Q\n    return 1 - this.incompleteGammaUpperContinuedFraction(a, x);\n  }\n\n  /**\n   * Series expansion for regularized lower incomplete gamma P(a, x)\n   */\n  incompleteGammaLowerSeries(a, x) {\n    const gln = this.logGamma(a);\n    let sum = 1 / a;\n    let term = sum;\n    for (let n = 1; n <= 200; n++) {\n      term *= x / (a + n);\n      sum += term;\n      if (Math.abs(term) < Math.abs(sum) * 1e-15) break;\n    }\n    return sum * Math.exp(-x + a * Math.log(x) - gln);\n  }\n\n  /**\n   * Continued fraction for regularized upper incomplete gamma Q(a, x)\n   * Based on Lentz's algorithm (Numerical Recipes)\n   */\n  incompleteGammaUpperContinuedFraction(a, x) {\n    const gln = this.logGamma(a);\n    const eps = 1e-14;\n    const maxIterations = 200;\n    const tiny = 1e-300;\n\n    let b = x + 1 - a;\n    let c = 1 / tiny;\n    let d = 1 / b;\n    let h = d;\n\n    for (let i = 1; i <= maxIterations; i++) {\n      const an = -i * (i - a);\n      b += 2;\n      d = an * d + b;\n      if (Math.abs(d) < tiny) d = tiny;\n      c = b + an / c;\n      if (Math.abs(c) < tiny) c = tiny;\n      d = 1 / d;\n      const del = d * c;\n      h *= del;\n      if (Math.abs(del - 1) < eps) break;\n    }\n\n    return Math.exp(-x + a * Math.log(x) - gln) * h;\n  }\n\n  /**\n   * Log gamma function approximation\n   */\n  logGamma(x) {\n    const coef = [\n      76.18009172947146, -86.50532032941677, 24.01409824083091,\n      -1.231739572450155, 0.1208650973866179e-2, -0.5395239384953e-5\n    ];\n\n    let j = 0;\n    let ser = 1.000000000190015;\n    let xx = x;\n    let y = xx = x;\n    let tmp = x + 5.5;\n    tmp -= (x + 0.5) * Math.log(tmp);\n\n    for (; j < 6; j++) {\n      ser += coef[j] / ++y;\n    }\n\n    return -tmp + Math.log(2.5066282746310005 * ser / xx);\n  }\n\n  /**\n   * Kolmogorov-Smirnov test for normality\n   */\n  ksTestNormality(values) {\n    const n = values.length;\n    const mean = values.reduce((sum, v) => sum + v, 0) / n;\n    const variance = values.reduce((sum, v) => sum + Math.pow(v - mean, 2), 0) / n;\n    const stdDev = Math.sqrt(variance);\n\n    let maxD = 0;\n\n    for (let i = 0; i < n; i++) {\n      const empirical = (i + 1) / n;\n      const theoretical = this.normalCDF((values[i] - mean) / stdDev);\n      const d = Math.abs(empirical - theoretical);\n      if (d > maxD) maxD = d;\n    }\n\n    const critical = 1.36 / Math.sqrt(n); // Critical value at 5% significance\n\n    return {\n      statistic: maxD,\n      critical,\n      isNormal: maxD < critical\n    };\n  }\n\n  /**\n   * Normal CDF approximation\n   */\n  normalCDF(x) {\n    return 0.5 * (1 + this.erf(x / Math.sqrt(2)));\n  }\n\n  /**\n   * Error function approximation\n   */\n  erf(x) {\n    const a1 =  0.254829592;\n    const a2 = -0.284496736;\n    const a3 =  1.421413741;\n    const a4 = -1.453152027;\n    const a5 =  1.061405429;\n    const p  =  0.3275911;\n\n    const sign = x < 0 ? -1 : 1;\n    x = Math.abs(x);\n\n    const t = 1.0 / (1.0 + p * x);\n    const y = 1.0 - (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1) * t * Math.exp(-x * x);\n\n    return sign * y;\n  }\n\n  /**\n   * Shapiro-Wilk test for normality (simplified)\n   */\n  shapiroWilkTest(values) {\n    // Simplified implementation - in practice, would use lookup tables\n    const n = values.length;\n    if (n < 3 || n > 5000) return null;\n\n    const sortedValues = [...values].sort((a, b) => a - b);\n    const mean = values.reduce((sum, v) => sum + v, 0) / n;\n\n    // This is a very simplified approximation\n    const numerator = 0;\n    let denominator = 0;\n\n    for (let i = 0; i < n; i++) {\n      denominator += Math.pow(sortedValues[i] - mean, 2);\n    }\n\n    // Simplified calculation - real implementation would use Shapiro-Wilk coefficients\n    const w = numerator / denominator;\n\n    return {\n      statistic: w,\n      isNormal: w > 0.9 // Very rough approximation\n    };\n  }\n\n  /**\n   * Calculate correlation matrix between metrics\n   */\n  calculateCorrelationMatrix(results, metrics) {\n    const correlationMatrix = {};\n\n    for (let i = 0; i < metrics.length; i++) {\n      correlationMatrix[metrics[i]] = {};\n      for (let j = 0; j < metrics.length; j++) {\n        if (i === j) {\n          correlationMatrix[metrics[i]][metrics[j]] = 1.0;\n        } else {\n          const valuesI = results.map(r => r[metrics[i]]).filter(v => v !== null && !isNaN(v));\n          const valuesJ = results.map(r => r[metrics[j]]).filter(v => v !== null && !isNaN(v));\n\n          correlationMatrix[metrics[i]][metrics[j]] = this.calculateCorrelation(valuesI, valuesJ);\n        }\n      }\n    }\n\n    return correlationMatrix;\n  }\n\n  /**\n   * Calculate Pearson correlation coefficient\n   */\n  calculateCorrelation(x, y) {\n    if (x.length !== y.length || x.length === 0) return 0;\n\n    const n = x.length;\n    const meanX = x.reduce((sum, v) => sum + v, 0) / n;\n    const meanY = y.reduce((sum, v) => sum + v, 0) / n;\n\n    let numerator = 0;\n    let sumXX = 0;\n    let sumYY = 0;\n\n    for (let i = 0; i < n; i++) {\n      const dx = x[i] - meanX;\n      const dy = y[i] - meanY;\n      numerator += dx * dy;\n      sumXX += dx * dx;\n      sumYY += dy * dy;\n    }\n\n    const denominator = Math.sqrt(sumXX * sumYY);\n    return denominator > 0 ? numerator / denominator : 0;\n  }\n\n  /**\n   * Calculate percentile\n   * @param {Array} sortedValues - Sorted array of values\n   * @param {number} p - Percentile (0-1)\n   * @returns {number} Percentile value\n   */\n  percentile(sortedValues, p) {\n    const index = p * (sortedValues.length - 1);\n    const lower = Math.floor(index);\n    const upper = Math.ceil(index);\n    const weight = index - lower;\n\n    if (lower === upper) {\n      return sortedValues[lower];\n    }\n\n    return sortedValues[lower] * (1 - weight) + sortedValues[upper] * weight;\n  }\n\n  /**\n   * Calculate skewness\n   * @param {Array} values - Array of values\n   * @param {number} mean - Mean\n   * @param {number} stdDev - Standard deviation\n   * @returns {number} Skewness\n   */\n  calculateSkewness(values, mean, stdDev) {\n    const n = values.length;\n    const sum = values.reduce((sum, v) => sum + Math.pow((v - mean) / stdDev, 3), 0);\n    return (n / ((n - 1) * (n - 2))) * sum;\n  }\n\n  /**\n   * Calculate kurtosis\n   * @param {Array} values - Array of values\n   * @param {number} mean - Mean\n   * @param {number} stdDev - Standard deviation\n   * @returns {number} Kurtosis\n   */\n  calculateKurtosis(values, mean, stdDev) {\n    const n = values.length;\n    const sum = values.reduce((sum, v) => sum + Math.pow((v - mean) / stdDev, 4), 0);\n    return ((n * (n + 1)) / ((n - 1) * (n - 2) * (n - 3))) * sum - (3 * Math.pow(n - 1, 2)) / ((n - 2) * (n - 3));\n  }\n\n  /**\n   * Set random seed for reproducible results\n   * @param {number} seed - Random seed\n   */\n  setSeed(seed) {\n    // Simple linear congruential generator for reproducible results\n    this.seed = seed;\n    this.random = () => {\n      this.seed = (this.seed * 9301 + 49297) % 233280;\n      return this.seed / 233280;\n    };\n    Math.random = this.random;\n  }\n\n  /**\n   * Stop running simulation\n   */\n  stopSimulation() {\n    this.isRunning = false;\n  }\n\n  /**\n   * Check if simulation is running\n   * @returns {boolean} True if running\n   */\n  isSimulationRunning() {\n    return this.isRunning;\n  }\n}\n\n// Export singleton instance\nexport const monteCarloEngine = new MonteCarloEngine();\nexport default MonteCarloEngine;\n"],"names":["LOG_LEVELS","ERROR","WARN","INFO","DEBUG","TRACE","DEFAULT_CONFIG","logLevel","enableMetrics","enablePerformanceTracking","enableErrorTracking","maxLogHistory","metricsRetentionPeriod","apiLogger","constructor","config","this","logs","metrics","Map","performanceData","errorCounts","startTime","Date","now","log","level","message","metadata","toUpperCase","logEntry","timestamp","toISOString","id","generateLogId","push","trimLogs","outputToConsole","logApiRequest","service","endpoint","params","requestId","generateRequestId","sanitizeParams","set","logApiResponse","success","response","error","get","duration","responseSize","getResponseSize","recordMetric","code","status","statusText","recordError","delete","logRateLimit","waitTime","remainingRequests","action","logCircuitBreaker","state","emoji","OPEN","HALF_OPEN","CLOSED","toLowerCase","logCache","operation","key","hit","miss","clear","sanitizeCacheKey","metric","value","has","values","total","count","min","Infinity","max","avg","metricData","Math","cleanOldMetrics","errorKey","getMetrics","summary","uptime","totalLogs","length","services","cache","errors","data","entries","split","messageParts","join","getRecentLogs","limit","filter","slice","reverse","random","toString","substr","sanitized","apikey","api_key","token","substring","JSON","stringify","cutoff","item","toLocaleTimeString","financialModelingEngine","modelCache","assumptions","getDefaultAssumptions","dcf","projectionYears","terminalGrowthRate","riskFreeRate","marketPremium","taxRate","capexAsPercentOfRevenue","nwcAsPercentOfRevenue","depreciationAsPercentOfRevenue","normalizedMarginTarget","cyclicalAdjustment","industryBeta","sizeAdjustment","countryRiskPremium","liquidityDiscount","lbo","holdingPeriod","debtMultiples","senior","subordinated","interestRates","managementFeeRate","carriedInterestRate","ebitdaGrowthRate","debtPaydownRate","monte_carlo","iterations","confidenceIntervals","correlationMatrix","buildDCFModel","inputs","scenarios","symbol","companyName","modelAssumptions","baseCase","calculateDCFScenario","scenarioResults","bull","bullAssumptions","revenueGrowthRate","wacc","bear","bearAssumptions","sensitivityAnalysis","performDCFSensitivityAnalysis","modelType","generateDCFSummary","currentPrice","calculateWACC","marketCap","totalDebt","cash","beta","costOfDebt","costOfEquity","netDebt","totalValue","scenarioName","currentRevenue","sharesOutstanding","discountRate","isNaN","revenueProjections","projectRevenues","operatingProjections","projectOperatingMetrics","fcfProjections","calculateFreeCashFlows","finalFCF","unleveredFCF","terminalValue","calculateTerminalValue","fcfValues","map","fcf","pvOfCashFlows","calculatePresentValue","pvOfTerminalValue","enterpriseValue","equityValue","pricePerShare","upside","impliedMultiples","calculateImpliedMultiples","baseRevenue","growthRates","years","projections","i","growthRate","Array","isArray","pow","year","revenue","projection","index","ebitdaMargin","ebitda","depreciation","ebit","taxes","nopat","maintenanceCapex","maintenanceCapexRate","growthCapex","growthCapexRate","totalCapex","nwcChange","calculateWorkingCapitalChange","stockBasedComp","stockBasedCompRate","otherNonCash","otherNonCashRate","totalNonCash","fcfMargin","currentProjection","priorProjection","receivablesDays","inventoryDays","payablesDays","cogsPct","options","Error","toFixed","method","exitMultiple","fadeYears","longTermGrowth","fadeRate","cashFlows","startYear","reduce","pv","cf","currentYearEbitda","nextYearEbitda","currentYearEbit","nextYearEbit","nextYearRevenue","currentYearFCF","nextYearFCF","evToCurrentRevenue","evToForwardRevenue","evToCurrentEbitda","evToForwardEbitda","evToCurrentEbit","evToForwardEbit","evToCurrentFCF","evToForwardFCF","pegRatio","calculatePEGRatio","currentEarnings","futureEarnings","baseAssumptions","results","Object","forEach","variable","variations","variation","adjustedAssumptions","scenario","pricesPerShare","s","p","priceRange","average","sum","recommendation","generateRecommendation","keyMetrics","impliedReturn","rating","confidence","abs","round","reasoning","generateRecommendationReasoning","upsideAbs","lboModelingEngine","transaction","managementRollover","transactionFees","financingFees","debt","seniorDebtMultiple","subordinatedDebtMultiple","totalDebtMultiple","seniorInterestRate","subordinatedInterestRate","mandatoryPaydown","cashSweep","operating","exit","exitMultipleRange","publicMarketDiscount","fees","hurdle","buildLBOModel","purchasePrice","transactionStructure","calculateTransactionStructure","calculateLBOScenario","upsideAssumptions","downside","downsideAssumptions","performLBOSensitivityAnalysis","generateLBOSummary","seniorDebt","totalUses","equityContribution","sponsorEquity","adjustedTotalDebt","adjustedSeniorDebt","subordinatedDebt","debtToEbitda","equityToTotalCapital","projectLBOOperatingPerformance","debtSchedule","calculateDebtSchedule","equityCashFlows","calculateEquityCashFlows","exitAnalysis","calculateExitAnalysis","returnsAnalysis","calculateReturnsMetrics","netProceeds","calculateLBOKeyMetrics","baseEbitda","operatingAssumptions","currentEbitda","ebitdaGrowth","capex","debtAssumptions","schedule","seniorDebtBalance","subordinatedDebtBalance","revolvingDebtBalance","revolvingDebt","enhancedAssumptions","revolvingRate","maxLeverageRatio","minCoverageRatio","maxCapexRatio","seniorInterest","subordinatedInterest","totalInterest","cashAvailableForDebt","excessCash","totalPaydown","seniorPaydown","subordinatedPaydown","leverageRatio","coverageRatio","capexRatio","covenantTests","leverageCompliance","coverageCompliance","capexCompliance","dscr","beginningBalance","endingBalance","revolving","interestExpense","principalPayment","netDebtToEbitda","ebitdaToInterest","managementFees","cashFlowToEquity","finalYearProjection","finalYearDebt","exitEbitda","totalDebtAtExit","grossProceeds","totalReturn","investedCapital","carriedInterest","managementProceeds","initialInvestment","exitProceeds","irr","NaN","moic","totalCashReturned","annualizedReturn","calculateIRR","every","sign","tolerance","maxIterations","initialGuess","rate","newtonRaphsonIRR","isFinite","bisectionIRR","secantIRR","npv","dnpv","j","factor","Number","EPSILON","proposed","clamped","low","high","npvLow","calculateNPV","npvHigh","mid","npvMid","x0","x1","f0","f1","x2","impliedEntryEbitda","entryMultiple","actualEntryMultiple","peakLeverage","d","minCoverage","avgDSCR","multipleExpansion","operationalImprovement","leverage","entryLeverage","debtToEquity","exitLeverage","leverageReduction","leverageContribution","breakdownLeverage","covenantBreaches","equityEfficiency","timeToRecoverEquity","calculateTimeToRecoverEquity","initialEquity","cumulativeCashFlow","debtMultiple","allScenarios","irrs","moics","returnRange","irrMin","irrMax","irrAverage","moicMin","moicMax","moicAverage","investmentHighlights","generateInvestmentHighlights","riskFactors","generateRiskFactors","highlights","risks","monteCarloEngine","workers","isRunning","currentSimulation","runDCFSimulation","baseInputs","distributions","confidenceLevel","randomSeed","variables","keys","setSeed","samples","generateCorrelatedSamples","progressCallback","onProgress","scenarioInputs","createScenarioInputs","dcfResult","iteration","floor","analysis","analyzeResults","endTime","meanPrice","statistics","mean","type","parameters","runLBOSimulation","lboResult","meanIRR","numVars","independentSamples","sample","dist","sampleFromDistribution","choleskyMatrix","choleskyDecomposition","correlatedSample","independentValues","v","correlatedValues","applyCorrelation","distribution","normalRandom","stdDev","normalSample","mu","sigma","exp","triangularRandom","mode","betaRandom","alpha","exponentialRandom","lambda","weibullRandom","shape","scale","paretoRandom","studentTRandom","df","chiSquaredRandom","u","normal","chiSq","sqrt","gammaRandom","undefined","spareNormal","spare","u1","u2","z0","cos","PI","z1","sin","x","c","matrix","n","L","fill","k","applyTo","totalPV","equity","percentiles","riskMetrics","distributionTests","correlations","r","sort","a","b","variance","sampleStdDev","median","percentile","calculateMode","range","trimmedMean","calculateTrimmedMean","mad","calculateMAD","iqr","p1","p5","p10","p25","p50","p75","p90","p95","p99","lowerBound","upperBound","width","bootstrapCI","calculateBootstrapCI","var95","var99","cvar95","cvar99","skewness","calculateSkewness","kurtosis","calculateKurtosis","excessKurtosis","expectedShortfall","maxDrawdown","calculateMaxDrawdown","sharpeRatio","calculateSharpeRatio","sortinoRatio","calculateSortinoRatio","jarqueBera","jarqueBeraTest","kolmogorovSmirnov","ksTestNormality","shapiroWilk","shapiroWilkTest","calculateCorrelationMatrix","frequency","rounded","maxFreq","modes","parseFloat","sortedValues","trimProportion","trimCount","trimmedValues","deviations","bootstrapSamples","bootstrapMeans","peak","drawdown","targetReturn","excessReturns","negativeReturns","downsideDeviation","meanExcessReturn","jb","pValue","chiSquaredCDF","statistic","isNormal","incompleteGamma","incompleteGammaLowerSeries","incompleteGammaUpperContinuedFraction","gln","logGamma","term","tiny","h","an","del","coef","ser","xx","y","tmp","maxD","empirical","theoretical","normalCDF","critical","erf","t","denominator","w","valuesI","valuesJ","calculateCorrelation","meanX","meanY","numerator","sumXX","sumYY","dx","dy","lower","upper","ceil","weight","seed","stopSimulation","isSimulationRunning"],"mappings":"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"}