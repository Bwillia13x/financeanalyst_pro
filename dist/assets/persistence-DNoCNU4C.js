class e{constructor(){this.currentVersion="1.0.0",this.migrationKey="financeanalyst_migration_version",this.backupKey="financeanalyst_migration_backup",this.migrations={"0.0.0":{to:"1.0.0",description:"Initial migration to structured persistence layer",migrate:this.migrateToV1_0_0.bind(this)}}}async checkAndMigrate(){try{const e=localStorage.getItem(this.migrationKey);return e?e!==this.currentVersion&&await this.performVersionMigration(e,this.currentVersion):await this.performInitialMigration(),localStorage.setItem(this.migrationKey,this.currentVersion),{success:!0,version:this.currentVersion}}catch(e){return{success:!1,error:e.message}}}async performInitialMigration(){try{const e=await this.detectLegacyData();Object.keys(e).length>0&&(await this.createMigrationBackup(e),await this.migrateToV1_0_0(e))}catch(e){throw e}}async performVersionMigration(e,t){try{const r=this.findMigrationPath(e,t);if(!r.length)throw new Error(`No migration path found from ${e} to ${t}`);const a=await this.exportCurrentData();await this.createMigrationBackup(a,e);for(const e of r)await e.migrate()}catch(r){throw await this.restoreFromBackup(),r}}async detectLegacyData(){const e={};try{const t=localStorage.getItem("commandProcessor_variables");t&&(e.variables=JSON.parse(t));const r=localStorage.getItem("commandProcessor_settings");r&&(e.settings=JSON.parse(r));const a=localStorage.getItem("watchlists");a&&(e.watchlists=JSON.parse(a));const s=localStorage.getItem("alerts");return s&&(e.alerts=JSON.parse(s)),Object.keys(localStorage).forEach(t=>{if(t.startsWith("financeanalyst_")&&!t.includes("migration")&&!t.includes("session")&&!t.includes("user")&&!t.includes("crypto_key"))try{e[t]=JSON.parse(localStorage.getItem(t))}catch(r){e[t]=localStorage.getItem(t)}}),e}catch(t){return{}}}async migrateToV1_0_0(e=null){try{const t=e||await this.detectLegacyData();if(t.watchlists){const e=this.migrateWatchlistsFormat(t.watchlists);localStorage.setItem("financeanalyst_watchlists",JSON.stringify(e))}if(t.alerts){const e=this.migrateAlertsFormat(t.alerts);localStorage.setItem("financeanalyst_alerts",JSON.stringify(e))}if(t.settings){const e=this.migratePreferencesFormat(t.settings);localStorage.setItem("financeanalyst_preferences",JSON.stringify(e))}if(t.variables){const e=this.migrateVariablesFormat(t.variables);localStorage.setItem("financeanalyst_user_variables",JSON.stringify(e))}await this.cleanupLegacyData(t)}catch(t){throw t}}migrateWatchlistsFormat(e){const t={};return Array.isArray(e)?e.forEach((e,r)=>{const a=e.name||`Watchlist ${r+1}`;t[a]={tickers:e.tickers||e.stocks||[],created:e.created||(new Date).toISOString().split("T")[0],lastUpdated:e.lastUpdated||null}}):"object"==typeof e&&Object.entries(e).forEach(([e,r])=>{t[e]={tickers:r.tickers||r.stocks||[],created:r.created||(new Date).toISOString().split("T")[0],lastUpdated:r.lastUpdated||null}}),t}migrateAlertsFormat(e){return Array.isArray(e)?e.map(e=>({id:e.id||Date.now()+Math.random(),ticker:e.ticker,condition:e.condition,value:e.value,created:e.created||(new Date).toISOString().split("T")[0],triggered:e.triggered||!1})):[]}migratePreferencesFormat(e){return{currency:e.currency||"USD",precision:e.precision||2,dateFormat:e.dateFormat||"YYYY-MM-DD",theme:e.theme||"dark",notifications:!1!==e.notifications,autoSave:!1!==e.autoSave,commandHistory:!1!==e.commandHistory,dataRetention:e.dataRetention||30,privacy:{analytics:e.analytics||!1,crashReporting:!1!==e.crashReporting,dataSharing:e.dataSharing||!1}}}migrateVariablesFormat(e){return{...e}}async cleanupLegacyData(e){try{["commandProcessor_variables","commandProcessor_settings","watchlists","alerts"].forEach(e=>{localStorage.getItem(e)&&localStorage.removeItem(e)}),Object.keys(e).forEach(e=>{!e.startsWith("financeanalyst_")||e.includes("migration")||e.includes("session")||e.includes("user")||e.includes("crypto_key")||localStorage.removeItem(e)})}catch(t){}}async createMigrationBackup(e,t="legacy"){try{const r={version:t,timestamp:(new Date).toISOString(),data:e};localStorage.setItem(this.backupKey,JSON.stringify(r))}catch(r){}}async restoreFromBackup(){try{const e=localStorage.getItem(this.backupKey);if(!e)throw new Error("No migration backup found");const t=JSON.parse(e);return"legacy"===t.version&&Object.entries(t.data).forEach(([e,t])=>{localStorage.setItem(e,"string"==typeof t?t:JSON.stringify(t))}),!0}catch(e){return!1}}async exportCurrentData(){const e={};return Object.keys(localStorage).forEach(t=>{if(t.startsWith("financeanalyst_"))try{e[t]=JSON.parse(localStorage.getItem(t))}catch(r){e[t]=localStorage.getItem(t)}}),e}findMigrationPath(e,t){const r=this.migrations[e];return r&&r.to===t?[r]:[]}getMigrationStatus(){const e=localStorage.getItem(this.migrationKey),t=!!localStorage.getItem(this.backupKey);return{currentVersion:this.currentVersion,storedVersion:e,needsMigration:e!==this.currentVersion,hasBackup:t,availableMigrations:Object.keys(this.migrations)}}clearBackup(){localStorage.removeItem(this.backupKey)}}class t{constructor(){this.compressionFormat="gzip",this.textEncoder=new TextEncoder,this.textDecoder=new TextDecoder}async compress(e){try{return"CompressionStream"in window?await this.compressWithStream(e):await this.compressWithLZString(e)}catch(t){return e}}async decompress(e){try{return"DecompressionStream"in window&&this.isNativeCompressed(e)?await this.decompressWithStream(e):await this.decompressWithLZString(e)}catch(t){return e}}async compressWithStream(e){const t=new CompressionStream(this.compressionFormat),r=t.writable.getWriter(),a=t.readable.getReader(),s=this.textEncoder.encode(e);r.write(s),r.close();const i=[];let n=!1;for(;!n;){const{value:e,done:t}=await a.read();n=t,e&&i.push(e)}const o=i.reduce((e,t)=>e+t.length,0),c=new Uint8Array(o);let l=0;for(const h of i)c.set(h,l),l+=h.length;return"NATIVE_GZIP:"+this.arrayBufferToBase64(c.buffer)}async decompressWithStream(e){const t=e.replace("NATIVE_GZIP:",""),r=this.base64ToArrayBuffer(t),a=new DecompressionStream(this.compressionFormat),s=a.writable.getWriter(),i=a.readable.getReader();s.write(new Uint8Array(r)),s.close();const n=[];let o=!1;for(;!o;){const{value:e,done:t}=await i.read();o=t,e&&n.push(e)}const c=n.reduce((e,t)=>e+t.length,0),l=new Uint8Array(c);let h=0;for(const d of n)l.set(d,h),h+=d.length;return this.textDecoder.decode(l)}async compressWithLZString(e){const t=new Map,r=[];let a=256;for(let n=0;n<256;n++)t.set(String.fromCharCode(n),n);let s="";for(let n=0;n<e.length;n++){const i=e[n],o=s+i;t.has(o)?s=o:(r.push(t.get(s)),t.set(o,a++),s=i)}s&&r.push(t.get(s));const i=new Uint16Array(r);return"LZ_STRING:"+this.arrayBufferToBase64(i.buffer)}async decompressWithLZString(e){const t=e.replace("LZ_STRING:",""),r=this.base64ToArrayBuffer(t),a=new Uint16Array(r),s=new Map;let i=256;for(let c=0;c<256;c++)s.set(c,String.fromCharCode(c));let n="",o=String.fromCharCode(a[0]);n+=o;for(let c=1;c<a.length;c++){const e=a[c];let t;if(s.has(e))t=s.get(e);else{if(e!==i)throw new Error("Invalid compressed data");t=o+o[0]}n+=t,s.set(i++,o+t[0]),o=t}return n}isNativeCompressed(e){return"string"==typeof e&&e.startsWith("NATIVE_GZIP:")}isLZStringCompressed(e){return"string"==typeof e&&e.startsWith("LZ_STRING:")}isCompressed(e){return this.isNativeCompressed(e)||this.isLZStringCompressed(e)}getCompressionRatio(e,t){const r=new Blob([e]).size;return new Blob([t]).size/r}async estimateCompressionBenefit(e){try{const t=new Blob([e]).size,r=await this.compress(e),a=new Blob([r]).size;return{originalSize:t,compressedSize:a,ratio:a/t,savings:t-a,savingsPercentage:(t-a)/t*100,worthCompressing:a<.9*t}}catch(t){return{originalSize:new Blob([e]).size,compressedSize:new Blob([e]).size,ratio:1,savings:0,savingsPercentage:0,worthCompressing:!1,error:t.message}}}isAvailable(){return"CompressionStream"in window||!0}getInfo(){return{nativeCompressionAvailable:"CompressionStream"in window,fallbackAvailable:!0,defaultFormat:this.compressionFormat,available:this.isAvailable()}}async performanceTest(){const e=JSON.stringify({test:"compression performance",data:new Array(1e3).fill("This is test data for compression performance testing. ".repeat(10)),numbers:new Array(100).fill(0).map((e,t)=>t),timestamp:Date.now()});try{const t=performance.now();let r;for(let o=0;o<20;o++)r=await this.compress(e);const a=performance.now()-t,s=performance.now();for(let e=0;e<20;e++)await this.decompress(r);const i=performance.now()-s,n=this.getCompressionRatio(e,r);return{compressTime:a/20,decompressTime:i/20,totalTime:a+i,originalSize:e.length,compressedSize:r.length,compressionRatio:n,savingsPercentage:100*(1-n),iterations:20,method:this.isNativeCompressed(r)?"native":"lz-string"}}catch(t){return null}}arrayBufferToBase64(e){const t=new Uint8Array(e);let r="";for(let a=0;a<t.byteLength;a++)r+=String.fromCharCode(t[a]);return btoa(r)}base64ToArrayBuffer(e){const t=atob(e),r=new Uint8Array(t.length);for(let a=0;a<t.length;a++)r[a]=t.charCodeAt(a);return r.buffer}}class r{constructor(){this.dbName="FinanceAnalystPro",this.dbVersion=1,this.db=null,this.isAvailable=!1,this.compressionUtils=new t,this.stores={watchlists:{keyPath:"id",autoIncrement:!0,indexes:[{name:"name",keyPath:"name",unique:!0},{name:"created",keyPath:"created"},{name:"lastUpdated",keyPath:"lastUpdated"}]},analysis_history:{keyPath:"id",autoIncrement:!0,indexes:[{name:"ticker",keyPath:"ticker"},{name:"analysisType",keyPath:"analysisType"},{name:"timestamp",keyPath:"timestamp"}]},command_history:{keyPath:"id",autoIncrement:!0,indexes:[{name:"command",keyPath:"command"},{name:"timestamp",keyPath:"timestamp"},{name:"success",keyPath:"success"}]},alerts:{keyPath:"id",autoIncrement:!0,indexes:[{name:"ticker",keyPath:"ticker"},{name:"condition",keyPath:"condition"},{name:"created",keyPath:"created"},{name:"triggered",keyPath:"triggered"}]},cached_data:{keyPath:"key",indexes:[{name:"timestamp",keyPath:"timestamp"},{name:"expiry",keyPath:"expiry"},{name:"dataType",keyPath:"dataType"}]},user_models:{keyPath:"id",autoIncrement:!0,indexes:[{name:"name",keyPath:"name"},{name:"type",keyPath:"type"},{name:"created",keyPath:"created"}]},export_data:{keyPath:"id",autoIncrement:!0,indexes:[{name:"timestamp",keyPath:"timestamp"},{name:"type",keyPath:"type"}]}}}async initialize(){if(!window.indexedDB)return this.isAvailable=!1,{success:!1,available:!1};try{return this.db=await this.openDatabase(),this.isAvailable=!0,await this.cleanupExpiredData(),{success:!0,available:!0,version:this.dbVersion}}catch(e){return this.isAvailable=!1,{success:!1,available:!1,error:e.message}}}async openDatabase(){return new Promise((e,t)=>{const r=indexedDB.open(this.dbName,this.dbVersion);r.onerror=()=>{t(new Error(`Failed to open database: ${r.error}`))},r.onsuccess=()=>{e(r.result)},r.onupgradeneeded=e=>{const t=e.target.result;this.createObjectStores(t)}})}createObjectStores(e){for(const t of Object.keys(this.stores))e.objectStoreNames.contains(t)&&e.deleteObjectStore(t);for(const[t,r]of Object.entries(this.stores)){const a=e.createObjectStore(t,{keyPath:r.keyPath,autoIncrement:r.autoIncrement});r.indexes&&r.indexes.forEach(e=>{a.createIndex(e.name,e.keyPath,{unique:e.unique||!1})})}}async store(e,t,r={}){if(!this.isAvailable)throw new Error("IndexedDB is not available");const{storeName:a="cached_data",metadata:s={},compress:i=!1}=r;try{const r={key:e,data:t,timestamp:Date.now(),metadata:{...s,compressed:i,originalSize:JSON.stringify(t).length}};if(i){const e=await this.compressionUtils.compress(JSON.stringify(t));r.data=e,r.metadata.compressedSize=e.length}return{success:!0,key:await this.performTransaction(a,"readwrite",e=>e.put(r)),storeName:a,size:JSON.stringify(r).length,metadata:r.metadata}}catch(n){throw n}}async retrieve(e,t={}){if(!this.isAvailable)return null;const{storeName:r="cached_data"}=t;try{const t=await this.performTransaction(r,"readonly",t=>t.get(e));if(!t)return null;if(t.metadata&&t.metadata.expiry&&Date.now()>t.metadata.expiry)return await this.remove(e,{storeName:r}),null;let a=t.data;return t.metadata&&t.metadata.compressed&&(a=JSON.parse(await this.compressionUtils.decompress(a))),{data:a,metadata:t.metadata,timestamp:t.timestamp}}catch(a){return null}}async remove(e,t={}){if(!this.isAvailable)return!1;const{storeName:r="cached_data"}=t;try{return await this.performTransaction(r,"readwrite",t=>t.delete(e)),!0}catch(a){return!1}}async clear(e=null){if(!this.isAvailable)return!1;try{if(e)await this.performTransaction(e,"readwrite",e=>e.clear());else for(const e of Object.keys(this.stores))await this.performTransaction(e,"readwrite",e=>e.clear());return!0}catch(t){return!1}}async getKeys(e="cached_data"){if(!this.isAvailable)return[];try{return await this.performTransaction(e,"readonly",e=>e.getAllKeys())}catch(t){return[]}}async getAll(e="cached_data",t={}){if(!this.isAvailable)return[];const{limit:r=null,filter:a=null}=t;try{const t=await this.performTransaction(e,"readonly",e=>e.getAll());let s=t;return a&&(s=t.filter(a)),r&&(s=s.slice(0,r)),s}catch(s){return[]}}async query(e,t,r,a={}){if(!this.isAvailable)return[];const{limit:s=null}=a;try{return await this.performTransaction(e,"readonly",e=>{const a=e.index(t);return s?a.getAll(r,s):a.getAll(r)})}catch(i){return[]}}async getStats(){if(!this.isAvailable)return{available:!1,stores:{},total:{records:0,size:0}};try{const e={available:!0,stores:{},total:{records:0,size:0}};for(const t of Object.keys(this.stores)){const r=await this.getAll(t),a=r.length,s=r.reduce((e,t)=>e+JSON.stringify(t).length,0);e.stores[t]={records:a,size:s},e.total.records+=a,e.total.size+=s}return e}catch(e){return{available:!1,error:e.message}}}async exportAll(){if(!this.isAvailable)return{};try{const e={};for(const t of Object.keys(this.stores))e[t]=await this.getAll(t);return e}catch(e){return{}}}async importData(e,t={}){if(!this.isAvailable)throw new Error("IndexedDB is not available");const{overwrite:r=!1}=t;try{const t={imported:0,skipped:0,errors:0};for(const[s,i]of Object.entries(e))if(this.stores[s])for(const e of i)try{if(!r&&await this.retrieve(e.key||e.id,{storeName:s})){t.skipped++;continue}await this.performTransaction(s,"readwrite",t=>t.put(e)),t.imported++}catch(a){t.errors++}return t}catch(a){throw a}}async cleanupExpiredData(){if(!this.isAvailable)return{cleaned:0};try{let e=0;const t=Date.now(),r=await this.getAll("cached_data");for(const a of r)a.metadata&&a.metadata.expiry&&t>a.metadata.expiry&&(await this.remove(a.key,{storeName:"cached_data"}),e++);return{cleaned:e}}catch(e){return{cleaned:0,error:e.message}}}async performTransaction(e,t,r){return new Promise((a,s)=>{const i=this.db.transaction([e],t),n=i.objectStore(e);i.onerror=()=>{s(new Error(`Transaction failed: ${i.error}`))},i.oncomplete=()=>{};const o=r(n);o.onsuccess=()=>{a(o.result)},o.onerror=()=>{s(new Error(`Operation failed: ${o.error}`))}})}isStorageAvailable(){return this.isAvailable}getInfo(){return{dbName:this.dbName,dbVersion:this.dbVersion,available:this.isAvailable,stores:Object.keys(this.stores),storeCount:Object.keys(this.stores).length}}}class a{constructor(){this.algorithm="AES-GCM",this.keyLength=256,this.ivLength=12,this.tagLength=16,this.textEncoder=new TextEncoder,this.textDecoder=new TextDecoder,this.initializeKey()}async initializeKey(){try{const e=localStorage.getItem("financeanalyst_crypto_key");if(e){const t=this.base64ToArrayBuffer(e);this.cryptoKey=await crypto.subtle.importKey("raw",t,{name:this.algorithm},!1,["encrypt","decrypt"])}else{this.cryptoKey=await crypto.subtle.generateKey({name:this.algorithm,length:this.keyLength},!0,["encrypt","decrypt"]);const e=await crypto.subtle.exportKey("raw",this.cryptoKey),t=this.arrayBufferToBase64(e);localStorage.setItem("financeanalyst_crypto_key",t)}}catch(e){throw e}}async encrypt(e){this.cryptoKey||await this.initializeKey();try{const t=this.textEncoder.encode(e),r=crypto.getRandomValues(new Uint8Array(this.ivLength)),a=await crypto.subtle.encrypt({name:this.algorithm,iv:r},this.cryptoKey,t),s=new Uint8Array(r.length+a.byteLength);return s.set(r,0),s.set(new Uint8Array(a),r.length),this.arrayBufferToBase64(s.buffer)}catch(t){throw new Error(`Encryption failed: ${t.message}`)}}async decrypt(e){this.cryptoKey||await this.initializeKey();try{const t=this.base64ToArrayBuffer(e),r=t.slice(0,this.ivLength),a=t.slice(this.ivLength),s=await crypto.subtle.decrypt({name:this.algorithm,iv:r},this.cryptoKey,a);return this.textDecoder.decode(s)}catch(t){throw new Error(`Decryption failed: ${t.message}`)}}async hash(e){try{const t=this.textEncoder.encode(e),r=await crypto.subtle.digest("SHA-256",t);return this.arrayBufferToBase64(r)}catch(t){throw new Error(`Hashing failed: ${t.message}`)}}async verifyIntegrity(e,t){try{return await this.hash(e)===t}catch(r){return!1}}generateRandomString(e=32){const t=new Uint8Array(e);return crypto.getRandomValues(t),this.arrayBufferToBase64(t.buffer).substring(0,e)}async deriveKeyFromPassword(e,t){try{const r=this.textEncoder.encode(e),a=this.textEncoder.encode(t),s=await crypto.subtle.importKey("raw",r,{name:"PBKDF2"},!1,["deriveKey"]);return await crypto.subtle.deriveKey({name:"PBKDF2",salt:a,iterations:1e5,hash:"SHA-256"},s,{name:this.algorithm,length:this.keyLength},!1,["encrypt","decrypt"])}catch(r){throw new Error(`Key derivation failed: ${r.message}`)}}isAvailable(){return!(!window.crypto||!window.crypto.subtle)}getInfo(){return{algorithm:this.algorithm,keyLength:this.keyLength,ivLength:this.ivLength,available:this.isAvailable(),keyInitialized:!!this.cryptoKey}}arrayBufferToBase64(e){const t=new Uint8Array(e);let r="";for(let a=0;a<t.byteLength;a++)r+=String.fromCharCode(t[a]);return btoa(r)}base64ToArrayBuffer(e){const t=atob(e),r=new Uint8Array(t.length);for(let a=0;a<t.length;a++)r[a]=t.charCodeAt(a);return r.buffer}clearSensitiveData(e){if(e instanceof ArrayBuffer){const t=new Uint8Array(e);crypto.getRandomValues(t)}else"string"==typeof e&&(e=null)}async performanceTest(){if(!this.isAvailable())return null;const e=JSON.stringify({test:"performance",data:new Array(1e3).fill("test data for performance testing"),timestamp:Date.now()});try{const t=performance.now();let r;for(let n=0;n<50;n++)r=await this.encrypt(e);const a=performance.now()-t,s=performance.now();for(let e=0;e<50;e++)await this.decrypt(r);const i=performance.now()-s;return{encryptTime:a/50,decryptTime:i/50,totalTime:a+i,dataSize:e.length,encryptedSize:r.length,compressionRatio:r.length/e.length,iterations:50}}catch(t){return null}}}class s{constructor(){this.prefix="financeanalyst_",this.isAvailable=!1,this.maxSize=5242880,this.cryptoUtils=new a,this.compressionUtils=new t}async initialize(){try{const e=this.prefix+"test";return localStorage.setItem(e,"test"),localStorage.removeItem(e),this.isAvailable=!0,{success:!0,available:!0}}catch(e){return this.isAvailable=!1,{success:!1,available:!1,error:e.message}}}async store(e,t,r={}){if(!this.isAvailable)throw new Error("localStorage is not available");const{encrypt:a=!1,compress:s=!1,ttl:i=null,validate:n=!0}=r;try{if(n&&!this.validateData(t))throw new Error("Invalid data format");const r={data:t,metadata:{timestamp:Date.now(),version:"1.0",encrypted:a,compressed:s,ttl:i,originalSize:JSON.stringify(t).length}};let o=JSON.stringify(r);if(s&&(o=await this.compressionUtils.compress(o),r.metadata.compressedSize=o.length),a&&(o=await this.cryptoUtils.encrypt(o)),o.length>this.maxSize)throw new Error(`Data too large: ${o.length} bytes exceeds ${this.maxSize} bytes`);const c=this.prefix+e;return localStorage.setItem(c,o),{success:!0,key:c,size:o.length,metadata:r.metadata}}catch(o){throw o}}async retrieve(e,t={}){if(!this.isAvailable)return null;const{decrypt:r=!1,validateTTL:a=!0}=t;try{const t=this.prefix+e;let n,o=localStorage.getItem(t);if(!o)return null;r&&(o=await this.cryptoUtils.decrypt(o));try{n=JSON.parse(o)}catch(s){try{const e=await this.compressionUtils.decompress(o);n=JSON.parse(e)}catch(i){throw new Error("Failed to parse stored data")}}return a&&n.metadata&&n.metadata.ttl&&Date.now()>n.metadata.timestamp+n.metadata.ttl?(await this.remove(e),null):{data:n.data,metadata:n.metadata}}catch(n){return null}}async remove(e){if(!this.isAvailable)return!1;try{const t=this.prefix+e;return localStorage.removeItem(t),!0}catch(t){return!1}}async clear(){if(!this.isAvailable)return!1;try{return Object.keys(localStorage).filter(e=>e.startsWith(this.prefix)).forEach(e=>{localStorage.removeItem(e)}),!0}catch(e){return!1}}async getKeys(){if(!this.isAvailable)return[];try{return Object.keys(localStorage).filter(e=>e.startsWith(this.prefix)).map(e=>e.substring(this.prefix.length))}catch(e){return[]}}async getStats(){if(!this.isAvailable)return{available:!1,used:0,keys:0};try{const e=await this.getKeys();let t=0,r=0;const a={};for(const s of e){const e=this.prefix+s,i=localStorage.getItem(e);if(i){const e=i.length;t+=e,r++,a[s]=e}}return{available:!0,used:t,keys:r,maxSize:this.maxSize,usagePercentage:t/this.maxSize*100,itemSizes:a,largestItem:Object.entries(a).reduce((e,[t,r])=>r>e.size?{key:t,size:r}:e,{key:null,size:0})}}catch(e){return{available:!1,used:0,keys:0,error:e.message}}}async exportAll(){if(!this.isAvailable)return{};try{const e=await this.getKeys(),t={};for(const r of e){const e=await this.retrieve(r,{validateTTL:!1});e&&(t[r]=e)}return t}catch(e){return{}}}async importData(e,t={}){if(!this.isAvailable)throw new Error("localStorage is not available");const{overwrite:r=!1}=t;try{const t={imported:0,skipped:0,errors:0};for(const[s,i]of Object.entries(e))try{if(await this.retrieve(s,{validateTTL:!1})&&!r){t.skipped++;continue}await this.store(s,i.data,{encrypt:i.metadata?.encrypted||!1,compress:i.metadata?.compressed||!1,ttl:i.metadata?.ttl||null}),t.imported++}catch(a){t.errors++}return t}catch(a){throw a}}async hasSpace(e){if(!this.isAvailable)return!1;try{return(await this.getStats()).used+e<=this.maxSize}catch(t){return!1}}async cleanup(){if(!this.isAvailable)return{cleaned:0};try{const e=await this.getKeys();let t=0;for(const r of e)await this.retrieve(r,{validateTTL:!0})||t++;return{cleaned:t}}catch(e){return{cleaned:0,error:e.message}}}validateData(e){try{JSON.stringify(e);const t=new WeakSet,r=e=>{if(null!==e&&"object"==typeof e){if(t.has(e))return!1;t.add(e);for(const t in e)if(!r(e[t]))return!1}return!0};return r(e)}catch(t){return!1}}isStorageAvailable(){return this.isAvailable}async performanceTest(){if(!this.isAvailable)return null;const e={test:"performance",data:new Array(1e3).fill("test")},t=100;try{const r=performance.now();for(let n=0;n<t;n++)await this.store(`perf_test_${n}`,e);const a=performance.now()-r,s=performance.now();for(let e=0;e<t;e++)await this.retrieve(`perf_test_${e}`);const i=performance.now()-s;for(let e=0;e<t;e++)await this.remove(`perf_test_${e}`);return{writeTime:a/t,readTime:i/t,totalTime:a+i,iterations:t}}catch(r){return null}}}class i{constructor(){this.sessionKey="financeanalyst_session",this.userKey="financeanalyst_user",this.preferencesKey="financeanalyst_preferences",this.cryptoUtils=new a,this.currentSession=null,this.currentUser=null,this.sessionTimeout=864e5,this.listeners=new Set,this.defaultPreferences={currency:"USD",precision:2,dateFormat:"YYYY-MM-DD",theme:"dark",notifications:!0,autoSave:!0,commandHistory:!0,dataRetention:30,privacy:{analytics:!1,crashReporting:!0,dataSharing:!1}}}async initialize(){try{return await this.loadSession(),this.setupSessionMonitoring(),{success:!0,hasSession:!!this.currentSession}}catch(e){return{success:!1,error:e.message}}}async createSession(e={}){try{const t=this.generateSessionId(),r=Date.now(),a={id:t,userId:e.id||this.generateUserId(),created:r,lastActivity:r,expires:r+this.sessionTimeout,userAgent:navigator.userAgent,platform:navigator.platform,language:navigator.language,timezone:Intl.DateTimeFormat().resolvedOptions().timeZone,version:"1.0"},s={id:a.userId,name:e.name||"Anonymous User",email:e.email||null,created:e.created||r,lastLogin:r,loginCount:(e.loginCount||0)+1,preferences:{...this.defaultPreferences,...e.preferences}};return await this.storeSession(a),await this.storeUser(s),this.currentSession=a,this.currentUser=s,this.notifyListeners("sessionCreated",{session:a,user:s}),{success:!0,session:a,user:s}}catch(t){throw t}}async loadSession(){try{const e=localStorage.getItem(this.sessionKey),t=localStorage.getItem(this.userKey);if(!e||!t)return null;const r=JSON.parse(e),a=JSON.parse(t);return Date.now()>r.expires?(await this.destroySession(),null):(r.lastActivity=Date.now(),await this.storeSession(r),this.currentSession=r,this.currentUser=a,this.notifyListeners("sessionLoaded",{session:r,user:a}),{session:r,user:a})}catch(e){return await this.destroySession(),null}}async updateActivity(){if(!this.currentSession)return!1;try{return this.currentSession.lastActivity=Date.now(),this.currentSession.expires-Date.now()<.1*this.sessionTimeout&&(this.currentSession.expires=Date.now()+this.sessionTimeout),await this.storeSession(this.currentSession),!0}catch(e){return!1}}async destroySession(){try{const e=this.currentSession,t=this.currentUser;return localStorage.removeItem(this.sessionKey),this.currentSession=null,this.currentUser=null,this.notifyListeners("sessionDestroyed",{session:e,user:t}),!0}catch(e){return!1}}getSession(){return this.currentSession}getUser(){return this.currentUser}isAuthenticated(){return!!(this.currentSession&&Date.now()<this.currentSession.expires)}getPreferences(){return this.currentUser?this.currentUser.preferences:this.defaultPreferences}async updatePreferences(e){if(!this.currentUser)throw new Error("No active user session");try{return this.currentUser.preferences={...this.currentUser.preferences,...e},await this.storeUser(this.currentUser),localStorage.setItem(this.preferencesKey,JSON.stringify(this.currentUser.preferences)),this.notifyListeners("preferencesUpdated",{preferences:this.currentUser.preferences}),this.currentUser.preferences}catch(t){throw t}}getSessionStats(){if(!this.currentSession||!this.currentUser)return null;const e=Date.now(),t=e-this.currentSession.created,r=this.currentSession.expires-e,a=e-this.currentSession.lastActivity;return{sessionId:this.currentSession.id,userId:this.currentUser.id,userName:this.currentUser.name,sessionDuration:t,timeUntilExpiry:r,lastActivityAge:a,loginCount:this.currentUser.loginCount,userCreated:this.currentUser.created,isExpired:r<=0,isActive:a<3e5}}async exportSessionData(){return this.currentSession&&this.currentUser?{session:{...this.currentSession},user:{...this.currentUser},preferences:{...this.currentUser.preferences},exportTimestamp:Date.now()}:null}async importSessionData(e){try{if(!e||!e.session||!e.user)throw new Error("Invalid session data format");const t=e.session,r=e.user;return t.lastActivity=Date.now(),t.expires=Date.now()+this.sessionTimeout,r.lastLogin=Date.now(),await this.storeSession(t),await this.storeUser(r),this.currentSession=t,this.currentUser=r,this.notifyListeners("sessionImported",{session:t,user:r}),{success:!0,session:t,user:r}}catch(t){throw t}}addEventListener(e){this.listeners.add(e)}removeEventListener(e){this.listeners.delete(e)}async storeSession(e){try{localStorage.setItem(this.sessionKey,JSON.stringify(e))}catch(t){throw t}}async storeUser(e){try{localStorage.setItem(this.userKey,JSON.stringify(e))}catch(t){throw t}}generateSessionId(){return"sess_"+Date.now()+"_"+Math.random().toString(36).substr(2,9)}generateUserId(){return"user_"+Date.now()+"_"+Math.random().toString(36).substr(2,9)}setupSessionMonitoring(){let e=Date.now();const t=this.throttle(()=>{const t=Date.now();t-e>6e4&&(this.updateActivity(),e=t)},1e3);["click","keypress","scroll","mousemove"].forEach(e=>{document.addEventListener(e,t,{passive:!0})}),setInterval(()=>{this.currentSession&&Date.now()>this.currentSession.expires&&this.destroySession()},6e4),document.addEventListener("visibilitychange",()=>{document.hidden||this.updateActivity()}),window.addEventListener("beforeunload",()=>{this.updateActivity()})}throttle(e,t){let r;return function(){const a=arguments;r||(e.apply(this,a),r=!0,setTimeout(()=>r=!1,t))}}notifyListeners(e,t){this.listeners.forEach(r=>{try{r(e,t)}catch(a){}})}}const n=new class{constructor(){this.localStorage=new s,this.indexedDB=new r,this.sessionManager=new i,this.migrationService=new e,this.isInitialized=!1,this.storageQuota=null,this.listeners=new Map,this.storageStrategy={localStorage:["user_preferences","session_data","ui_state","recent_commands","quick_settings"],indexedDB:["watchlists","analysis_history","command_history","alerts","cached_data","user_models","export_data"]}}async initialize(){if(!this.isInitialized)try{return await this.checkStorageAvailability(),await Promise.all([this.localStorage.initialize(),this.indexedDB.initialize(),this.sessionManager.initialize()]),await this.migrationService.checkAndMigrate(),await this.estimateStorageQuota(),this.isInitialized=!0,{success:!0,storageQuota:this.storageQuota,availableStorage:await this.getAvailableStorage()}}catch(e){throw new Error(`Persistence initialization failed: ${e.message}`)}}async store(e,t,r={}){await this.ensureInitialized();const{storage:a=this.determineStorageLayer(e),encrypt:s=!1,compress:i=!1,ttl:n=null}=r;try{const r={timestamp:Date.now(),version:"1.0",encrypted:s,compressed:i,ttl:n,size:JSON.stringify(t).length};let o;if("localStorage"===a)o=await this.localStorage.store(e,t,{encrypt:s,ttl:n});else{if("indexedDB"!==a)throw new Error(`Unknown storage layer: ${a}`);o=await this.indexedDB.store(e,t,{metadata:r,compress:i})}return this.notifyListeners("store",{key:e,storage:a,metadata:r}),o}catch(o){throw o}}async retrieve(e,t={}){await this.ensureInitialized();const{storage:r=this.determineStorageLayer(e),decrypt:a=!1}=t;try{let t;return t="localStorage"===r?await this.localStorage.retrieve(e,{decrypt:a}):"indexedDB"===r?await this.indexedDB.retrieve(e):await this.localStorage.retrieve(e,{decrypt:a})||await this.indexedDB.retrieve(e),t&&t.metadata&&t.metadata.ttl&&Date.now()>t.metadata.timestamp+t.metadata.ttl?(await this.remove(e,{storage:r}),null):t?t.data||t:null}catch(s){return null}}async remove(e,t={}){await this.ensureInitialized();const{storage:r="both"}=t;try{const t=[];return"localStorage"!==r&&"both"!==r||t.push(this.localStorage.remove(e)),"indexedDB"!==r&&"both"!==r||t.push(this.indexedDB.remove(e)),await Promise.all(t),this.notifyListeners("remove",{key:e,storage:r}),!0}catch(a){throw a}}async clear(e={}){await this.ensureInitialized();const{storage:t="both",confirm:r=!1}=e;if(!r)throw new Error("Clear operation requires explicit confirmation");try{const e=[];return"localStorage"!==t&&"both"!==t||e.push(this.localStorage.clear()),"indexedDB"!==t&&"both"!==t||e.push(this.indexedDB.clear()),await Promise.all(e),this.notifyListeners("clear",{storage:t}),!0}catch(a){throw a}}async getStorageStats(){await this.ensureInitialized();try{const[e,t]=await Promise.all([this.localStorage.getStats(),this.indexedDB.getStats()]),r=e.used+t.used;return{localStorage:e,indexedDB:t,total:{used:r,available:await this.getAvailableStorage(),quota:this.storageQuota,usagePercentage:this.storageQuota?r/this.storageQuota*100:0}}}catch(e){return null}}async exportData(e={}){await this.ensureInitialized();const{format:t="json",includeMetadata:r=!0}=e;try{const[a,s]=await Promise.all([this.localStorage.exportAll(),this.indexedDB.exportAll()]),i={version:"1.0",timestamp:(new Date).toISOString(),localStorage:a,indexedDB:s};return r&&(i.metadata={userAgent:navigator.userAgent,storageStats:await this.getStorageStats(),exportOptions:e}),{data:i,size:JSON.stringify(i).length,format:t}}catch(a){throw a}}async importData(e,t={}){await this.ensureInitialized();const{overwrite:r=!1,validate:a=!0,backup:s=!0}=t;try{if(a&&!this.validateImportData(e))throw new Error("Invalid import data format");if(s){const e=await this.exportData();await this.store("backup_before_import",e,{storage:"indexedDB",ttl:6048e5})}return e.localStorage&&await this.localStorage.importData(e.localStorage,{overwrite:r}),e.indexedDB&&await this.indexedDB.importData(e.indexedDB,{overwrite:r}),this.notifyListeners("import",{size:JSON.stringify(e).length}),{success:!0,imported:{localStorage:Object.keys(e.localStorage||{}).length,indexedDB:Object.keys(e.indexedDB||{}).length}}}catch(i){throw i}}addEventListener(e,t){this.listeners.has(e)||this.listeners.set(e,new Set),this.listeners.get(e).add(t)}removeEventListener(e,t){this.listeners.has(e)&&this.listeners.get(e).delete(t)}async ensureInitialized(){this.isInitialized||await this.initialize()}determineStorageLayer(e){return this.storageStrategy.localStorage.includes(e)?"localStorage":this.storageStrategy.indexedDB.includes(e)?"indexedDB":"localStorage"}async checkStorageAvailability(){if(!window.localStorage)throw new Error("localStorage is not available");if(!window.indexedDB)throw new Error("IndexedDB is not available");return!0}async estimateStorageQuota(){if("storage"in navigator&&"estimate"in navigator.storage){const e=await navigator.storage.estimate();return this.storageQuota=e.quota,e}return null}async getAvailableStorage(){if("storage"in navigator&&"estimate"in navigator.storage){const e=await navigator.storage.estimate();return e.quota-e.usage}return null}validateImportData(e){return e&&"object"==typeof e&&e.version&&(e.localStorage||e.indexedDB)}notifyListeners(e,t){this.listeners.has(e)&&this.listeners.get(e).forEach(e=>{try{e(t)}catch(r){}})}};export{n as p};
//# sourceMappingURL=persistence-DNoCNU4C.js.map
