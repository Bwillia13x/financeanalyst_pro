{"version":3,"file":"financial-engines-B7TnAHCU.js","sources":["../../src/utils/apiLogger.js","../../src/services/financialModelingEngine.js","../../src/services/lboModelingEngine.js","../../src/services/monteCarloEngine.js"],"sourcesContent":["/**\n * Enhanced API logging and monitoring utility\n * Provides comprehensive logging, metrics collection, and performance monitoring\n */\n\n// Log levels\nconst LOG_LEVELS = {\n  ERROR: 0,\n  WARN: 1,\n  INFO: 2,\n  DEBUG: 3,\n  TRACE: 4\n};\n\n// Default configuration\nconst DEFAULT_CONFIG = {\n  logLevel: LOG_LEVELS.INFO,\n  enableMetrics: true,\n  enablePerformanceTracking: true,\n  enableErrorTracking: true,\n  maxLogHistory: 1000,\n  metricsRetentionPeriod: 24 * 60 * 60 * 1000 // 24 hours\n};\n\n/**\n * API Logger class for comprehensive monitoring\n */\nclass ApiLogger {\n  constructor(config = {}) {\n    this.config = { ...DEFAULT_CONFIG, ...config };\n    this.logs = [];\n    this.metrics = new Map();\n    this.performanceData = new Map();\n    this.errorCounts = new Map();\n    this.startTime = Date.now();\n  }\n\n  /**\n   * Log a message with specified level\n   * @param {string} level - Log level\n   * @param {string} message - Log message\n   * @param {Object} metadata - Additional metadata\n   */\n  log(level, message, metadata = {}) {\n    const levelValue = LOG_LEVELS[level.toUpperCase()] || LOG_LEVELS.INFO;\n\n    if (levelValue <= this.config.logLevel) {\n      const logEntry = {\n        timestamp: new Date().toISOString(),\n        level: level.toUpperCase(),\n        message,\n        metadata,\n        id: this.generateLogId()\n      };\n\n      this.logs.push(logEntry);\n      this.trimLogs();\n\n      // Console output with formatting\n      this.outputToConsole(logEntry);\n    }\n  }\n\n  /**\n   * Log API request start\n   * @param {string} service - Service name (e.g., 'FMP', 'ALPHA_VANTAGE')\n   * @param {string} endpoint - API endpoint\n   * @param {Object} params - Request parameters\n   * @returns {string} Request ID for tracking\n   */\n  logApiRequest(service, endpoint, params = {}) {\n    const requestId = this.generateRequestId();\n    const startTime = Date.now();\n\n    this.log('INFO', '🚀 API Request Started', {\n      requestId,\n      service,\n      endpoint,\n      params: this.sanitizeParams(params),\n      startTime\n    });\n\n    // Store performance tracking data\n    this.performanceData.set(requestId, {\n      service,\n      endpoint,\n      startTime,\n      params: this.sanitizeParams(params)\n    });\n\n    return requestId;\n  }\n\n  /**\n   * Log API request completion\n   * @param {string} requestId - Request ID from logApiRequest\n   * @param {boolean} success - Whether request was successful\n   * @param {Object} response - Response data (will be sanitized)\n   * @param {Error} error - Error object if request failed\n   */\n  logApiResponse(requestId, success, response = null, error = null) {\n    const performanceData = this.performanceData.get(requestId);\n    if (!performanceData) {\n      this.log('WARN', 'No performance data found for request', { requestId });\n      return;\n    }\n\n    const endTime = Date.now();\n    const duration = endTime - performanceData.startTime;\n    const { service, endpoint } = performanceData;\n\n    if (success) {\n      this.log('INFO', '✅ API Request Completed', {\n        requestId,\n        service,\n        endpoint,\n        duration,\n        responseSize: this.getResponseSize(response),\n        success: true\n      });\n\n      this.recordMetric(service, 'success', 1);\n    } else {\n      this.log('ERROR', '❌ API Request Failed', {\n        requestId,\n        service,\n        endpoint,\n        duration,\n        error: error\n          ? {\n            message: error.message,\n            code: error.code,\n            status: error.response?.status,\n            statusText: error.response?.statusText\n          }\n          : null,\n        success: false\n      });\n\n      this.recordMetric(service, 'error', 1);\n      this.recordError(service, error);\n    }\n\n    // Record performance metrics\n    this.recordMetric(service, 'duration', duration);\n    this.recordMetric(service, 'requests', 1);\n\n    // Clean up performance data\n    this.performanceData.delete(requestId);\n  }\n\n  /**\n   * Log rate limiting events\n   * @param {string} service - Service name\n   * @param {number} waitTime - Time to wait in milliseconds\n   * @param {number} remainingRequests - Remaining requests in current period\n   */\n  logRateLimit(service, waitTime, remainingRequests = null) {\n    this.log('WARN', '⏱️ Rate Limit Hit', {\n      service,\n      waitTime,\n      remainingRequests,\n      action: 'throttling'\n    });\n\n    this.recordMetric(service, 'rateLimitHits', 1);\n  }\n\n  /**\n   * Log circuit breaker events\n   * @param {string} service - Service name\n   * @param {string} state - Circuit breaker state\n   * @param {string} action - Action taken\n   * @param {Object} metadata - Additional metadata\n   */\n  logCircuitBreaker(service, state, action, metadata = {}) {\n    const emoji =\n      {\n        OPEN: '🚨',\n        HALF_OPEN: '🔄',\n        CLOSED: '✅'\n      }[state] || '🔧';\n\n    this.log('WARN', `${emoji} Circuit Breaker ${action}`, {\n      service,\n      state,\n      action,\n      ...metadata\n    });\n\n    this.recordMetric(service, `circuitBreaker_${state.toLowerCase()}`, 1);\n  }\n\n  /**\n   * Log cache events\n   * @param {string} operation - Cache operation (hit, miss, set, clear)\n   * @param {string} key - Cache key\n   * @param {Object} metadata - Additional metadata\n   */\n  logCache(operation, key, metadata = {}) {\n    const emoji =\n      {\n        hit: '🎯',\n        miss: '❌',\n        set: '💾',\n        clear: '🗑️'\n      }[operation] || '📦';\n\n    this.log('DEBUG', `${emoji} Cache ${operation.toUpperCase()}`, {\n      operation,\n      key: this.sanitizeCacheKey(key),\n      ...metadata\n    });\n\n    this.recordMetric('cache', operation, 1);\n  }\n\n  /**\n   * Record a metric\n   * @param {string} service - Service name\n   * @param {string} metric - Metric name\n   * @param {number} value - Metric value\n   */\n  recordMetric(service, metric, value) {\n    if (!this.config.enableMetrics) return;\n\n    const key = `${service}.${metric}`;\n    const now = Date.now();\n\n    if (!this.metrics.has(key)) {\n      this.metrics.set(key, {\n        values: [],\n        total: 0,\n        count: 0,\n        min: Infinity,\n        max: -Infinity,\n        avg: 0\n      });\n    }\n\n    const metricData = this.metrics.get(key);\n    metricData.values.push({ value, timestamp: now });\n    metricData.total += value;\n    metricData.count += 1;\n    metricData.min = Math.min(metricData.min, value);\n    metricData.max = Math.max(metricData.max, value);\n    metricData.avg = metricData.total / metricData.count;\n\n    // Clean old metrics\n    this.cleanOldMetrics(key);\n  }\n\n  /**\n   * Record an error for tracking\n   * @param {string} service - Service name\n   * @param {Error} error - Error object\n   */\n  recordError(service, error) {\n    if (!this.config.enableErrorTracking || !error) return;\n\n    const errorKey = `${service}.${error.message}`;\n    const count = this.errorCounts.get(errorKey) || 0;\n    this.errorCounts.set(errorKey, count + 1);\n  }\n\n  /**\n   * Get comprehensive metrics summary\n   * @returns {Object} Metrics summary\n   */\n  getMetrics() {\n    const summary = {\n      uptime: Date.now() - this.startTime,\n      totalLogs: this.logs.length,\n      services: {},\n      cache: {},\n      errors: {}\n    };\n\n    // Process service metrics\n    for (const [key, data] of this.metrics.entries()) {\n      const [service, metric] = key.split('.');\n\n      if (service === 'cache') {\n        summary.cache[metric] = {\n          total: data.total,\n          count: data.count,\n          avg: data.avg\n        };\n      } else {\n        if (!summary.services[service]) {\n          summary.services[service] = {};\n        }\n\n        summary.services[service][metric] = {\n          total: data.total,\n          count: data.count,\n          min: data.min === Infinity ? 0 : data.min,\n          max: data.max === -Infinity ? 0 : data.max,\n          avg: data.avg\n        };\n      }\n    }\n\n    // Process error counts\n    for (const [errorKey, count] of this.errorCounts.entries()) {\n      const [service, ...messageParts] = errorKey.split('.');\n      const message = messageParts.join('.');\n\n      if (!summary.errors[service]) {\n        summary.errors[service] = {};\n      }\n\n      summary.errors[service][message] = count;\n    }\n\n    return summary;\n  }\n\n  /**\n   * Get recent logs\n   * @param {number} limit - Maximum number of logs to return\n   * @param {string} level - Filter by log level\n   * @returns {Array} Recent log entries\n   */\n  getRecentLogs(limit = 100, level = null) {\n    let logs = [...this.logs];\n\n    if (level) {\n      logs = logs.filter(log => log.level === level.toUpperCase());\n    }\n\n    return logs.slice(-limit).reverse();\n  }\n\n  /**\n   * Clear all logs and metrics\n   */\n  clear() {\n    this.logs = [];\n    this.metrics.clear();\n    this.performanceData.clear();\n    this.errorCounts.clear();\n    this.startTime = Date.now();\n  }\n\n  // Private helper methods\n  generateLogId() {\n    return `log_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  generateRequestId() {\n    return `req_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  sanitizeParams(params) {\n    const sanitized = { ...params };\n    // Remove sensitive data\n    if (sanitized.apikey) sanitized.apikey = '***';\n    if (sanitized.api_key) sanitized.api_key = '***';\n    if (sanitized.token) sanitized.token = '***';\n    return sanitized;\n  }\n\n  sanitizeCacheKey(key) {\n    // Truncate long cache keys for readability\n    return key.length > 50 ? `${key.substring(0, 47)}...` : key;\n  }\n\n  getResponseSize(response) {\n    if (!response) return 0;\n    try {\n      return JSON.stringify(response).length;\n    } catch {\n      return 0;\n    }\n  }\n\n  trimLogs() {\n    if (this.logs.length > this.config.maxLogHistory) {\n      this.logs = this.logs.slice(-this.config.maxLogHistory);\n    }\n  }\n\n  cleanOldMetrics(key) {\n    const metricData = this.metrics.get(key);\n    const cutoff = Date.now() - this.config.metricsRetentionPeriod;\n\n    metricData.values = metricData.values.filter(item => item.timestamp > cutoff);\n  }\n\n  outputToConsole(logEntry) {\n    const { level, message, metadata } = logEntry;\n    const timestamp = new Date(logEntry.timestamp).toLocaleTimeString();\n\n    const colors = {\n      ERROR: '\\x1b[31m', // Red\n      WARN: '\\x1b[33m', // Yellow\n      INFO: '\\x1b[36m', // Cyan\n      DEBUG: '\\x1b[35m', // Magenta\n      TRACE: '\\x1b[37m' // White\n    };\n\n    const reset = '\\x1b[0m';\n    const color = colors[level] || colors.INFO;\n\n    console.log(\n      `${color}[${timestamp}] ${level}:${reset} ${message}`,\n      Object.keys(metadata).length > 0 ? metadata : ''\n    );\n  }\n}\n\n// Export singleton instance\nexport const apiLogger = new ApiLogger();\nexport default ApiLogger;\n","import { apiLogger } from '../utils/apiLogger.js';\n\n/**\n * Advanced Financial Modeling Engine\n * Provides comprehensive DCF, LBO, and valuation modeling capabilities\n */\nclass FinancialModelingEngine {\n  constructor() {\n    this.modelCache = new Map();\n    this.assumptions = this.getDefaultAssumptions();\n  }\n\n  /**\n   * Get default financial modeling assumptions\n   */\n  getDefaultAssumptions() {\n    return {\n      dcf: {\n        projectionYears: 5,\n        terminalGrowthRate: 0.025,\n        riskFreeRate: 0.045,\n        marketPremium: 0.065,\n        taxRate: 0.21,\n        capexAsPercentOfRevenue: 0.03,\n        nwcAsPercentOfRevenue: 0.05,\n        depreciationAsPercentOfRevenue: 0.025,\n        // Enhanced DCF parameters\n        normalizedMarginTarget: null, // For margin normalization\n        cyclicalAdjustment: false,\n        industryBeta: 1.0,\n        sizeAdjustment: 0.0, // Small company premium\n        countryRiskPremium: 0.0,\n        liquidityDiscount: 0.0\n      },\n      lbo: {\n        holdingPeriod: 5,\n        debtMultiples: { senior: 4.0, subordinated: 1.5, total: 5.5 },\n        interestRates: { senior: 0.055, subordinated: 0.095 },\n        managementFeeRate: 0.02,\n        carriedInterestRate: 0.2,\n        ebitdaGrowthRate: 0.05,\n        debtPaydownRate: 0.5\n      },\n      monte_carlo: {\n        iterations: 10000,\n        confidenceIntervals: [0.05, 0.25, 0.5, 0.75, 0.95],\n        correlationMatrix: null\n      }\n    };\n  }\n\n  /**\n   * Build comprehensive DCF model with multiple scenarios\n   * @param {Object} inputs - DCF model inputs\n   * @param {Object} scenarios - Different scenario assumptions\n   * @returns {Object} Complete DCF analysis\n   */\n  buildDCFModel(inputs, scenarios = {}) {\n    const {\n      symbol,\n      companyName,\n      currentRevenue,\n      historicalGrowthRates = [],\n      margins = {},\n      balanceSheetData = {},\n      marketData = {},\n      assumptions = {}\n    } = inputs;\n\n    // Merge with default assumptions\n    const modelAssumptions = { ...this.assumptions.dcf, ...assumptions };\n\n    // Build base case scenario\n    const baseCase = this.calculateDCFScenario(inputs, modelAssumptions, 'Base Case');\n\n    // Build additional scenarios\n    const scenarioResults = {};\n\n    // Bull case: Higher growth, lower discount rate\n    if (scenarios.bull !== false) {\n      const bullAssumptions = {\n        ...modelAssumptions,\n        revenueGrowthRate: (modelAssumptions.revenueGrowthRate || 0.1) * 1.3,\n        terminalGrowthRate: Math.min(modelAssumptions.terminalGrowthRate * 1.2, 0.04),\n        wacc: (modelAssumptions.wacc || 0.1) * 0.9\n      };\n      scenarioResults.bull = this.calculateDCFScenario(inputs, bullAssumptions, 'Bull Case');\n    }\n\n    // Bear case: Lower growth, higher discount rate\n    if (scenarios.bear !== false) {\n      const bearAssumptions = {\n        ...modelAssumptions,\n        revenueGrowthRate: (modelAssumptions.revenueGrowthRate || 0.1) * 0.7,\n        terminalGrowthRate: Math.max(modelAssumptions.terminalGrowthRate * 0.8, 0.015),\n        wacc: (modelAssumptions.wacc || 0.1) * 1.1\n      };\n      scenarioResults.bear = this.calculateDCFScenario(inputs, bearAssumptions, 'Bear Case');\n    }\n\n    // Calculate sensitivity analysis\n    const sensitivityAnalysis = this.performDCFSensitivityAnalysis(inputs, modelAssumptions);\n\n    return {\n      symbol,\n      companyName,\n      modelType: 'DCF',\n      timestamp: new Date().toISOString(),\n      baseCase,\n      scenarios: scenarioResults,\n      sensitivityAnalysis,\n      assumptions: modelAssumptions,\n      summary: this.generateDCFSummary(baseCase, scenarioResults, inputs.currentPrice)\n    };\n  }\n\n  /**\n   * Calculate DCF for a specific scenario\n   * @param {Object} inputs - Model inputs\n   * @param {Object} assumptions - Scenario assumptions\n   * @param {string} scenarioName - Name of the scenario\n   * @returns {Object} DCF calculation results\n   */\n  calculateDCFScenario(inputs, assumptions, scenarioName) {\n    const {\n      currentRevenue,\n      currentPrice,\n      sharesOutstanding,\n      totalDebt = 0,\n      cash = 0\n    } = inputs;\n\n    // Project revenues\n    const revenueProjections = this.projectRevenues(\n      currentRevenue,\n      assumptions.revenueGrowthRate || 0.1,\n      assumptions.projectionYears\n    );\n\n    // Project operating metrics\n    const operatingProjections = this.projectOperatingMetrics(\n      revenueProjections,\n      assumptions\n    );\n\n    // Calculate free cash flows\n    const fcfProjections = this.calculateFreeCashFlows(\n      operatingProjections,\n      assumptions\n    );\n\n    // Calculate terminal value\n    const terminalValue = this.calculateTerminalValue(\n      fcfProjections[fcfProjections.length - 1],\n      assumptions.terminalGrowthRate,\n      assumptions.wacc\n    );\n\n    // Calculate present values\n    const pvOfCashFlows = this.calculatePresentValue(fcfProjections, assumptions.wacc);\n    const pvOfTerminalValue = this.calculatePresentValue([terminalValue], assumptions.wacc, assumptions.projectionYears);\n\n    // Calculate enterprise and equity values\n    const enterpriseValue = pvOfCashFlows + pvOfTerminalValue;\n    const equityValue = enterpriseValue - totalDebt + cash;\n    const pricePerShare = equityValue / sharesOutstanding;\n\n    // Calculate valuation metrics\n    const upside = currentPrice ? ((pricePerShare - currentPrice) / currentPrice) * 100 : null;\n\n    return {\n      scenarioName,\n      revenueProjections,\n      operatingProjections,\n      fcfProjections,\n      terminalValue,\n      pvOfCashFlows,\n      pvOfTerminalValue,\n      enterpriseValue,\n      equityValue,\n      pricePerShare,\n      currentPrice,\n      upside,\n      wacc: assumptions.wacc,\n      terminalGrowthRate: assumptions.terminalGrowthRate,\n      impliedMultiples: this.calculateImpliedMultiples(enterpriseValue, operatingProjections)\n    };\n  }\n\n  /**\n   * Project revenue growth over multiple years\n   * @param {number} baseRevenue - Starting revenue\n   * @param {number|Array} growthRates - Growth rate(s)\n   * @param {number} years - Number of years to project\n   * @returns {Array} Revenue projections\n   */\n  projectRevenues(baseRevenue, growthRates, years) {\n    const projections = [];\n    let currentRevenue = baseRevenue;\n\n    for (let i = 0; i < years; i++) {\n      const growthRate = Array.isArray(growthRates)\n        ? growthRates[i] || growthRates[growthRates.length - 1]\n        : growthRates * Math.pow(0.95, i); // Declining growth rate\n\n      currentRevenue *= (1 + growthRate);\n      projections.push({\n        year: i + 1,\n        revenue: currentRevenue,\n        growthRate\n      });\n    }\n\n    return projections;\n  }\n\n  /**\n   * Project operating metrics (EBITDA, margins, etc.)\n   * @param {Array} revenueProjections - Revenue projections\n   * @param {Object} assumptions - Model assumptions\n   * @returns {Array} Operating projections\n   */\n  projectOperatingMetrics(revenueProjections, assumptions) {\n    return revenueProjections.map((projection, index) => {\n      const ebitdaMargin = assumptions.ebitdaMargin || 0.2;\n      const ebitda = projection.revenue * ebitdaMargin;\n      const depreciation = projection.revenue * assumptions.depreciationAsPercentOfRevenue;\n      const ebit = ebitda - depreciation;\n      const taxes = ebit * assumptions.taxRate;\n      const nopat = ebit - taxes;\n\n      return {\n        ...projection,\n        ebitda,\n        ebitdaMargin,\n        depreciation,\n        ebit,\n        taxes,\n        nopat\n      };\n    });\n  }\n\n  /**\n   * Calculate free cash flows with enhanced methodology\n   * @param {Array} operatingProjections - Operating projections\n   * @param {Object} assumptions - Model assumptions\n   * @returns {Array} Free cash flow projections with detailed breakdown\n   */\n  calculateFreeCashFlows(operatingProjections, assumptions) {\n    return operatingProjections.map((projection, index) => {\n      // More sophisticated CapEx modeling\n      const maintenanceCapex = projection.revenue * (assumptions.maintenanceCapexRate || 0.015);\n      const growthCapex = index > 0 ? \n        (projection.revenue - operatingProjections[index - 1].revenue) * (assumptions.growthCapexRate || 0.8) : 0;\n      const totalCapex = maintenanceCapex + growthCapex;\n      \n      // Enhanced working capital calculation\n      const nwcChange = this.calculateWorkingCapitalChange(projection, operatingProjections[index - 1], assumptions);\n      \n      // Add non-cash charges beyond depreciation\n      const stockBasedComp = projection.revenue * (assumptions.stockBasedCompRate || 0.005);\n      const otherNonCash = projection.revenue * (assumptions.otherNonCashRate || 0.001);\n      const totalNonCash = projection.depreciation + stockBasedComp + otherNonCash;\n      \n      // Calculate unlevered FCF\n      const fcf = projection.nopat + totalNonCash - totalCapex - nwcChange;\n      \n      return {\n        year: index + 1,\n        nopat: projection.nopat,\n        depreciation: projection.depreciation,\n        stockBasedComp,\n        otherNonCash,\n        totalNonCash,\n        maintenanceCapex,\n        growthCapex,\n        totalCapex,\n        nwcChange,\n        unleveredFCF: fcf,\n        fcfMargin: projection.revenue > 0 ? fcf / projection.revenue : 0\n      };\n    });\n  }\n  \n  /**\n   * Calculate working capital change with detailed components\n   * @param {Object} currentProjection - Current year projection\n   * @param {Object} priorProjection - Prior year projection\n   * @param {Object} assumptions - Model assumptions\n   * @returns {number} Working capital change\n   */\n  calculateWorkingCapitalChange(currentProjection, priorProjection, assumptions) {\n    if (!priorProjection) {\n      return currentProjection.revenue * assumptions.nwcAsPercentOfRevenue;\n    }\n    \n    // Component-based NWC calculation\n    const receivablesDays = assumptions.receivablesDays || 45;\n    const inventoryDays = assumptions.inventoryDays || 30;\n    const payablesDays = assumptions.payablesDays || 35;\n    \n    const currentReceivables = (currentProjection.revenue * receivablesDays) / 365;\n    const currentInventory = (currentProjection.revenue * inventoryDays) / 365 * (assumptions.cogsPct || 0.6);\n    const currentPayables = (currentProjection.revenue * payablesDays) / 365 * (assumptions.cogsPct || 0.6);\n    const currentNWC = currentReceivables + currentInventory - currentPayables;\n    \n    const priorReceivables = (priorProjection.revenue * receivablesDays) / 365;\n    const priorInventory = (priorProjection.revenue * inventoryDays) / 365 * (assumptions.cogsPct || 0.6);\n    const priorPayables = (priorProjection.revenue * payablesDays) / 365 * (assumptions.cogsPct || 0.6);\n    const priorNWC = priorReceivables + priorInventory - priorPayables;\n    \n    return currentNWC - priorNWC;\n  }\n\n  /**\n   * Calculate terminal value using Gordon Growth Model with validation\n   * @param {number} finalFCF - Final year free cash flow\n   * @param {number} terminalGrowthRate - Terminal growth rate\n   * @param {number} discountRate - Discount rate (WACC)\n   * @param {Object} options - Additional options for terminal value calculation\n   * @returns {number} Terminal value\n   */\n  calculateTerminalValue(finalFCF, terminalGrowthRate, discountRate, options = {}) {\n    // Enhanced validation\n    if (discountRate <= terminalGrowthRate) {\n      throw new Error(`Discount rate (${(discountRate * 100).toFixed(2)}%) must be greater than terminal growth rate (${(terminalGrowthRate * 100).toFixed(2)}%)`);\n    }\n    \n    if (terminalGrowthRate < 0 || terminalGrowthRate > 0.05) {\n      console.warn(`Terminal growth rate ${(terminalGrowthRate * 100).toFixed(2)}% is outside typical range (0-5%)`);\n    }\n    \n    if (finalFCF <= 0) {\n      console.warn('Final year FCF is negative or zero, terminal value calculation may be unreliable');\n    }\n    \n    // Multiple terminal value methods\n    const { method = 'gordon', exitMultiple = null, fadeToGrowth = false } = options;\n    \n    switch (method) {\n      case 'gordon':\n        return (finalFCF * (1 + terminalGrowthRate)) / (discountRate - terminalGrowthRate);\n        \n      case 'exit_multiple':\n        if (exitMultiple && finalFCF > 0) {\n          // Assume FCF approximates EBITDA for multiple calculation\n          return finalFCF * exitMultiple;\n        }\n        return (finalFCF * (1 + terminalGrowthRate)) / (discountRate - terminalGrowthRate);\n        \n      case 'fade_to_growth':\n        // Implement fade-to-growth model where high growth fades to long-term rate\n        const fadeYears = options.fadeYears || 5;\n        const longTermGrowth = options.longTermGrowth || 0.025;\n        let terminalValue = 0;\n        \n        for (let year = 1; year <= fadeYears; year++) {\n          const fadeRate = terminalGrowthRate * Math.pow((fadeYears - year + 1) / fadeYears, 2) + \n                          longTermGrowth * Math.pow(year / fadeYears, 2);\n          const yearFCF = finalFCF * Math.pow(1 + fadeRate, year);\n          terminalValue += yearFCF / Math.pow(1 + discountRate, year);\n        }\n        \n        // Add perpetual value after fade period\n        const finalFadeFCF = finalFCF * Math.pow(1 + longTermGrowth, fadeYears);\n        const perpetualValue = finalFadeFCF / (discountRate - longTermGrowth);\n        terminalValue += perpetualValue / Math.pow(1 + discountRate, fadeYears);\n        \n        return terminalValue;\n        \n      default:\n        return (finalFCF * (1 + terminalGrowthRate)) / (discountRate - terminalGrowthRate);\n    }\n  }\n\n  /**\n   * Calculate present value of cash flows\n   * @param {Array} cashFlows - Array of cash flows\n   * @param {number} discountRate - Discount rate\n   * @param {number} startYear - Starting year for discounting\n   * @returns {number} Present value\n   */\n  calculatePresentValue(cashFlows, discountRate, startYear = 0) {\n    return cashFlows.reduce((pv, cf, index) => {\n      const year = startYear + index + 1;\n      return pv + cf / Math.pow(1 + discountRate, year);\n    }, 0);\n  }\n\n  /**\n   * Calculate comprehensive implied valuation multiples\n   * @param {number} enterpriseValue - Enterprise value\n   * @param {Array} operatingProjections - Operating projections\n   * @param {Array} fcfProjections - Free cash flow projections  \n   * @param {number} currentRevenue - Current year revenue\n   * @returns {Object} Comprehensive implied multiples\n   */\n  calculateImpliedMultiples(enterpriseValue, operatingProjections, fcfProjections = [], currentRevenue = 0) {\n    const currentYearEbitda = operatingProjections[0]?.ebitda || 0;\n    const nextYearEbitda = operatingProjections[1]?.ebitda || 0;\n    const currentYearEbit = operatingProjections[0]?.ebit || 0;\n    const nextYearEbit = operatingProjections[1]?.ebit || 0;\n    const nextYearRevenue = operatingProjections[1]?.revenue || 0;\n    const currentYearFCF = fcfProjections[0]?.unleveredFCF || 0;\n    const nextYearFCF = fcfProjections[1]?.unleveredFCF || 0;\n\n    return {\n      // Revenue multiples\n      evToCurrentRevenue: currentRevenue ? enterpriseValue / currentRevenue : null,\n      evToForwardRevenue: nextYearRevenue ? enterpriseValue / nextYearRevenue : null,\n      \n      // EBITDA multiples\n      evToCurrentEbitda: currentYearEbitda ? enterpriseValue / currentYearEbitda : null,\n      evToForwardEbitda: nextYearEbitda ? enterpriseValue / nextYearEbitda : null,\n      \n      // EBIT multiples\n      evToCurrentEbit: currentYearEbit ? enterpriseValue / currentYearEbit : null,\n      evToForwardEbit: nextYearEbit ? enterpriseValue / nextYearEbit : null,\n      \n      // FCF multiples\n      evToCurrentFCF: currentYearFCF ? enterpriseValue / currentYearFCF : null,\n      evToForwardFCF: nextYearFCF ? enterpriseValue / nextYearFCF : null,\n      \n      // PEG ratio approximation (P/E to Growth)\n      pegRatio: this.calculatePEGRatio(operatingProjections, enterpriseValue)\n    };\n  }\n  \n  /**\n   * Calculate PEG ratio approximation\n   * @param {Array} operatingProjections - Operating projections\n   * @param {number} enterpriseValue - Enterprise value\n   * @returns {number} PEG ratio\n   */\n  calculatePEGRatio(operatingProjections, enterpriseValue) {\n    if (operatingProjections.length < 2) return null;\n    \n    const currentEarnings = operatingProjections[0]?.nopat || 0;\n    const futureEarnings = operatingProjections[operatingProjections.length - 1]?.nopat || 0;\n    \n    if (currentEarnings <= 0 || futureEarnings <= 0) return null;\n    \n    const growthRate = Math.pow(futureEarnings / currentEarnings, 1 / (operatingProjections.length - 1)) - 1;\n    const peRatio = enterpriseValue / currentEarnings;\n    \n    return growthRate > 0 ? peRatio / (growthRate * 100) : null;\n  }\n\n  /**\n   * Perform sensitivity analysis on key variables\n   * @param {Object} inputs - Model inputs\n   * @param {Object} baseAssumptions - Base case assumptions\n   * @returns {Object} Sensitivity analysis results\n   */\n  performDCFSensitivityAnalysis(inputs, baseAssumptions) {\n    const sensitivityVars = {\n      revenueGrowthRate: [-0.02, -0.01, 0, 0.01, 0.02],\n      wacc: [-0.005, -0.0025, 0, 0.0025, 0.005],\n      terminalGrowthRate: [-0.005, -0.0025, 0, 0.0025, 0.005],\n      ebitdaMargin: [-0.02, -0.01, 0, 0.01, 0.02]\n    };\n\n    const results = {};\n\n    Object.entries(sensitivityVars).forEach(([variable, variations]) => {\n      results[variable] = variations.map(variation => {\n        const adjustedAssumptions = {\n          ...baseAssumptions,\n          [variable]: (baseAssumptions[variable] || 0) + variation\n        };\n\n        try {\n          const scenario = this.calculateDCFScenario(inputs, adjustedAssumptions, `${variable}_${variation}`);\n          return {\n            variation,\n            pricePerShare: scenario.pricePerShare,\n            upside: scenario.upside\n          };\n        } catch (error) {\n          return {\n            variation,\n            pricePerShare: null,\n            upside: null,\n            error: error.message\n          };\n        }\n      });\n    });\n\n    return results;\n  }\n\n  /**\n   * Generate DCF model summary\n   * @param {Object} baseCase - Base case results\n   * @param {Object} scenarios - Scenario results\n   * @param {number} currentPrice - Current stock price\n   * @returns {Object} Model summary\n   */\n  generateDCFSummary(baseCase, scenarios, currentPrice) {\n    const allScenarios = [baseCase, ...Object.values(scenarios)];\n    const pricesPerShare = allScenarios.map(s => s.pricePerShare).filter(p => p !== null);\n\n    return {\n      priceRange: {\n        min: Math.min(...pricesPerShare),\n        max: Math.max(...pricesPerShare),\n        average: pricesPerShare.reduce((sum, p) => sum + p, 0) / pricesPerShare.length\n      },\n      recommendation: this.generateRecommendation(baseCase, currentPrice),\n      keyMetrics: {\n        baseCase: {\n          pricePerShare: baseCase.pricePerShare,\n          upside: baseCase.upside,\n          enterpriseValue: baseCase.enterpriseValue\n        },\n        currentPrice,\n        impliedReturn: baseCase.upside\n      }\n    };\n  }\n\n  /**\n   * Generate investment recommendation\n   * @param {Object} baseCase - Base case DCF results\n   * @param {number} currentPrice - Current stock price\n   * @returns {Object} Investment recommendation\n   */\n  generateRecommendation(baseCase, currentPrice) {\n    if (!currentPrice || !baseCase.pricePerShare) {\n      return { rating: 'INSUFFICIENT_DATA', confidence: 0 };\n    }\n\n    const upside = baseCase.upside;\n    let rating, confidence;\n\n    if (upside > 20) {\n      rating = 'STRONG_BUY';\n      confidence = Math.min(95, 70 + (upside - 20) * 1.25);\n    } else if (upside > 10) {\n      rating = 'BUY';\n      confidence = Math.min(85, 60 + (upside - 10) * 2);\n    } else if (upside > -10) {\n      rating = 'HOLD';\n      confidence = Math.min(75, 50 + Math.abs(upside) * 2.5);\n    } else if (upside > -20) {\n      rating = 'SELL';\n      confidence = Math.min(85, 60 + Math.abs(upside + 10) * 2);\n    } else {\n      rating = 'STRONG_SELL';\n      confidence = Math.min(95, 70 + Math.abs(upside + 20) * 1.25);\n    }\n\n    return {\n      rating,\n      confidence: Math.round(confidence),\n      upside,\n      reasoning: this.generateRecommendationReasoning(rating, upside)\n    };\n  }\n\n  /**\n   * Generate reasoning for investment recommendation\n   * @param {string} rating - Investment rating\n   * @param {number} upside - Upside percentage\n   * @returns {string} Recommendation reasoning\n   */\n  generateRecommendationReasoning(rating, upside) {\n    const upsideAbs = Math.abs(upside);\n\n    switch (rating) {\n      case 'STRONG_BUY':\n        return `Strong upside potential of ${upside.toFixed(1)}% suggests significant undervaluation based on DCF analysis.`;\n      case 'BUY':\n        return `Moderate upside of ${upside.toFixed(1)}% indicates the stock is undervalued relative to intrinsic value.`;\n      case 'HOLD':\n        return `Fair valuation with ${upside >= 0 ? 'limited upside' : 'modest downside'} of ${upsideAbs.toFixed(1)}%.`;\n      case 'SELL':\n        return `Downside risk of ${upsideAbs.toFixed(1)}% suggests the stock is overvalued based on fundamental analysis.`;\n      case 'STRONG_SELL':\n        return `Significant downside of ${upsideAbs.toFixed(1)}% indicates substantial overvaluation.`;\n      default:\n        return 'Insufficient data for reliable recommendation.';\n    }\n  }\n}\n\n// Export singleton instance\nexport const financialModelingEngine = new FinancialModelingEngine();\nexport default FinancialModelingEngine;\n","import { apiLogger } from '../utils/apiLogger.js';\n\n/**\n * Advanced LBO (Leveraged Buyout) Modeling Engine\n * Provides comprehensive LBO analysis with debt schedules and cash flow waterfalls\n */\nclass LBOModelingEngine {\n  constructor() {\n    this.modelCache = new Map();\n    this.assumptions = this.getDefaultAssumptions();\n  }\n\n  /**\n   * Get default LBO modeling assumptions\n   */\n  getDefaultAssumptions() {\n    return {\n      transaction: {\n        holdingPeriod: 5,\n        managementRollover: 0.1, // 10% management rollover\n        transactionFees: 0.02, // 2% of transaction value\n        financingFees: 0.015 // 1.5% of debt\n      },\n      debt: {\n        seniorDebtMultiple: 4.0,\n        subordinatedDebtMultiple: 1.5,\n        totalDebtMultiple: 5.5,\n        seniorInterestRate: 0.055, // 5.5%\n        subordinatedInterestRate: 0.095, // 9.5%\n        mandatoryPaydown: 0.05, // 5% annually\n        cashSweep: 0.5 // 50% of excess cash\n      },\n      operating: {\n        ebitdaGrowthRate: 0.05, // 5% annually\n        capexAsPercentOfRevenue: 0.03,\n        nwcAsPercentOfRevenue: 0.02,\n        taxRate: 0.21\n      },\n      exit: {\n        exitMultiple: null, // Will use peer average\n        exitMultipleRange: [0.8, 1.2], // 80% to 120% of peer average\n        publicMarketDiscount: 0.1 // 10% discount for public exit\n      },\n      fees: {\n        managementFeeRate: 0.02, // 2% annually\n        carriedInterestRate: 0.2, // 20%\n        hurdle: 0.08 // 8% preferred return\n      }\n    };\n  }\n\n  /**\n   * Build comprehensive LBO model\n   * @param {Object} inputs - LBO model inputs\n   * @param {Object} scenarios - Different scenario assumptions\n   * @returns {Object} Complete LBO analysis\n   */\n  buildLBOModel(inputs, scenarios = {}) {\n    const {\n      symbol,\n      companyName,\n      purchasePrice,\n      ebitda,\n      revenue,\n      marketData = {},\n      peerData = {},\n      assumptions = {}\n    } = inputs;\n\n    // Merge with default assumptions\n    const modelAssumptions = { ...this.assumptions, ...assumptions };\n\n    // Calculate transaction structure\n    const transactionStructure = this.calculateTransactionStructure(\n      purchasePrice,\n      ebitda,\n      modelAssumptions\n    );\n\n    // Build base case scenario\n    const baseCase = this.calculateLBOScenario(\n      inputs,\n      transactionStructure,\n      modelAssumptions,\n      'Base Case'\n    );\n\n    // Build additional scenarios\n    const scenarioResults = {};\n\n    // Upside case: Higher growth and exit multiple\n    if (scenarios.upside !== false) {\n      const upsideAssumptions = {\n        ...modelAssumptions,\n        operating: {\n          ...modelAssumptions.operating,\n          ebitdaGrowthRate: modelAssumptions.operating.ebitdaGrowthRate * 1.3\n        },\n        exit: {\n          ...modelAssumptions.exit,\n          exitMultiple: (modelAssumptions.exit.exitMultiple || 10) * 1.1\n        }\n      };\n      scenarioResults.upside = this.calculateLBOScenario(\n        inputs,\n        transactionStructure,\n        upsideAssumptions,\n        'Upside Case'\n      );\n    }\n\n    // Downside case: Lower growth and exit multiple\n    if (scenarios.downside !== false) {\n      const downsideAssumptions = {\n        ...modelAssumptions,\n        operating: {\n          ...modelAssumptions.operating,\n          ebitdaGrowthRate: modelAssumptions.operating.ebitdaGrowthRate * 0.7\n        },\n        exit: {\n          ...modelAssumptions.exit,\n          exitMultiple: (modelAssumptions.exit.exitMultiple || 10) * 0.9\n        }\n      };\n      scenarioResults.downside = this.calculateLBOScenario(\n        inputs,\n        transactionStructure,\n        downsideAssumptions,\n        'Downside Case'\n      );\n    }\n\n    // Calculate sensitivity analysis\n    const sensitivityAnalysis = this.performLBOSensitivityAnalysis(\n      inputs,\n      transactionStructure,\n      modelAssumptions\n    );\n\n    return {\n      symbol,\n      companyName,\n      modelType: 'LBO',\n      timestamp: new Date().toISOString(),\n      transactionStructure,\n      baseCase,\n      scenarios: scenarioResults,\n      sensitivityAnalysis,\n      assumptions: modelAssumptions,\n      summary: this.generateLBOSummary(baseCase, scenarioResults, transactionStructure)\n    };\n  }\n\n  /**\n   * Calculate transaction structure and financing\n   * @param {number} purchasePrice - Total purchase price\n   * @param {number} ebitda - Current EBITDA\n   * @param {Object} assumptions - Model assumptions\n   * @returns {Object} Transaction structure\n   */\n  calculateTransactionStructure(purchasePrice, ebitda, assumptions) {\n    const { debt, transaction } = assumptions;\n\n    // Calculate debt capacity based on EBITDA multiples\n    const seniorDebt = ebitda * debt.seniorDebtMultiple;\n    const subordinatedDebt = ebitda * debt.subordinatedDebtMultiple;\n    const totalDebt = seniorDebt + subordinatedDebt;\n\n    // Calculate transaction costs\n    const transactionFees = purchasePrice * transaction.transactionFees;\n    const financingFees = totalDebt * transaction.financingFees;\n    const totalUses = purchasePrice + transactionFees + financingFees;\n\n    // Calculate equity requirement (ensure it's positive)\n    const equityContribution = Math.max(totalUses - totalDebt, totalUses * 0.2); // Minimum 20% equity\n    const managementRollover = purchasePrice * transaction.managementRollover;\n    const sponsorEquity = Math.max(equityContribution - managementRollover, 0);\n\n    // Recalculate total debt if equity was adjusted\n    const adjustedTotalDebt = totalUses - equityContribution;\n    const adjustedSeniorDebt = Math.min(seniorDebt, adjustedTotalDebt * 0.8); // Max 80% senior\n    const adjustedSubordinatedDebt = adjustedTotalDebt - adjustedSeniorDebt;\n\n    return {\n      purchasePrice,\n      transactionFees,\n      financingFees,\n      totalUses,\n      seniorDebt: adjustedSeniorDebt,\n      subordinatedDebt: adjustedSubordinatedDebt,\n      totalDebt: adjustedTotalDebt,\n      equityContribution,\n      sponsorEquity,\n      managementRollover,\n      debtToEbitda: adjustedTotalDebt / ebitda,\n      equityToTotalCapital: equityContribution / totalUses\n    };\n  }\n\n  /**\n   * Calculate LBO scenario with detailed cash flow projections\n   * @param {Object} inputs - Model inputs\n   * @param {Object} transactionStructure - Transaction structure\n   * @param {Object} assumptions - Scenario assumptions\n   * @param {string} scenarioName - Name of the scenario\n   * @returns {Object} LBO scenario results\n   */\n  calculateLBOScenario(inputs, transactionStructure, assumptions, scenarioName) {\n    const { ebitda, revenue } = inputs;\n    const { holdingPeriod } = assumptions.transaction;\n\n    // Project operating performance\n    const operatingProjections = this.projectLBOOperatingPerformance(\n      revenue,\n      ebitda,\n      assumptions.operating,\n      holdingPeriod\n    );\n\n    // Calculate debt schedule\n    const debtSchedule = this.calculateDebtSchedule(\n      transactionStructure,\n      operatingProjections,\n      assumptions.debt,\n      holdingPeriod\n    );\n\n    // Calculate cash flow to equity\n    const equityCashFlows = this.calculateEquityCashFlows(\n      operatingProjections,\n      debtSchedule,\n      assumptions\n    );\n\n    // Calculate exit value and returns\n    const exitAnalysis = this.calculateExitAnalysis(\n      operatingProjections[holdingPeriod - 1],\n      debtSchedule[holdingPeriod - 1],\n      transactionStructure,\n      assumptions\n    );\n\n    // Calculate returns metrics\n    const returnsAnalysis = this.calculateReturnsMetrics(\n      transactionStructure.sponsorEquity,\n      equityCashFlows,\n      exitAnalysis.netProceeds,\n      holdingPeriod\n    );\n\n    return {\n      scenarioName,\n      operatingProjections,\n      debtSchedule,\n      equityCashFlows,\n      exitAnalysis,\n      returnsAnalysis,\n      keyMetrics: this.calculateLBOKeyMetrics(\n        transactionStructure,\n        exitAnalysis,\n        returnsAnalysis\n      )\n    };\n  }\n\n  /**\n   * Project operating performance over holding period\n   * @param {number} baseRevenue - Starting revenue\n   * @param {number} baseEbitda - Starting EBITDA\n   * @param {Object} operatingAssumptions - Operating assumptions\n   * @param {number} years - Number of years\n   * @returns {Array} Operating projections\n   */\n  projectLBOOperatingPerformance(baseRevenue, baseEbitda, operatingAssumptions, years) {\n    const projections = [];\n    let currentRevenue = baseRevenue;\n    let currentEbitda = baseEbitda;\n\n    for (let year = 1; year <= years; year++) {\n      // Assume revenue grows in line with EBITDA\n      const ebitdaGrowth = operatingAssumptions.ebitdaGrowthRate;\n      currentEbitda *= (1 + ebitdaGrowth);\n      currentRevenue *= (1 + ebitdaGrowth);\n\n      const ebitdaMargin = currentEbitda / currentRevenue;\n      const capex = currentRevenue * operatingAssumptions.capexAsPercentOfRevenue;\n      const nwcChange = year === 1\n        ? currentRevenue * operatingAssumptions.nwcAsPercentOfRevenue\n        : (currentRevenue - projections[year - 2].revenue) * operatingAssumptions.nwcAsPercentOfRevenue;\n\n      const taxes = currentEbitda * operatingAssumptions.taxRate;\n      const unleveredFCF = currentEbitda - taxes - capex - nwcChange;\n\n      projections.push({\n        year,\n        revenue: currentRevenue,\n        ebitda: currentEbitda,\n        ebitdaMargin,\n        capex,\n        nwcChange,\n        taxes,\n        unleveredFCF\n      });\n    }\n\n    return projections;\n  }\n\n  /**\n   * Calculate enhanced debt schedule with detailed amortization and covenants\n   * @param {Object} transactionStructure - Transaction structure\n   * @param {Array} operatingProjections - Operating projections\n   * @param {Object} debtAssumptions - Debt assumptions\n   * @param {number} years - Number of years\n   * @returns {Array} Enhanced debt schedule with covenant testing\n   */\n  calculateDebtSchedule(transactionStructure, operatingProjections, debtAssumptions, years) {\n    const schedule = [];\n    let seniorDebtBalance = transactionStructure.seniorDebt;\n    let subordinatedDebtBalance = transactionStructure.subordinatedDebt;\n    let revolvingDebtBalance = transactionStructure.revolvingDebt || 0;\n    \n    // Enhanced debt assumptions\n    const enhancedAssumptions = {\n      ...debtAssumptions,\n      revolvingRate: debtAssumptions.revolvingRate || 0.045,\n      minCashBalance: debtAssumptions.minCashBalance || 10000000,\n      // Covenant parameters\n      maxLeverageRatio: debtAssumptions.maxLeverageRatio || 6.0,\n      minCoverageRatio: debtAssumptions.minCoverageRatio || 1.25,\n      maxCapexRatio: debtAssumptions.maxCapexRatio || 0.05\n    };\n\n    for (let year = 1; year <= years; year++) {\n      const projection = operatingProjections[year - 1];\n\n      // Calculate interest expense\n      const seniorInterest = seniorDebtBalance * debtAssumptions.seniorInterestRate;\n      const subordinatedInterest = subordinatedDebtBalance * debtAssumptions.subordinatedInterestRate;\n      const totalInterest = seniorInterest + subordinatedInterest;\n\n      // Calculate available cash for debt paydown\n      const cashAvailableForDebt = projection.unleveredFCF - totalInterest;\n\n      // Mandatory amortization\n      const mandatoryPaydown = Math.min(\n        seniorDebtBalance * debtAssumptions.mandatoryPaydown,\n        seniorDebtBalance\n      );\n\n      // Cash sweep (excess cash after mandatory paydown)\n      const excessCash = Math.max(0, cashAvailableForDebt - mandatoryPaydown);\n      const cashSweep = excessCash * debtAssumptions.cashSweep;\n\n      // Total debt paydown\n      const totalPaydown = mandatoryPaydown + cashSweep;\n      const seniorPaydown = Math.min(totalPaydown, seniorDebtBalance);\n      const subordinatedPaydown = Math.max(0, totalPaydown - seniorPaydown);\n\n      // Update balances\n      seniorDebtBalance = Math.max(0, seniorDebtBalance - seniorPaydown);\n      subordinatedDebtBalance = Math.max(0, subordinatedDebtBalance - subordinatedPaydown);\n\n      // Enhanced debt covenant testing\n      const leverageRatio = (seniorDebtBalance + subordinatedDebtBalance + revolvingDebtBalance) / projection.ebitda;\n      const coverageRatio = projection.ebitda / totalInterest;\n      const capexRatio = (projection.capex || 0) / projection.revenue;\n      \n      const covenantTests = {\n        leverageCompliance: leverageRatio <= enhancedAssumptions.maxLeverageRatio,\n        coverageCompliance: coverageRatio >= enhancedAssumptions.minCoverageRatio,\n        capexCompliance: capexRatio <= enhancedAssumptions.maxCapexRatio,\n        leverageRatio,\n        coverageRatio,\n        capexRatio\n      };\n      \n      // Calculate debt service coverage ratio (DSCR)\n      const dscr = cashAvailableForDebt / (totalInterest + mandatoryPaydown);\n      \n      schedule.push({\n        year,\n        beginningBalance: {\n          senior: year === 1 ? transactionStructure.seniorDebt : schedule[year - 2].endingBalance.senior,\n          subordinated: year === 1 ? transactionStructure.subordinatedDebt : schedule[year - 2].endingBalance.subordinated,\n          revolving: year === 1 ? (transactionStructure.revolvingDebt || 0) : schedule[year - 2].endingBalance.revolving\n        },\n        interestExpense: {\n          senior: seniorInterest,\n          subordinated: subordinatedInterest,\n          revolving: revolvingDebtBalance * enhancedAssumptions.revolvingRate,\n          total: totalInterest + (revolvingDebtBalance * enhancedAssumptions.revolvingRate)\n        },\n        principalPayment: {\n          senior: seniorPaydown,\n          subordinated: subordinatedPaydown,\n          revolving: 0, // Revolving debt typically doesn't amortize\n          total: totalPaydown\n        },\n        endingBalance: {\n          senior: seniorDebtBalance,\n          subordinated: subordinatedDebtBalance,\n          revolving: revolvingDebtBalance,\n          total: seniorDebtBalance + subordinatedDebtBalance + revolvingDebtBalance\n        },\n        cashAvailableForDebt,\n        excessCash: excessCash - cashSweep,\n        mandatoryPaydown,\n        cashSweep,\n        dscr,\n        covenantTests,\n        // Additional debt metrics\n        netDebtToEbitda: (seniorDebtBalance + subordinatedDebtBalance + revolvingDebtBalance) / projection.ebitda,\n        ebitdaToInterest: projection.ebitda / totalInterest\n      });\n    }\n\n    return schedule;\n  }\n\n  /**\n   * Calculate cash flows to equity holders\n   * @param {Array} operatingProjections - Operating projections\n   * @param {Array} debtSchedule - Debt schedule\n   * @param {Object} assumptions - Model assumptions\n   * @returns {Array} Equity cash flows\n   */\n  calculateEquityCashFlows(operatingProjections, debtSchedule, assumptions) {\n    return operatingProjections.map((projection, index) => {\n      const debt = debtSchedule[index];\n      const managementFees = assumptions.fees.managementFeeRate *\n        (assumptions.transaction.sponsorEquity || 0);\n\n      const cashFlowToEquity = debt.excessCash - managementFees;\n\n      return {\n        year: projection.year,\n        unleveredFCF: projection.unleveredFCF,\n        interestExpense: debt.interestExpense.total,\n        principalPayment: debt.principalPayment.total,\n        managementFees,\n        cashFlowToEquity: Math.max(0, cashFlowToEquity)\n      };\n    });\n  }\n\n  /**\n   * Calculate exit analysis and proceeds\n   * @param {Object} finalYearProjection - Final year operating projection\n   * @param {Object} finalYearDebt - Final year debt schedule\n   * @param {Object} transactionStructure - Transaction structure\n   * @param {Object} assumptions - Model assumptions\n   * @returns {Object} Exit analysis\n   */\n  calculateExitAnalysis(finalYearProjection, finalYearDebt, transactionStructure, assumptions) {\n    const exitMultiple = assumptions.exit.exitMultiple || 10;\n    const exitEbitda = finalYearProjection.ebitda;\n\n    const enterpriseValue = exitEbitda * exitMultiple;\n    const totalDebtAtExit = finalYearDebt.endingBalance.total;\n    const grossProceeds = enterpriseValue - totalDebtAtExit;\n\n    // Calculate carried interest\n    const totalReturn = grossProceeds;\n    const investedCapital = transactionStructure.sponsorEquity;\n    const profit = Math.max(0, totalReturn - investedCapital);\n    const carriedInterest = profit * assumptions.fees.carriedInterestRate;\n\n    const netProceeds = grossProceeds - carriedInterest;\n\n    return {\n      exitEbitda,\n      exitMultiple,\n      enterpriseValue,\n      totalDebtAtExit,\n      grossProceeds,\n      carriedInterest,\n      netProceeds,\n      managementProceeds: grossProceeds * (transactionStructure.managementRollover / transactionStructure.equityContribution)\n    };\n  }\n\n  /**\n   * Calculate returns metrics (IRR, MOIC, etc.)\n   * @param {number} initialInvestment - Initial equity investment\n   * @param {Array} equityCashFlows - Annual equity cash flows\n   * @param {number} exitProceeds - Exit proceeds\n   * @param {number} holdingPeriod - Holding period in years\n   * @returns {Object} Returns analysis\n   */\n  calculateReturnsMetrics(initialInvestment, equityCashFlows, exitProceeds, holdingPeriod) {\n    // Validate inputs\n    if (!initialInvestment || initialInvestment <= 0) {\n      return {\n        irr: NaN,\n        moic: NaN,\n        totalCashReturned: 0,\n        initialInvestment: initialInvestment || 0,\n        holdingPeriod,\n        annualizedReturn: NaN\n      };\n    }\n\n    // Calculate total cash flows (negative initial investment, positive distributions and exit)\n    const cashFlows = [-Math.abs(initialInvestment)]; // Ensure initial investment is negative\n\n    // Add annual cash flows\n    equityCashFlows.forEach(cf => {\n      cashFlows.push(cf.cashFlowToEquity || 0);\n    });\n\n    // Add exit proceeds to final year\n    if (cashFlows.length > 1) {\n      cashFlows[cashFlows.length - 1] += (exitProceeds || 0);\n    } else {\n      cashFlows.push(exitProceeds || 0);\n    }\n\n    // Calculate IRR using Newton-Raphson method\n    const irr = this.calculateIRR(cashFlows);\n\n    // Calculate MOIC (Multiple of Invested Capital)\n    const totalCashReturned = equityCashFlows.reduce((sum, cf) => sum + (cf.cashFlowToEquity || 0), 0) + (exitProceeds || 0);\n    const moic = totalCashReturned / Math.abs(initialInvestment);\n\n    return {\n      irr: isNaN(irr) ? 0 : irr, // Default to 0% if IRR calculation fails\n      moic: isNaN(moic) ? 0 : moic,\n      totalCashReturned,\n      initialInvestment: Math.abs(initialInvestment),\n      holdingPeriod,\n      annualizedReturn: isNaN(moic) || moic <= 0 ? 0 : Math.pow(moic, 1 / holdingPeriod) - 1,\n      cashFlows // Include for debugging\n    };\n  }\n\n  /**\n   * Calculate IRR using enhanced Newton-Raphson method with multiple fallbacks\n   * @param {Array} cashFlows - Array of cash flows\n   * @param {Object} options - Calculation options\n   * @returns {number} IRR as decimal\n   */\n  calculateIRR(cashFlows, options = {}) {\n    // Validate cash flows\n    if (!cashFlows || cashFlows.length < 2) {\n      return NaN;\n    }\n\n    // Check if all cash flows are zero\n    if (cashFlows.every(cf => cf === 0)) {\n      return 0;\n    }\n\n    // Check if there's no sign change (no valid IRR)\n    const signChanges = cashFlows.slice(1).reduce((count, cf, i) => {\n      return count + (Math.sign(cf) !== Math.sign(cashFlows[i]) ? 1 : 0);\n    }, 0);\n\n    if (signChanges === 0) {\n      return cashFlows[0] < 0 ? -1 : Infinity; // No valid IRR\n    }\n\n    const { tolerance = 1e-8, maxIterations = 200, initialGuess = 0.1 } = options;\n    \n    // Try Newton-Raphson method first\n    let rate = this.newtonRaphsonIRR(cashFlows, initialGuess, tolerance, maxIterations);\n    \n    // If Newton-Raphson fails, try bisection method\n    if (isNaN(rate) || !isFinite(rate)) {\n      rate = this.bisectionIRR(cashFlows, tolerance, maxIterations);\n    }\n    \n    // If both fail, try Secant method\n    if (isNaN(rate) || !isFinite(rate)) {\n      rate = this.secantIRR(cashFlows, tolerance, maxIterations);\n    }\n\n    return rate;\n  }\n  \n  /**\n   * Newton-Raphson method for IRR calculation\n   */\n  newtonRaphsonIRR(cashFlows, initialGuess, tolerance, maxIterations) {\n    let rate = initialGuess;\n\n    for (let i = 0; i < maxIterations; i++) {\n      let npv = 0;\n      let dnpv = 0;\n\n      for (let j = 0; j < cashFlows.length; j++) {\n        const factor = Math.pow(1 + rate, j);\n        npv += cashFlows[j] / factor;\n        if (j > 0) {\n          dnpv -= j * cashFlows[j] / (factor * (1 + rate));\n        }\n      }\n\n      if (Math.abs(npv) < tolerance) {\n        return rate;\n      }\n\n      if (Math.abs(dnpv) < tolerance) {\n        break; // Avoid division by zero\n      }\n\n      const newRate = rate - npv / dnpv;\n\n      // Prevent rate from going too negative or too high\n      if (newRate < -0.99) {\n        rate = -0.99;\n      } else if (newRate > 50) {\n        rate = 50;\n      } else {\n        rate = newRate;\n      }\n      \n      // Check for convergence\n      if (Math.abs(newRate - rate) < tolerance) {\n        return newRate;\n      }\n      \n      rate = newRate;\n    }\n\n    return rate;\n  }\n  \n  /**\n   * Bisection method for IRR calculation (fallback)\n   */\n  bisectionIRR(cashFlows, tolerance, maxIterations) {\n    let low = -0.99;\n    let high = 5.0;\n    \n    // Check if bounds contain a root\n    const npvLow = this.calculateNPV(cashFlows, low);\n    const npvHigh = this.calculateNPV(cashFlows, high);\n    \n    if (npvLow * npvHigh > 0) {\n      return NaN; // No root in bounds\n    }\n    \n    for (let i = 0; i < maxIterations; i++) {\n      const mid = (low + high) / 2;\n      const npvMid = this.calculateNPV(cashFlows, mid);\n      \n      if (Math.abs(npvMid) < tolerance) {\n        return mid;\n      }\n      \n      if (npvLow * npvMid < 0) {\n        high = mid;\n      } else {\n        low = mid;\n      }\n      \n      if (Math.abs(high - low) < tolerance) {\n        return (low + high) / 2;\n      }\n    }\n    \n    return (low + high) / 2;\n  }\n  \n  /**\n   * Secant method for IRR calculation (second fallback)\n   */\n  secantIRR(cashFlows, tolerance, maxIterations) {\n    let x0 = 0;\n    let x1 = 0.1;\n    \n    for (let i = 0; i < maxIterations; i++) {\n      const f0 = this.calculateNPV(cashFlows, x0);\n      const f1 = this.calculateNPV(cashFlows, x1);\n      \n      if (Math.abs(f1) < tolerance) {\n        return x1;\n      }\n      \n      if (Math.abs(f1 - f0) < tolerance) {\n        break;\n      }\n      \n      const x2 = x1 - f1 * (x1 - x0) / (f1 - f0);\n      \n      if (Math.abs(x2 - x1) < tolerance) {\n        return x2;\n      }\n      \n      x0 = x1;\n      x1 = x2;\n    }\n    \n    return x1;\n  }\n  \n  /**\n   * Calculate NPV for a given discount rate\n   */\n  calculateNPV(cashFlows, rate) {\n    return cashFlows.reduce((npv, cf, index) => {\n      return npv + cf / Math.pow(1 + rate, index);\n    }, 0);\n  }\n\n  /**\n   * Calculate comprehensive LBO metrics summary with advanced ratios\n   * @param {Object} transactionStructure - Transaction structure\n   * @param {Object} exitAnalysis - Exit analysis\n   * @param {Object} returnsAnalysis - Returns analysis\n   * @param {Array} debtSchedule - Debt schedule for additional metrics\n   * @returns {Object} Comprehensive key metrics\n   */\n  calculateLBOKeyMetrics(transactionStructure, exitAnalysis, returnsAnalysis, debtSchedule = []) {\n    // Calculate entry EBITDA multiple\n    const impliedEntryEbitda = transactionStructure.purchasePrice / (transactionStructure.entryMultiple || 10);\n    const actualEntryMultiple = impliedEntryEbitda > 0 ? transactionStructure.purchasePrice / impliedEntryEbitda : null;\n    \n    // Calculate leverage metrics\n    const peakLeverage = Math.max(...debtSchedule.map(d => d.netDebtToEbitda || 0));\n    const minCoverage = Math.min(...debtSchedule.map(d => d.ebitdaToInterest || Infinity));\n    const avgDSCR = debtSchedule.length > 0 ? \n      debtSchedule.reduce((sum, d) => sum + (d.dscr || 0), 0) / debtSchedule.length : 0;\n    \n    // Calculate multiple arbitrage components\n    const multipleExpansion = exitAnalysis.exitMultiple - (actualEntryMultiple || 10);\n    const operationalImprovement = returnsAnalysis.moic - 1 - multipleExpansion;\n    const leverage = transactionStructure.totalDebt / transactionStructure.equityContribution;\n    \n    return {\n      // Entry metrics\n      entryMultiple: actualEntryMultiple,\n      entryLeverage: transactionStructure.debtToEbitda,\n      equityContribution: transactionStructure.equityContribution,\n      debtToEquity: leverage,\n      \n      // Exit metrics\n      exitMultiple: exitAnalysis.exitMultiple,\n      exitLeverage: exitAnalysis.totalDebtAtExit / exitAnalysis.exitEbitda,\n      \n      // Returns metrics\n      irr: returnsAnalysis.irr,\n      moic: returnsAnalysis.moic,\n      totalReturn: returnsAnalysis.totalCashReturned,\n      \n      // Leverage and credit metrics\n      leverageReduction: transactionStructure.totalDebt - exitAnalysis.totalDebtAtExit,\n      peakLeverage,\n      minCoverage,\n      avgDSCR,\n      \n      // Value creation analysis\n      multipleExpansion,\n      operationalImprovement,\n      leverageContribution: leverage > 1 ? (returnsAnalysis.moic - 1) * (leverage - 1) / leverage : 0,\n      \n      // Risk metrics\n      breakdownLeverage: debtSchedule.length > 0 ? \n        Math.max(...debtSchedule.map(d => d.leverageRatio || 0)) : null,\n      covenantBreaches: debtSchedule.filter(d => \n        d.covenantTests && (!d.covenantTests.leverageCompliance || !d.covenantTests.coverageCompliance)\n      ).length,\n      \n      // Efficiency ratios\n      equityEfficiency: returnsAnalysis.totalCashReturned / transactionStructure.equityContribution,\n      timeToRecoverEquity: this.calculateTimeToRecoverEquity(returnsAnalysis.cashFlows, transactionStructure.equityContribution)\n    };\n  }\n  \n  /**\n   * Calculate time to recover initial equity investment\n   * @param {Array} cashFlows - Array of cash flows\n   * @param {number} initialEquity - Initial equity investment\n   * @returns {number} Years to recover equity\n   */\n  calculateTimeToRecoverEquity(cashFlows, initialEquity) {\n    if (!cashFlows || cashFlows.length === 0) return null;\n    \n    let cumulativeCashFlow = 0;\n    \n    for (let i = 1; i < cashFlows.length; i++) { // Skip initial investment\n      cumulativeCashFlow += cashFlows[i];\n      if (cumulativeCashFlow >= initialEquity) {\n        return i;\n      }\n    }\n    \n    return null; // Equity not recovered within holding period\n  }\n\n  /**\n   * Perform sensitivity analysis on key LBO variables\n   * @param {Object} inputs - Model inputs\n   * @param {Object} transactionStructure - Transaction structure\n   * @param {Object} baseAssumptions - Base case assumptions\n   * @returns {Object} Sensitivity analysis results\n   */\n  performLBOSensitivityAnalysis(inputs, transactionStructure, baseAssumptions) {\n    const sensitivityVars = {\n      ebitdaGrowthRate: [-0.02, -0.01, 0, 0.01, 0.02],\n      exitMultiple: [-1, -0.5, 0, 0.5, 1],\n      debtMultiple: [-0.5, -0.25, 0, 0.25, 0.5]\n    };\n\n    const results = {};\n\n    Object.entries(sensitivityVars).forEach(([variable, variations]) => {\n      results[variable] = variations.map(variation => {\n        const adjustedAssumptions = { ...baseAssumptions };\n\n        if (variable === 'ebitdaGrowthRate') {\n          adjustedAssumptions.operating.ebitdaGrowthRate += variation;\n        } else if (variable === 'exitMultiple') {\n          adjustedAssumptions.exit.exitMultiple = (adjustedAssumptions.exit.exitMultiple || 10) + variation;\n        } else if (variable === 'debtMultiple') {\n          // Adjust transaction structure for debt multiple sensitivity\n          const newDebtMultiple = transactionStructure.debtToEbitda + variation;\n          const adjustedStructure = {\n            ...transactionStructure,\n            totalDebt: (inputs.ebitda * newDebtMultiple),\n            debtToEbitda: newDebtMultiple\n          };\n          adjustedStructure.equityContribution = transactionStructure.totalUses - adjustedStructure.totalDebt;\n        }\n\n        try {\n          const scenario = this.calculateLBOScenario(inputs, transactionStructure, adjustedAssumptions, `${variable}_${variation}`);\n          return {\n            variation,\n            irr: scenario.returnsAnalysis.irr,\n            moic: scenario.returnsAnalysis.moic\n          };\n        } catch (error) {\n          return {\n            variation,\n            irr: null,\n            moic: null,\n            error: error.message\n          };\n        }\n      });\n    });\n\n    return results;\n  }\n\n  /**\n   * Generate LBO model summary\n   * @param {Object} baseCase - Base case results\n   * @param {Object} scenarios - Scenario results\n   * @param {Object} transactionStructure - Transaction structure\n   * @returns {Object} Model summary\n   */\n  generateLBOSummary(baseCase, scenarios, transactionStructure) {\n    const allScenarios = [baseCase, ...Object.values(scenarios)];\n    const irrs = allScenarios.map(s => s.returnsAnalysis.irr).filter(irr => irr !== null);\n    const moics = allScenarios.map(s => s.returnsAnalysis.moic).filter(moic => moic !== null);\n\n    return {\n      returnRange: {\n        irrMin: Math.min(...irrs),\n        irrMax: Math.max(...irrs),\n        irrAverage: irrs.reduce((sum, irr) => sum + irr, 0) / irrs.length,\n        moicMin: Math.min(...moics),\n        moicMax: Math.max(...moics),\n        moicAverage: moics.reduce((sum, moic) => sum + moic, 0) / moics.length\n      },\n      investmentHighlights: this.generateInvestmentHighlights(baseCase, transactionStructure),\n      riskFactors: this.generateRiskFactors(baseCase, transactionStructure)\n    };\n  }\n\n  /**\n   * Generate investment highlights\n   * @param {Object} baseCase - Base case results\n   * @param {Object} transactionStructure - Transaction structure\n   * @returns {Array} Investment highlights\n   */\n  generateInvestmentHighlights(baseCase, transactionStructure) {\n    const highlights = [];\n    const irr = baseCase.returnsAnalysis.irr;\n    const moic = baseCase.returnsAnalysis.moic;\n\n    if (irr > 0.2) {\n      highlights.push(`Strong projected IRR of ${(irr * 100).toFixed(1)}%`);\n    }\n\n    if (moic > 2.5) {\n      highlights.push(`Attractive multiple of ${moic.toFixed(1)}x invested capital`);\n    }\n\n    if (transactionStructure.debtToEbitda < 5) {\n      highlights.push(`Conservative leverage at ${transactionStructure.debtToEbitda.toFixed(1)}x EBITDA`);\n    }\n\n    return highlights;\n  }\n\n  /**\n   * Generate risk factors\n   * @param {Object} baseCase - Base case results\n   * @param {Object} transactionStructure - Transaction structure\n   * @returns {Array} Risk factors\n   */\n  generateRiskFactors(baseCase, transactionStructure) {\n    const risks = [];\n\n    if (transactionStructure.debtToEbitda > 6) {\n      risks.push(`High leverage at ${transactionStructure.debtToEbitda.toFixed(1)}x EBITDA`);\n    }\n\n    if (baseCase.returnsAnalysis.irr < 0.15) {\n      risks.push(`Below-target IRR of ${(baseCase.returnsAnalysis.irr * 100).toFixed(1)}%`);\n    }\n\n    return risks;\n  }\n}\n\n// Export singleton instance\nexport const lboModelingEngine = new LBOModelingEngine();\nexport default LBOModelingEngine;\n","import { apiLogger } from '../utils/apiLogger.js';\n\n/**\n * Monte Carlo Simulation Engine\n * Provides advanced statistical modeling and risk analysis\n */\nclass MonteCarloEngine {\n  constructor() {\n    this.workers = [];\n    this.isRunning = false;\n    this.currentSimulation = null;\n  }\n\n  /**\n   * Run Monte Carlo simulation for DCF analysis\n   * @param {Object} baseInputs - Base DCF inputs\n   * @param {Object} distributions - Variable distributions\n   * @param {Object} options - Simulation options\n   * @returns {Promise<Object>} Simulation results\n   */\n  async runDCFSimulation(baseInputs, distributions, options = {}) {\n    const {\n      iterations = 10000,\n      confidenceLevel = 0.95,\n      correlationMatrix = null,\n      randomSeed = null\n    } = options;\n\n    apiLogger.log('INFO', 'Starting DCF Monte Carlo simulation', {\n      iterations,\n      variables: Object.keys(distributions).length\n    });\n\n    this.isRunning = true;\n    const startTime = Date.now();\n\n    try {\n      // Initialize random number generator\n      if (randomSeed) {\n        this.setSeed(randomSeed);\n      }\n\n      // Generate correlated random samples\n      const samples = this.generateCorrelatedSamples(\n        distributions,\n        iterations,\n        correlationMatrix\n      );\n\n      // Run simulation iterations\n      const results = [];\n      const progressCallback = options.onProgress;\n\n      for (let i = 0; i < iterations; i++) {\n        if (!this.isRunning) {\n          throw new Error('Simulation cancelled');\n        }\n\n        // Create scenario inputs\n        const scenarioInputs = this.createScenarioInputs(baseInputs, samples[i], distributions);\n\n        // Calculate DCF for this scenario\n        const dcfResult = this.calculateDCFScenario(scenarioInputs);\n        results.push({\n          iteration: i + 1,\n          pricePerShare: dcfResult.pricePerShare,\n          enterpriseValue: dcfResult.enterpriseValue,\n          upside: dcfResult.upside,\n          inputs: scenarioInputs\n        });\n\n        // Report progress\n        if (progressCallback && i % Math.floor(iterations / 100) === 0) {\n          progressCallback((i / iterations) * 100);\n        }\n      }\n\n      // Analyze results\n      const analysis = this.analyzeResults(results, confidenceLevel);\n\n      const endTime = Date.now();\n      apiLogger.log('INFO', 'DCF Monte Carlo simulation completed', {\n        iterations,\n        duration: endTime - startTime,\n        meanPrice: analysis.statistics.mean\n      });\n\n      return {\n        type: 'DCF_MONTE_CARLO',\n        timestamp: new Date().toISOString(),\n        parameters: { iterations, confidenceLevel, randomSeed },\n        results,\n        analysis,\n        duration: endTime - startTime\n      };\n\n    } catch (error) {\n      this.isRunning = false;\n      apiLogger.log('ERROR', 'DCF Monte Carlo simulation failed', { error: error.message });\n      throw error;\n    } finally {\n      this.isRunning = false;\n    }\n  }\n\n  /**\n   * Run Monte Carlo simulation for LBO analysis\n   * @param {Object} baseInputs - Base LBO inputs\n   * @param {Object} distributions - Variable distributions\n   * @param {Object} options - Simulation options\n   * @returns {Promise<Object>} Simulation results\n   */\n  async runLBOSimulation(baseInputs, distributions, options = {}) {\n    const {\n      iterations = 10000,\n      confidenceLevel = 0.95,\n      correlationMatrix = null,\n      randomSeed = null\n    } = options;\n\n    apiLogger.log('INFO', 'Starting LBO Monte Carlo simulation', {\n      iterations,\n      variables: Object.keys(distributions).length\n    });\n\n    this.isRunning = true;\n    const startTime = Date.now();\n\n    try {\n      if (randomSeed) {\n        this.setSeed(randomSeed);\n      }\n\n      const samples = this.generateCorrelatedSamples(\n        distributions,\n        iterations,\n        correlationMatrix\n      );\n\n      const results = [];\n      const progressCallback = options.onProgress;\n\n      for (let i = 0; i < iterations; i++) {\n        if (!this.isRunning) {\n          throw new Error('Simulation cancelled');\n        }\n\n        const scenarioInputs = this.createScenarioInputs(baseInputs, samples[i], distributions);\n        const lboResult = this.calculateLBOScenario(scenarioInputs);\n\n        results.push({\n          iteration: i + 1,\n          irr: lboResult.irr,\n          moic: lboResult.moic,\n          totalReturn: lboResult.totalReturn,\n          inputs: scenarioInputs\n        });\n\n        if (progressCallback && i % Math.floor(iterations / 100) === 0) {\n          progressCallback((i / iterations) * 100);\n        }\n      }\n\n      const analysis = this.analyzeResults(results, confidenceLevel, ['irr', 'moic', 'totalReturn']);\n\n      const endTime = Date.now();\n      apiLogger.log('INFO', 'LBO Monte Carlo simulation completed', {\n        iterations,\n        duration: endTime - startTime,\n        meanIRR: analysis.statistics.irr?.mean\n      });\n\n      return {\n        type: 'LBO_MONTE_CARLO',\n        timestamp: new Date().toISOString(),\n        parameters: { iterations, confidenceLevel, randomSeed },\n        results,\n        analysis,\n        duration: endTime - startTime\n      };\n\n    } catch (error) {\n      this.isRunning = false;\n      apiLogger.log('ERROR', 'LBO Monte Carlo simulation failed', { error: error.message });\n      throw error;\n    } finally {\n      this.isRunning = false;\n    }\n  }\n\n  /**\n   * Generate correlated random samples using Cholesky decomposition\n   * @param {Object} distributions - Variable distributions\n   * @param {number} iterations - Number of iterations\n   * @param {Array} correlationMatrix - Correlation matrix\n   * @returns {Array} Array of sample sets\n   */\n  generateCorrelatedSamples(distributions, iterations, correlationMatrix) {\n    const variables = Object.keys(distributions);\n    const numVars = variables.length;\n    const samples = [];\n\n    // Generate independent samples first\n    const independentSamples = [];\n    for (let i = 0; i < iterations; i++) {\n      const sample = {};\n      variables.forEach(variable => {\n        const dist = distributions[variable];\n        sample[variable] = this.sampleFromDistribution(dist);\n      });\n      independentSamples.push(sample);\n    }\n\n    // Apply correlation if matrix is provided\n    if (correlationMatrix && correlationMatrix.length === numVars) {\n      const choleskyMatrix = this.choleskyDecomposition(correlationMatrix);\n\n      for (let i = 0; i < iterations; i++) {\n        const correlatedSample = {};\n        const independentValues = variables.map(v => independentSamples[i][v]);\n        const correlatedValues = this.applyCorrelation(independentValues, choleskyMatrix);\n\n        variables.forEach((variable, index) => {\n          correlatedSample[variable] = correlatedValues[index];\n        });\n\n        samples.push(correlatedSample);\n      }\n    } else {\n      samples.push(...independentSamples);\n    }\n\n    return samples;\n  }\n\n  /**\n   * Sample from a probability distribution with enhanced types\n   * @param {Object} distribution - Distribution parameters\n   * @returns {number} Random sample\n   */\n  sampleFromDistribution(distribution) {\n    const { type, parameters } = distribution;\n\n    switch (type) {\n      case 'normal':\n        return this.normalRandom(parameters.mean, parameters.stdDev);\n\n      case 'lognormal':\n        const normalSample = this.normalRandom(parameters.mu, parameters.sigma);\n        return Math.exp(normalSample);\n\n      case 'uniform':\n        return parameters.min + Math.random() * (parameters.max - parameters.min);\n\n      case 'triangular':\n        return this.triangularRandom(parameters.min, parameters.mode, parameters.max);\n\n      case 'beta':\n        return this.betaRandom(parameters.alpha, parameters.beta);\n        \n      case 'exponential':\n        return this.exponentialRandom(parameters.lambda);\n        \n      case 'weibull':\n        return this.weibullRandom(parameters.shape, parameters.scale);\n        \n      case 'pareto':\n        return this.paretoRandom(parameters.scale, parameters.shape);\n        \n      case 'student_t':\n        return this.studentTRandom(parameters.df);\n        \n      case 'chi_squared':\n        return this.chiSquaredRandom(parameters.df);\n\n      default:\n        throw new Error(`Unsupported distribution type: ${type}`);\n    }\n  }\n  \n  /**\n   * Generate exponential random variable\n   * @param {number} lambda - Rate parameter\n   * @returns {number} Exponential random variable\n   */\n  exponentialRandom(lambda) {\n    return -Math.log(1 - Math.random()) / lambda;\n  }\n  \n  /**\n   * Generate Weibull random variable\n   * @param {number} shape - Shape parameter (k)\n   * @param {number} scale - Scale parameter (lambda)\n   * @returns {number} Weibull random variable\n   */\n  weibullRandom(shape, scale) {\n    const u = Math.random();\n    return scale * Math.pow(-Math.log(1 - u), 1 / shape);\n  }\n  \n  /**\n   * Generate Pareto random variable\n   * @param {number} scale - Scale parameter (xm)\n   * @param {number} shape - Shape parameter (alpha)\n   * @returns {number} Pareto random variable\n   */\n  paretoRandom(scale, shape) {\n    const u = Math.random();\n    return scale / Math.pow(u, 1 / shape);\n  }\n  \n  /**\n   * Generate Student's t random variable\n   * @param {number} df - Degrees of freedom\n   * @returns {number} Student's t random variable\n   */\n  studentTRandom(df) {\n    if (df <= 0) throw new Error('Degrees of freedom must be positive');\n    \n    const normal = this.normalRandom(0, 1);\n    const chiSq = this.chiSquaredRandom(df);\n    \n    return normal / Math.sqrt(chiSq / df);\n  }\n  \n  /**\n   * Generate Chi-squared random variable\n   * @param {number} df - Degrees of freedom\n   * @returns {number} Chi-squared random variable\n   */\n  chiSquaredRandom(df) {\n    if (df <= 0) throw new Error('Degrees of freedom must be positive');\n    \n    return this.gammaRandom(df / 2) * 2;\n  }\n\n  /**\n   * Generate normal random variable using Box-Muller transform\n   * @param {number} mean - Mean\n   * @param {number} stdDev - Standard deviation\n   * @returns {number} Normal random variable\n   */\n  normalRandom(mean = 0, stdDev = 1) {\n    if (this.spareNormal !== undefined) {\n      const spare = this.spareNormal;\n      this.spareNormal = undefined;\n      return spare * stdDev + mean;\n    }\n\n    const u1 = Math.random();\n    const u2 = Math.random();\n    const z0 = Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);\n    const z1 = Math.sqrt(-2 * Math.log(u1)) * Math.sin(2 * Math.PI * u2);\n\n    this.spareNormal = z1;\n    return z0 * stdDev + mean;\n  }\n\n  /**\n   * Generate triangular random variable\n   * @param {number} min - Minimum value\n   * @param {number} mode - Mode value\n   * @param {number} max - Maximum value\n   * @returns {number} Triangular random variable\n   */\n  triangularRandom(min, mode, max) {\n    const u = Math.random();\n    const c = (mode - min) / (max - min);\n\n    if (u < c) {\n      return min + Math.sqrt(u * (max - min) * (mode - min));\n    } else {\n      return max - Math.sqrt((1 - u) * (max - min) * (max - mode));\n    }\n  }\n\n  /**\n   * Generate beta random variable\n   * @param {number} alpha - Alpha parameter\n   * @param {number} beta - Beta parameter\n   * @returns {number} Beta random variable\n   */\n  betaRandom(alpha, beta) {\n    const x = this.gammaRandom(alpha);\n    const y = this.gammaRandom(beta);\n    return x / (x + y);\n  }\n\n  /**\n   * Generate gamma random variable\n   * @param {number} shape - Shape parameter\n   * @returns {number} Gamma random variable\n   */\n  gammaRandom(shape) {\n    // Marsaglia and Tsang's method for shape >= 1\n    if (shape >= 1) {\n      const d = shape - 1 / 3;\n      const c = 1 / Math.sqrt(9 * d);\n\n      while (true) {\n        let x, v;\n        do {\n          x = this.normalRandom();\n          v = 1 + c * x;\n        } while (v <= 0);\n\n        v = v * v * v;\n        const u = Math.random();\n\n        if (u < 1 - 0.0331 * x * x * x * x) {\n          return d * v;\n        }\n\n        if (Math.log(u) < 0.5 * x * x + d * (1 - v + Math.log(v))) {\n          return d * v;\n        }\n      }\n    } else {\n      // For shape < 1, use transformation\n      return this.gammaRandom(shape + 1) * Math.pow(Math.random(), 1 / shape);\n    }\n  }\n\n  /**\n   * Perform Cholesky decomposition\n   * @param {Array} matrix - Correlation matrix\n   * @returns {Array} Lower triangular matrix\n   */\n  choleskyDecomposition(matrix) {\n    const n = matrix.length;\n    const L = Array(n).fill().map(() => Array(n).fill(0));\n\n    for (let i = 0; i < n; i++) {\n      for (let j = 0; j <= i; j++) {\n        if (i === j) {\n          let sum = 0;\n          for (let k = 0; k < j; k++) {\n            sum += L[j][k] * L[j][k];\n          }\n          L[j][j] = Math.sqrt(matrix[j][j] - sum);\n        } else {\n          let sum = 0;\n          for (let k = 0; k < j; k++) {\n            sum += L[i][k] * L[j][k];\n          }\n          L[i][j] = (matrix[i][j] - sum) / L[j][j];\n        }\n      }\n    }\n\n    return L;\n  }\n\n  /**\n   * Apply correlation using Cholesky matrix\n   * @param {Array} independentValues - Independent random values\n   * @param {Array} choleskyMatrix - Cholesky decomposition matrix\n   * @returns {Array} Correlated values\n   */\n  applyCorrelation(independentValues, choleskyMatrix) {\n    const n = independentValues.length;\n    const correlatedValues = Array(n).fill(0);\n\n    for (let i = 0; i < n; i++) {\n      for (let j = 0; j <= i; j++) {\n        correlatedValues[i] += choleskyMatrix[i][j] * independentValues[j];\n      }\n    }\n\n    return correlatedValues;\n  }\n\n  /**\n   * Create scenario inputs by applying random samples to base inputs\n   * @param {Object} baseInputs - Base model inputs\n   * @param {Object} samples - Random samples\n   * @param {Object} distributions - Distribution definitions\n   * @returns {Object} Scenario inputs\n   */\n  createScenarioInputs(baseInputs, samples, distributions) {\n    const scenarioInputs = { ...baseInputs };\n\n    Object.entries(samples).forEach(([variable, sample]) => {\n      const distribution = distributions[variable];\n\n      if (distribution.applyTo) {\n        // Apply sample to specific input field\n        scenarioInputs[distribution.applyTo] = sample;\n      } else {\n        // Direct assignment\n        scenarioInputs[variable] = sample;\n      }\n    });\n\n    return scenarioInputs;\n  }\n\n  /**\n   * Calculate DCF scenario (simplified for Monte Carlo)\n   * @param {Object} inputs - Scenario inputs\n   * @returns {Object} DCF results\n   */\n  calculateDCFScenario(inputs) {\n    // This would integrate with the financialModelingEngine\n    // Simplified calculation for demonstration\n    const {\n      currentRevenue = 1000000000,\n      revenueGrowthRate = 0.1,\n      fcfMargin = 0.15,\n      wacc = 0.1,\n      terminalGrowthRate = 0.025,\n      sharesOutstanding = 100000000,\n      currentPrice = 100\n    } = inputs;\n\n    // Simple DCF calculation\n    const projectionYears = 5;\n    let totalPV = 0;\n    let revenue = currentRevenue;\n\n    for (let year = 1; year <= projectionYears; year++) {\n      revenue *= (1 + revenueGrowthRate);\n      const fcf = revenue * fcfMargin;\n      const pv = fcf / Math.pow(1 + wacc, year);\n      totalPV += pv;\n    }\n\n    // Terminal value\n    const terminalFCF = revenue * fcfMargin * (1 + terminalGrowthRate);\n    const terminalValue = terminalFCF / (wacc - terminalGrowthRate);\n    const pvTerminal = terminalValue / Math.pow(1 + wacc, projectionYears);\n\n    const enterpriseValue = totalPV + pvTerminal;\n    const pricePerShare = enterpriseValue / sharesOutstanding;\n    const upside = ((pricePerShare - currentPrice) / currentPrice) * 100;\n\n    return {\n      pricePerShare,\n      enterpriseValue,\n      upside\n    };\n  }\n\n  /**\n   * Calculate LBO scenario (simplified for Monte Carlo)\n   * @param {Object} inputs - Scenario inputs\n   * @returns {Object} LBO results\n   */\n  calculateLBOScenario(inputs) {\n    // Simplified LBO calculation for demonstration\n    const {\n      ebitda = 100000000,\n      ebitdaGrowthRate = 0.05,\n      exitMultiple = 10,\n      debtMultiple = 5,\n      holdingPeriod = 5\n    } = inputs;\n\n    const purchasePrice = ebitda * 10; // Assume 10x entry multiple\n    const debt = ebitda * debtMultiple;\n    const equity = purchasePrice - debt;\n\n    // Project exit EBITDA\n    const exitEbitda = ebitda * Math.pow(1 + ebitdaGrowthRate, holdingPeriod);\n    const exitValue = exitEbitda * exitMultiple;\n    const remainingDebt = debt * 0.5; // Assume 50% paydown\n    const exitProceeds = exitValue - remainingDebt;\n\n    const totalReturn = exitProceeds / equity;\n    const irr = Math.pow(totalReturn, 1 / holdingPeriod) - 1;\n\n    return {\n      irr,\n      moic: totalReturn,\n      totalReturn: exitProceeds\n    };\n  }\n\n  /**\n   * Analyze simulation results with enhanced statistical measures\n   * @param {Array} results - Simulation results\n   * @param {number} confidenceLevel - Confidence level\n   * @param {Array} metrics - Metrics to analyze\n   * @returns {Object} Comprehensive statistical analysis\n   */\n  analyzeResults(results, confidenceLevel, metrics = ['pricePerShare', 'enterpriseValue', 'upside']) {\n    const analysis = {\n      statistics: {},\n      percentiles: {},\n      confidenceIntervals: {},\n      riskMetrics: {},\n      distributionTests: {},\n      correlations: {}\n    };\n\n    metrics.forEach(metric => {\n      const values = results.map(r => r[metric]).filter(v => v !== null && !isNaN(v)).sort((a, b) => a - b);\n\n      if (values.length === 0) return;\n\n      const mean = values.reduce((sum, v) => sum + v, 0) / values.length;\n      const variance = values.reduce((sum, v) => sum + Math.pow(v - mean, 2), 0) / values.length;\n      const stdDev = Math.sqrt(variance);\n      const sampleStdDev = Math.sqrt(variance * values.length / (values.length - 1)); // Bessel's correction\n\n      analysis.statistics[metric] = {\n        mean,\n        median: this.percentile(values, 0.5),\n        mode: this.calculateMode(values),\n        stdDev,\n        sampleStdDev,\n        variance,\n        min: values[0],\n        max: values[values.length - 1],\n        range: values[values.length - 1] - values[0],\n        count: values.length,\n        // Additional robust statistics\n        trimmedMean: this.calculateTrimmedMean(values, 0.1), // 10% trimmed mean\n        mad: this.calculateMAD(values), // Median Absolute Deviation\n        iqr: this.percentile(values, 0.75) - this.percentile(values, 0.25)\n      };\n\n      analysis.percentiles[metric] = {\n        p1: this.percentile(values, 0.01),\n        p5: this.percentile(values, 0.05),\n        p10: this.percentile(values, 0.10),\n        p25: this.percentile(values, 0.25),\n        p50: this.percentile(values, 0.5),\n        p75: this.percentile(values, 0.75),\n        p90: this.percentile(values, 0.90),\n        p95: this.percentile(values, 0.95),\n        p99: this.percentile(values, 0.99)\n      };\n\n      const alpha = 1 - confidenceLevel;\n      const lowerBound = this.percentile(values, alpha / 2);\n      const upperBound = this.percentile(values, 1 - alpha / 2);\n\n      analysis.confidenceIntervals[metric] = {\n        level: confidenceLevel,\n        lowerBound,\n        upperBound,\n        width: upperBound - lowerBound,\n        // Bootstrap confidence intervals\n        bootstrapCI: this.calculateBootstrapCI(values, confidenceLevel)\n      };\n\n      const var95 = this.percentile(values, 0.05);\n      const var99 = this.percentile(values, 0.01);\n      const cvar95 = values.slice(0, Math.floor(values.length * 0.05)).reduce((sum, v) => sum + v, 0) / Math.floor(values.length * 0.05);\n      const cvar99 = values.slice(0, Math.floor(values.length * 0.01)).reduce((sum, v) => sum + v, 0) / Math.floor(values.length * 0.01);\n\n      analysis.riskMetrics[metric] = {\n        var95, // Value at Risk (5%)\n        var99, // Value at Risk (1%)\n        cvar95, // Conditional VaR (5%)\n        cvar99, // Conditional VaR (1%)\n        skewness: this.calculateSkewness(values, mean, stdDev),\n        kurtosis: this.calculateKurtosis(values, mean, stdDev),\n        excessKurtosis: this.calculateKurtosis(values, mean, stdDev) - 3,\n        // Tail risk measures\n        expectedShortfall: cvar95,\n        maxDrawdown: this.calculateMaxDrawdown(values),\n        // Risk-adjusted returns\n        sharpeRatio: this.calculateSharpeRatio(values, 0.02), // Assuming 2% risk-free rate\n        sortinoRatio: this.calculateSortinoRatio(values, mean)\n      };\n      \n      // Distribution fitting tests\n      analysis.distributionTests[metric] = {\n        jarqueBera: this.jarqueBeraTest(values),\n        kolmogorovSmirnov: this.ksTestNormality(values),\n        shapiroWilk: values.length <= 5000 ? this.shapiroWilkTest(values) : null\n      };\n    });\n    \n    // Calculate correlation matrix between metrics\n    if (metrics.length > 1) {\n      analysis.correlations = this.calculateCorrelationMatrix(results, metrics);\n    }\n\n    return analysis;\n  }\n  \n  /**\n   * Calculate mode of dataset\n   */\n  calculateMode(values) {\n    const frequency = {};\n    values.forEach(v => {\n      const rounded = Math.round(v * 100) / 100; // Round to avoid floating point issues\n      frequency[rounded] = (frequency[rounded] || 0) + 1;\n    });\n    \n    const maxFreq = Math.max(...Object.values(frequency));\n    const modes = Object.keys(frequency).filter(k => frequency[k] === maxFreq);\n    \n    return modes.length === 1 ? parseFloat(modes[0]) : null;\n  }\n  \n  /**\n   * Calculate trimmed mean\n   */\n  calculateTrimmedMean(sortedValues, trimProportion = 0.1) {\n    const trimCount = Math.floor(sortedValues.length * trimProportion);\n    const trimmedValues = sortedValues.slice(trimCount, -trimCount || undefined);\n    return trimmedValues.reduce((sum, v) => sum + v, 0) / trimmedValues.length;\n  }\n  \n  /**\n   * Calculate Median Absolute Deviation\n   */\n  calculateMAD(values) {\n    const median = this.percentile(values, 0.5);\n    const deviations = values.map(v => Math.abs(v - median)).sort((a, b) => a - b);\n    return this.percentile(deviations, 0.5);\n  }\n  \n  /**\n   * Calculate bootstrap confidence interval\n   */\n  calculateBootstrapCI(values, confidenceLevel, bootstrapSamples = 1000) {\n    const bootstrapMeans = [];\n    \n    for (let i = 0; i < bootstrapSamples; i++) {\n      const sample = [];\n      for (let j = 0; j < values.length; j++) {\n        sample.push(values[Math.floor(Math.random() * values.length)]);\n      }\n      bootstrapMeans.push(sample.reduce((sum, v) => sum + v, 0) / sample.length);\n    }\n    \n    bootstrapMeans.sort((a, b) => a - b);\n    const alpha = 1 - confidenceLevel;\n    \n    return {\n      lowerBound: this.percentile(bootstrapMeans, alpha / 2),\n      upperBound: this.percentile(bootstrapMeans, 1 - alpha / 2)\n    };\n  }\n  \n  /**\n   * Calculate maximum drawdown\n   */\n  calculateMaxDrawdown(values) {\n    let peak = values[0];\n    let maxDrawdown = 0;\n    \n    for (const value of values) {\n      if (value > peak) {\n        peak = value;\n      }\n      const drawdown = (peak - value) / peak;\n      if (drawdown > maxDrawdown) {\n        maxDrawdown = drawdown;\n      }\n    }\n    \n    return maxDrawdown;\n  }\n  \n  /**\n   * Calculate Sharpe ratio approximation\n   */\n  calculateSharpeRatio(values, riskFreeRate = 0.02) {\n    const mean = values.reduce((sum, v) => sum + v, 0) / values.length;\n    const variance = values.reduce((sum, v) => sum + Math.pow(v - mean, 2), 0) / values.length;\n    const stdDev = Math.sqrt(variance);\n    \n    return stdDev > 0 ? (mean - riskFreeRate) / stdDev : 0;\n  }\n  \n  /**\n   * Calculate Sortino ratio\n   */\n  calculateSortinoRatio(values, targetReturn) {\n    const excessReturns = values.map(v => v - targetReturn);\n    const negativeReturns = excessReturns.filter(r => r < 0);\n    \n    if (negativeReturns.length === 0) return Infinity;\n    \n    const downsideDeviation = Math.sqrt(\n      negativeReturns.reduce((sum, r) => sum + r * r, 0) / negativeReturns.length\n    );\n    \n    const meanExcessReturn = excessReturns.reduce((sum, r) => sum + r, 0) / excessReturns.length;\n    \n    return downsideDeviation > 0 ? meanExcessReturn / downsideDeviation : 0;\n  }\n  \n  /**\n   * Jarque-Bera test for normality\n   */\n  jarqueBeraTest(values) {\n    const n = values.length;\n    const mean = values.reduce((sum, v) => sum + v, 0) / n;\n    const variance = values.reduce((sum, v) => sum + Math.pow(v - mean, 2), 0) / n;\n    const stdDev = Math.sqrt(variance);\n    \n    const skewness = this.calculateSkewness(values, mean, stdDev);\n    const kurtosis = this.calculateKurtosis(values, mean, stdDev);\n    \n    const jb = (n / 6) * (Math.pow(skewness, 2) + Math.pow(kurtosis - 3, 2) / 4);\n    const pValue = 1 - this.chiSquaredCDF(jb, 2); // Approximate p-value\n    \n    return {\n      statistic: jb,\n      pValue,\n      isNormal: pValue > 0.05\n    };\n  }\n  \n  /**\n   * Approximate chi-squared CDF\n   */\n  chiSquaredCDF(x, df) {\n    if (x <= 0) return 0;\n    return this.incompleteGamma(df / 2, x / 2);\n  }\n  \n  /**\n   * Incomplete gamma function approximation\n   */\n  incompleteGamma(a, x) {\n    // Simple approximation for demonstration\n    if (x === 0) return 0;\n    if (x < a + 1) {\n      let sum = 1 / a;\n      let term = 1 / a;\n      for (let n = 1; n < 100; n++) {\n        term *= x / (a + n);\n        sum += term;\n        if (term < 1e-15) break;\n      }\n      return Math.exp(-x + a * Math.log(x) - this.logGamma(a)) * sum;\n    } else {\n      return 1 - this.incompleteGamma(a, x);\n    }\n  }\n  \n  /**\n   * Log gamma function approximation\n   */\n  logGamma(x) {\n    const coef = [\n      76.18009172947146, -86.50532032941677, 24.01409824083091,\n      -1.231739572450155, 0.1208650973866179e-2, -0.5395239384953e-5\n    ];\n    \n    let j = 0;\n    let ser = 1.000000000190015;\n    let xx = x;\n    let y = xx = x;\n    let tmp = x + 5.5;\n    tmp -= (x + 0.5) * Math.log(tmp);\n    \n    for (; j < 6; j++) {\n      ser += coef[j] / ++y;\n    }\n    \n    return -tmp + Math.log(2.5066282746310005 * ser / xx);\n  }\n  \n  /**\n   * Kolmogorov-Smirnov test for normality\n   */\n  ksTestNormality(values) {\n    const n = values.length;\n    const mean = values.reduce((sum, v) => sum + v, 0) / n;\n    const variance = values.reduce((sum, v) => sum + Math.pow(v - mean, 2), 0) / n;\n    const stdDev = Math.sqrt(variance);\n    \n    let maxD = 0;\n    \n    for (let i = 0; i < n; i++) {\n      const empirical = (i + 1) / n;\n      const theoretical = this.normalCDF((values[i] - mean) / stdDev);\n      const d = Math.abs(empirical - theoretical);\n      if (d > maxD) maxD = d;\n    }\n    \n    const critical = 1.36 / Math.sqrt(n); // Critical value at 5% significance\n    \n    return {\n      statistic: maxD,\n      critical,\n      isNormal: maxD < critical\n    };\n  }\n  \n  /**\n   * Normal CDF approximation\n   */\n  normalCDF(x) {\n    return 0.5 * (1 + this.erf(x / Math.sqrt(2)));\n  }\n  \n  /**\n   * Error function approximation\n   */\n  erf(x) {\n    const a1 =  0.254829592;\n    const a2 = -0.284496736;\n    const a3 =  1.421413741;\n    const a4 = -1.453152027;\n    const a5 =  1.061405429;\n    const p  =  0.3275911;\n    \n    const sign = x < 0 ? -1 : 1;\n    x = Math.abs(x);\n    \n    const t = 1.0 / (1.0 + p * x);\n    const y = 1.0 - (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1) * t * Math.exp(-x * x);\n    \n    return sign * y;\n  }\n  \n  /**\n   * Shapiro-Wilk test for normality (simplified)\n   */\n  shapiroWilkTest(values) {\n    // Simplified implementation - in practice, would use lookup tables\n    const n = values.length;\n    if (n < 3 || n > 5000) return null;\n    \n    const sortedValues = [...values].sort((a, b) => a - b);\n    const mean = values.reduce((sum, v) => sum + v, 0) / n;\n    \n    // This is a very simplified approximation\n    let numerator = 0;\n    let denominator = 0;\n    \n    for (let i = 0; i < n; i++) {\n      denominator += Math.pow(sortedValues[i] - mean, 2);\n    }\n    \n    // Simplified calculation - real implementation would use Shapiro-Wilk coefficients\n    const w = numerator / denominator;\n    \n    return {\n      statistic: w,\n      isNormal: w > 0.9 // Very rough approximation\n    };\n  }\n  \n  /**\n   * Calculate correlation matrix between metrics\n   */\n  calculateCorrelationMatrix(results, metrics) {\n    const correlationMatrix = {};\n    \n    for (let i = 0; i < metrics.length; i++) {\n      correlationMatrix[metrics[i]] = {};\n      for (let j = 0; j < metrics.length; j++) {\n        if (i === j) {\n          correlationMatrix[metrics[i]][metrics[j]] = 1.0;\n        } else {\n          const valuesI = results.map(r => r[metrics[i]]).filter(v => v !== null && !isNaN(v));\n          const valuesJ = results.map(r => r[metrics[j]]).filter(v => v !== null && !isNaN(v));\n          \n          correlationMatrix[metrics[i]][metrics[j]] = this.calculateCorrelation(valuesI, valuesJ);\n        }\n      }\n    }\n    \n    return correlationMatrix;\n  }\n  \n  /**\n   * Calculate Pearson correlation coefficient\n   */\n  calculateCorrelation(x, y) {\n    if (x.length !== y.length || x.length === 0) return 0;\n    \n    const n = x.length;\n    const meanX = x.reduce((sum, v) => sum + v, 0) / n;\n    const meanY = y.reduce((sum, v) => sum + v, 0) / n;\n    \n    let numerator = 0;\n    let sumXX = 0;\n    let sumYY = 0;\n    \n    for (let i = 0; i < n; i++) {\n      const dx = x[i] - meanX;\n      const dy = y[i] - meanY;\n      numerator += dx * dy;\n      sumXX += dx * dx;\n      sumYY += dy * dy;\n    }\n    \n    const denominator = Math.sqrt(sumXX * sumYY);\n    return denominator > 0 ? numerator / denominator : 0;\n  }\n\n  /**\n   * Calculate percentile\n   * @param {Array} sortedValues - Sorted array of values\n   * @param {number} p - Percentile (0-1)\n   * @returns {number} Percentile value\n   */\n  percentile(sortedValues, p) {\n    const index = p * (sortedValues.length - 1);\n    const lower = Math.floor(index);\n    const upper = Math.ceil(index);\n    const weight = index - lower;\n\n    if (lower === upper) {\n      return sortedValues[lower];\n    }\n\n    return sortedValues[lower] * (1 - weight) + sortedValues[upper] * weight;\n  }\n\n  /**\n   * Calculate skewness\n   * @param {Array} values - Array of values\n   * @param {number} mean - Mean\n   * @param {number} stdDev - Standard deviation\n   * @returns {number} Skewness\n   */\n  calculateSkewness(values, mean, stdDev) {\n    const n = values.length;\n    const sum = values.reduce((sum, v) => sum + Math.pow((v - mean) / stdDev, 3), 0);\n    return (n / ((n - 1) * (n - 2))) * sum;\n  }\n\n  /**\n   * Calculate kurtosis\n   * @param {Array} values - Array of values\n   * @param {number} mean - Mean\n   * @param {number} stdDev - Standard deviation\n   * @returns {number} Kurtosis\n   */\n  calculateKurtosis(values, mean, stdDev) {\n    const n = values.length;\n    const sum = values.reduce((sum, v) => sum + Math.pow((v - mean) / stdDev, 4), 0);\n    return ((n * (n + 1)) / ((n - 1) * (n - 2) * (n - 3))) * sum - (3 * Math.pow(n - 1, 2)) / ((n - 2) * (n - 3));\n  }\n\n  /**\n   * Set random seed for reproducible results\n   * @param {number} seed - Random seed\n   */\n  setSeed(seed) {\n    // Simple linear congruential generator for reproducible results\n    this.seed = seed;\n    this.random = () => {\n      this.seed = (this.seed * 9301 + 49297) % 233280;\n      return this.seed / 233280;\n    };\n    Math.random = this.random;\n  }\n\n  /**\n   * Stop running simulation\n   */\n  stopSimulation() {\n    this.isRunning = false;\n  }\n\n  /**\n   * Check if simulation is running\n   * @returns {boolean} True if running\n   */\n  isSimulationRunning() {\n    return this.isRunning;\n  }\n}\n\n// Export singleton instance\nexport const monteCarloEngine = new MonteCarloEngine();\nexport default MonteCarloEngine;\n"],"names":["LOG_LEVELS","ERROR","WARN","INFO","DEBUG","TRACE","DEFAULT_CONFIG","logLevel","enableMetrics","enablePerformanceTracking","enableErrorTracking","maxLogHistory","metricsRetentionPeriod","apiLogger","constructor","config","this","logs","metrics","Map","performanceData","errorCounts","startTime","Date","now","log","level","message","metadata","toUpperCase","logEntry","timestamp","toISOString","id","generateLogId","push","trimLogs","outputToConsole","logApiRequest","service","endpoint","params","requestId","generateRequestId","sanitizeParams","set","logApiResponse","success","response","error","get","duration","responseSize","getResponseSize","recordMetric","code","status","statusText","recordError","delete","logRateLimit","waitTime","remainingRequests","action","logCircuitBreaker","state","emoji","OPEN","HALF_OPEN","CLOSED","toLowerCase","logCache","operation","key","hit","miss","clear","sanitizeCacheKey","metric","value","has","values","total","count","min","Infinity","max","avg","metricData","Math","cleanOldMetrics","errorKey","getMetrics","summary","uptime","totalLogs","length","services","cache","errors","data","entries","split","messageParts","join","getRecentLogs","limit","filter","slice","reverse","random","toString","substr","sanitized","apikey","api_key","token","substring","JSON","stringify","cutoff","item","toLocaleTimeString","financialModelingEngine","modelCache","assumptions","getDefaultAssumptions","dcf","projectionYears","terminalGrowthRate","riskFreeRate","marketPremium","taxRate","capexAsPercentOfRevenue","nwcAsPercentOfRevenue","depreciationAsPercentOfRevenue","normalizedMarginTarget","cyclicalAdjustment","industryBeta","sizeAdjustment","countryRiskPremium","liquidityDiscount","lbo","holdingPeriod","debtMultiples","senior","subordinated","interestRates","managementFeeRate","carriedInterestRate","ebitdaGrowthRate","debtPaydownRate","monte_carlo","iterations","confidenceIntervals","correlationMatrix","buildDCFModel","inputs","scenarios","symbol","companyName","currentRevenue","historicalGrowthRates","margins","balanceSheetData","marketData","modelAssumptions","baseCase","calculateDCFScenario","scenarioResults","bull","bullAssumptions","revenueGrowthRate","wacc","bear","bearAssumptions","sensitivityAnalysis","performDCFSensitivityAnalysis","modelType","generateDCFSummary","currentPrice","scenarioName","sharesOutstanding","totalDebt","cash","revenueProjections","projectRevenues","operatingProjections","projectOperatingMetrics","fcfProjections","calculateFreeCashFlows","terminalValue","calculateTerminalValue","pvOfCashFlows","calculatePresentValue","pvOfTerminalValue","enterpriseValue","equityValue","pricePerShare","upside","impliedMultiples","calculateImpliedMultiples","baseRevenue","growthRates","years","projections","i","growthRate","Array","isArray","pow","year","revenue","map","projection","index","ebitdaMargin","ebitda","depreciation","ebit","taxes","nopat","maintenanceCapex","maintenanceCapexRate","growthCapex","growthCapexRate","totalCapex","nwcChange","calculateWorkingCapitalChange","stockBasedComp","stockBasedCompRate","otherNonCash","otherNonCashRate","totalNonCash","fcf","unleveredFCF","fcfMargin","currentProjection","priorProjection","receivablesDays","inventoryDays","payablesDays","cogsPct","finalFCF","discountRate","options","Error","toFixed","method","exitMultiple","fadeToGrowth","fadeYears","longTermGrowth","fadeRate","cashFlows","startYear","reduce","pv","cf","currentYearEbitda","nextYearEbitda","currentYearEbit","nextYearEbit","nextYearRevenue","currentYearFCF","nextYearFCF","evToCurrentRevenue","evToForwardRevenue","evToCurrentEbitda","evToForwardEbitda","evToCurrentEbit","evToForwardEbit","evToCurrentFCF","evToForwardFCF","pegRatio","calculatePEGRatio","currentEarnings","futureEarnings","baseAssumptions","results","Object","forEach","variable","variations","variation","adjustedAssumptions","scenario","pricesPerShare","s","p","priceRange","average","sum","recommendation","generateRecommendation","keyMetrics","impliedReturn","rating","confidence","abs","round","reasoning","generateRecommendationReasoning","upsideAbs","lboModelingEngine","transaction","managementRollover","transactionFees","financingFees","debt","seniorDebtMultiple","subordinatedDebtMultiple","totalDebtMultiple","seniorInterestRate","subordinatedInterestRate","mandatoryPaydown","cashSweep","operating","exit","exitMultipleRange","publicMarketDiscount","fees","hurdle","buildLBOModel","purchasePrice","peerData","transactionStructure","calculateTransactionStructure","calculateLBOScenario","upsideAssumptions","downside","downsideAssumptions","performLBOSensitivityAnalysis","generateLBOSummary","seniorDebt","totalUses","equityContribution","sponsorEquity","adjustedTotalDebt","adjustedSeniorDebt","subordinatedDebt","debtToEbitda","equityToTotalCapital","projectLBOOperatingPerformance","debtSchedule","calculateDebtSchedule","equityCashFlows","calculateEquityCashFlows","exitAnalysis","calculateExitAnalysis","returnsAnalysis","calculateReturnsMetrics","netProceeds","calculateLBOKeyMetrics","baseEbitda","operatingAssumptions","currentEbitda","ebitdaGrowth","capex","debtAssumptions","schedule","seniorDebtBalance","subordinatedDebtBalance","revolvingDebtBalance","revolvingDebt","enhancedAssumptions","revolvingRate","minCashBalance","maxLeverageRatio","minCoverageRatio","maxCapexRatio","seniorInterest","subordinatedInterest","totalInterest","cashAvailableForDebt","excessCash","totalPaydown","seniorPaydown","subordinatedPaydown","leverageRatio","coverageRatio","capexRatio","covenantTests","leverageCompliance","coverageCompliance","capexCompliance","dscr","beginningBalance","endingBalance","revolving","interestExpense","principalPayment","netDebtToEbitda","ebitdaToInterest","managementFees","cashFlowToEquity","finalYearProjection","finalYearDebt","exitEbitda","totalDebtAtExit","grossProceeds","totalReturn","investedCapital","carriedInterest","managementProceeds","initialInvestment","exitProceeds","irr","NaN","moic","totalCashReturned","annualizedReturn","calculateIRR","isNaN","every","sign","tolerance","maxIterations","initialGuess","rate","newtonRaphsonIRR","isFinite","bisectionIRR","secantIRR","npv","dnpv","j","factor","newRate","low","high","npvLow","calculateNPV","mid","npvMid","x0","x1","f0","f1","x2","impliedEntryEbitda","entryMultiple","actualEntryMultiple","peakLeverage","d","minCoverage","avgDSCR","multipleExpansion","operationalImprovement","leverage","entryLeverage","debtToEquity","exitLeverage","leverageReduction","leverageContribution","breakdownLeverage","covenantBreaches","equityEfficiency","timeToRecoverEquity","calculateTimeToRecoverEquity","initialEquity","cumulativeCashFlow","debtMultiple","newDebtMultiple","adjustedStructure","allScenarios","irrs","moics","returnRange","irrMin","irrMax","irrAverage","moicMin","moicMax","moicAverage","investmentHighlights","generateInvestmentHighlights","riskFactors","generateRiskFactors","highlights","risks","monteCarloEngine","workers","isRunning","currentSimulation","runDCFSimulation","baseInputs","distributions","confidenceLevel","randomSeed","variables","keys","setSeed","samples","generateCorrelatedSamples","progressCallback","onProgress","scenarioInputs","createScenarioInputs","dcfResult","iteration","floor","analysis","analyzeResults","endTime","meanPrice","statistics","mean","type","parameters","runLBOSimulation","lboResult","meanIRR","numVars","independentSamples","sample","dist","sampleFromDistribution","choleskyMatrix","choleskyDecomposition","correlatedSample","independentValues","v","correlatedValues","applyCorrelation","distribution","normalRandom","stdDev","normalSample","mu","sigma","exp","triangularRandom","mode","betaRandom","alpha","beta","exponentialRandom","lambda","weibullRandom","shape","scale","paretoRandom","studentTRandom","df","chiSquaredRandom","u","normal","chiSq","sqrt","gammaRandom","undefined","spareNormal","spare","u1","u2","z0","cos","PI","z1","sin","x","c","matrix","n","L","fill","k","applyTo","totalPV","equity","percentiles","riskMetrics","distributionTests","correlations","r","sort","a","b","variance","sampleStdDev","median","percentile","calculateMode","range","trimmedMean","calculateTrimmedMean","mad","calculateMAD","iqr","p1","p5","p10","p25","p50","p75","p90","p95","p99","lowerBound","upperBound","width","bootstrapCI","calculateBootstrapCI","var95","var99","cvar95","cvar99","skewness","calculateSkewness","kurtosis","calculateKurtosis","excessKurtosis","expectedShortfall","maxDrawdown","calculateMaxDrawdown","sharpeRatio","calculateSharpeRatio","sortinoRatio","calculateSortinoRatio","jarqueBera","jarqueBeraTest","kolmogorovSmirnov","ksTestNormality","shapiroWilk","shapiroWilkTest","calculateCorrelationMatrix","frequency","rounded","maxFreq","modes","parseFloat","sortedValues","trimProportion","trimCount","trimmedValues","deviations","bootstrapSamples","bootstrapMeans","peak","drawdown","targetReturn","excessReturns","negativeReturns","downsideDeviation","meanExcessReturn","jb","pValue","chiSquaredCDF","statistic","isNormal","incompleteGamma","term","logGamma","coef","ser","xx","y","tmp","maxD","empirical","theoretical","normalCDF","critical","erf","t","denominator","w","valuesI","valuesJ","calculateCorrelation","meanX","meanY","numerator","sumXX","sumYY","dx","dy","lower","upper","ceil","weight","seed","stopSimulation","isSimulationRunning"],"mappings":"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"}