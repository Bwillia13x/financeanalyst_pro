class t{constructor(){this.algorithm="AES-GCM",this.keyLength=256,this.ivLength=12,this.tagLength=16,this.textEncoder=new TextEncoder,this.textDecoder=new TextDecoder,this.initializeKey()}async initializeKey(){try{const t=localStorage.getItem("financeanalyst_crypto_key");if(t){const e=this.base64ToArrayBuffer(t);this.cryptoKey=await crypto.subtle.importKey("raw",e,{name:this.algorithm},!1,["encrypt","decrypt"])}else{this.cryptoKey=await crypto.subtle.generateKey({name:this.algorithm,length:this.keyLength},!0,["encrypt","decrypt"]);const t=await crypto.subtle.exportKey("raw",this.cryptoKey),e=this.arrayBufferToBase64(t);localStorage.setItem("financeanalyst_crypto_key",e)}}catch(t){throw t}}async encrypt(t){this.cryptoKey||await this.initializeKey();try{const e=this.textEncoder.encode(t),a=crypto.getRandomValues(new Uint8Array(this.ivLength)),s=await crypto.subtle.encrypt({name:this.algorithm,iv:a},this.cryptoKey,e),r=new Uint8Array(a.length+s.byteLength);return r.set(a,0),r.set(new Uint8Array(s),a.length),this.arrayBufferToBase64(r.buffer)}catch(e){throw new Error(`Encryption failed: ${e.message}`)}}async decrypt(t){this.cryptoKey||await this.initializeKey();try{const e=this.base64ToArrayBuffer(t),a=e.slice(0,this.ivLength),s=e.slice(this.ivLength),r=await crypto.subtle.decrypt({name:this.algorithm,iv:a},this.cryptoKey,s);return this.textDecoder.decode(r)}catch(e){throw new Error(`Decryption failed: ${e.message}`)}}async hash(t){try{const e=this.textEncoder.encode(t),a=await crypto.subtle.digest("SHA-256",e);return this.arrayBufferToBase64(a)}catch(e){throw new Error(`Hashing failed: ${e.message}`)}}async verifyIntegrity(t,e){try{return await this.hash(t)===e}catch(a){return!1}}generateRandomString(t=32){const e=new Uint8Array(t);return crypto.getRandomValues(e),this.arrayBufferToBase64(e.buffer).substring(0,t)}async deriveKeyFromPassword(t,e){try{const a=this.textEncoder.encode(t),s=this.textEncoder.encode(e),r=await crypto.subtle.importKey("raw",a,{name:"PBKDF2"},!1,["deriveKey"]);return await crypto.subtle.deriveKey({name:"PBKDF2",salt:s,iterations:1e5,hash:"SHA-256"},r,{name:this.algorithm,length:this.keyLength},!1,["encrypt","decrypt"])}catch(a){throw new Error(`Key derivation failed: ${a.message}`)}}isAvailable(){return!(!window.crypto||!window.crypto.subtle)}getInfo(){return{algorithm:this.algorithm,keyLength:this.keyLength,ivLength:this.ivLength,available:this.isAvailable(),keyInitialized:!!this.cryptoKey}}arrayBufferToBase64(t){const e=new Uint8Array(t);let a="";for(let s=0;s<e.byteLength;s++)a+=String.fromCharCode(e[s]);return btoa(a)}base64ToArrayBuffer(t){const e=atob(t),a=new Uint8Array(e.length);for(let s=0;s<e.length;s++)a[s]=e.charCodeAt(s);return a.buffer}clearSensitiveData(t){if(t instanceof ArrayBuffer){const e=new Uint8Array(t);crypto.getRandomValues(e)}else"string"==typeof t&&(t=null)}async performanceTest(){if(!this.isAvailable())return null;const t=JSON.stringify({test:"performance",data:new Array(1e3).fill("test data for performance testing"),timestamp:Date.now()});try{const e=performance.now();let a;for(let n=0;n<50;n++)a=await this.encrypt(t);const s=performance.now()-e,r=performance.now();for(let t=0;t<50;t++)await this.decrypt(a);const i=performance.now()-r;return{encryptTime:s/50,decryptTime:i/50,totalTime:s+i,dataSize:t.length,encryptedSize:a.length,compressionRatio:a.length/t.length,iterations:50}}catch(e){return null}}}class e{constructor(){this.compressionFormat="gzip",this.textEncoder=new TextEncoder,this.textDecoder=new TextDecoder}async compress(t){try{return"CompressionStream"in window?await this.compressWithStream(t):await this.compressWithLZString(t)}catch(e){return t}}async decompress(t){try{return"DecompressionStream"in window&&this.isNativeCompressed(t)?await this.decompressWithStream(t):await this.decompressWithLZString(t)}catch(e){return t}}async compressWithStream(t){const e=new CompressionStream(this.compressionFormat),a=e.writable.getWriter(),s=e.readable.getReader(),r=this.textEncoder.encode(t);a.write(r),a.close();const i=[];let n=!1;for(;!n;){const{value:t,done:e}=await s.read();n=e,t&&i.push(t)}const o=i.reduce((t,e)=>t+e.length,0),c=new Uint8Array(o);let l=0;for(const h of i)c.set(h,l),l+=h.length;return"NATIVE_GZIP:"+this.arrayBufferToBase64(c.buffer)}async decompressWithStream(t){const e=t.replace("NATIVE_GZIP:",""),a=this.base64ToArrayBuffer(e),s=new DecompressionStream(this.compressionFormat),r=s.writable.getWriter(),i=s.readable.getReader();r.write(new Uint8Array(a)),r.close();const n=[];let o=!1;for(;!o;){const{value:t,done:e}=await i.read();o=e,t&&n.push(t)}const c=n.reduce((t,e)=>t+e.length,0),l=new Uint8Array(c);let h=0;for(const u of n)l.set(u,h),h+=u.length;return this.textDecoder.decode(l)}async compressWithLZString(t){const e=new Map,a=[];let s=256;for(let n=0;n<256;n++)e.set(String.fromCharCode(n),n);let r="";for(let n=0;n<t.length;n++){const i=t[n],o=r+i;e.has(o)?r=o:(a.push(e.get(r)),e.set(o,s++),r=i)}r&&a.push(e.get(r));const i=new Uint16Array(a);return"LZ_STRING:"+this.arrayBufferToBase64(i.buffer)}async decompressWithLZString(t){const e=t.replace("LZ_STRING:",""),a=this.base64ToArrayBuffer(e),s=new Uint16Array(a),r=new Map;let i=256;for(let c=0;c<256;c++)r.set(c,String.fromCharCode(c));let n="",o=String.fromCharCode(s[0]);n+=o;for(let c=1;c<s.length;c++){const t=s[c];let e;if(r.has(t))e=r.get(t);else{if(t!==i)throw new Error("Invalid compressed data");e=o+o[0]}n+=e,r.set(i++,o+e[0]),o=e}return n}isNativeCompressed(t){return"string"==typeof t&&t.startsWith("NATIVE_GZIP:")}isLZStringCompressed(t){return"string"==typeof t&&t.startsWith("LZ_STRING:")}isCompressed(t){return this.isNativeCompressed(t)||this.isLZStringCompressed(t)}getCompressionRatio(t,e){const a=new Blob([t]).size;return new Blob([e]).size/a}async estimateCompressionBenefit(t){try{const e=new Blob([t]).size,a=await this.compress(t),s=new Blob([a]).size;return{originalSize:e,compressedSize:s,ratio:s/e,savings:e-s,savingsPercentage:(e-s)/e*100,worthCompressing:s<.9*e}}catch(e){return{originalSize:new Blob([t]).size,compressedSize:new Blob([t]).size,ratio:1,savings:0,savingsPercentage:0,worthCompressing:!1,error:e.message}}}isAvailable(){return"CompressionStream"in window||!0}getInfo(){return{nativeCompressionAvailable:"CompressionStream"in window,fallbackAvailable:!0,defaultFormat:this.compressionFormat,available:this.isAvailable()}}async performanceTest(){const t=JSON.stringify({test:"compression performance",data:new Array(1e3).fill("This is test data for compression performance testing. ".repeat(10)),numbers:new Array(100).fill(0).map((t,e)=>e),timestamp:Date.now()});try{const e=performance.now();let a;for(let o=0;o<20;o++)a=await this.compress(t);const s=performance.now()-e,r=performance.now();for(let t=0;t<20;t++)await this.decompress(a);const i=performance.now()-r,n=this.getCompressionRatio(t,a);return{compressTime:s/20,decompressTime:i/20,totalTime:s+i,originalSize:t.length,compressedSize:a.length,compressionRatio:n,savingsPercentage:100*(1-n),iterations:20,method:this.isNativeCompressed(a)?"native":"lz-string"}}catch(e){return null}}arrayBufferToBase64(t){const e=new Uint8Array(t);let a="";for(let s=0;s<e.byteLength;s++)a+=String.fromCharCode(e[s]);return btoa(a)}base64ToArrayBuffer(t){const e=atob(t),a=new Uint8Array(e.length);for(let s=0;s<e.length;s++)a[s]=e.charCodeAt(s);return a.buffer}}class a{constructor(){this.prefix="financeanalyst_",this.isAvailable=!1,this.maxSize=5242880,this.cryptoUtils=new t,this.compressionUtils=new e}async initialize(){try{const t=this.prefix+"test";return localStorage.setItem(t,"test"),localStorage.removeItem(t),this.isAvailable=!0,{success:!0,available:!0}}catch(t){return this.isAvailable=!1,{success:!1,available:!1,error:t.message}}}async store(t,e,a={}){if(!this.isAvailable)throw new Error("localStorage is not available");const{encrypt:s=!1,compress:r=!1,ttl:i=null,validate:n=!0}=a;try{if(n&&!this.validateData(e))throw new Error("Invalid data format");const a={data:e,metadata:{timestamp:Date.now(),version:"1.0",encrypted:s,compressed:r,ttl:i,originalSize:JSON.stringify(e).length}};let o=JSON.stringify(a);if(r&&(o=await this.compressionUtils.compress(o),a.metadata.compressedSize=o.length),s&&(o=await this.cryptoUtils.encrypt(o)),o.length>this.maxSize)throw new Error(`Data too large: ${o.length} bytes exceeds ${this.maxSize} bytes`);const c=this.prefix+t;return localStorage.setItem(c,o),{success:!0,key:c,size:o.length,metadata:a.metadata}}catch(o){throw o}}async retrieve(t,e={}){if(!this.isAvailable)return null;const{decrypt:a=!1,validateTTL:s=!0}=e;try{const e=this.prefix+t;let n,o=localStorage.getItem(e);if(!o)return null;a&&(o=await this.cryptoUtils.decrypt(o));try{n=JSON.parse(o)}catch(r){try{const t=await this.compressionUtils.decompress(o);n=JSON.parse(t)}catch(i){throw new Error("Failed to parse stored data")}}if(s&&n.metadata&&n.metadata.ttl){if(Date.now()>n.metadata.timestamp+n.metadata.ttl)return await this.remove(t),null}return{data:n.data,metadata:n.metadata}}catch(n){return null}}async remove(t){if(!this.isAvailable)return!1;try{const e=this.prefix+t;return localStorage.removeItem(e),!0}catch(e){return!1}}async clear(){if(!this.isAvailable)return!1;try{return Object.keys(localStorage).filter(t=>t.startsWith(this.prefix)).forEach(t=>{localStorage.removeItem(t)}),!0}catch(t){return!1}}async getKeys(){if(!this.isAvailable)return[];try{return Object.keys(localStorage).filter(t=>t.startsWith(this.prefix)).map(t=>t.substring(this.prefix.length))}catch(t){return[]}}async getStats(){if(!this.isAvailable)return{available:!1,used:0,keys:0};try{const t=await this.getKeys();let e=0,a=0;const s={};for(const r of t){const t=this.prefix+r,i=localStorage.getItem(t);if(i){const t=i.length;e+=t,a++,s[r]=t}}return{available:!0,used:e,keys:a,maxSize:this.maxSize,usagePercentage:e/this.maxSize*100,itemSizes:s,largestItem:Object.entries(s).reduce((t,[e,a])=>a>t.size?{key:e,size:a}:t,{key:null,size:0})}}catch(t){return{available:!1,used:0,keys:0,error:t.message}}}async exportAll(){if(!this.isAvailable)return{};try{const t=await this.getKeys(),e={};for(const a of t){const t=await this.retrieve(a,{validateTTL:!1});t&&(e[a]=t)}return e}catch(t){return{}}}async importData(t,e={}){if(!this.isAvailable)throw new Error("localStorage is not available");const{overwrite:a=!1}=e;try{const e={imported:0,skipped:0,errors:0};for(const[r,i]of Object.entries(t))try{if(await this.retrieve(r,{validateTTL:!1})&&!a){e.skipped++;continue}await this.store(r,i.data,{encrypt:i.metadata?.encrypted||!1,compress:i.metadata?.compressed||!1,ttl:i.metadata?.ttl||null}),e.imported++}catch(s){e.errors++}return e}catch(s){throw s}}async hasSpace(t){if(!this.isAvailable)return!1;try{return(await this.getStats()).used+t<=this.maxSize}catch(e){return!1}}async cleanup(){if(!this.isAvailable)return{cleaned:0};try{const t=await this.getKeys();let e=0;for(const a of t)await this.retrieve(a,{validateTTL:!0})||e++;return{cleaned:e}}catch(t){return{cleaned:0,error:t.message}}}validateData(t){try{JSON.stringify(t);const e=new WeakSet,a=t=>{if(null!==t&&"object"==typeof t){if(e.has(t))return!1;e.add(t);for(const e in t)if(!a(t[e]))return!1}return!0};return a(t)}catch(e){return!1}}isStorageAvailable(){return this.isAvailable}async performanceTest(){if(!this.isAvailable)return null;const t={test:"performance",data:new Array(1e3).fill("test")},e=100;try{const a=performance.now();for(let n=0;n<e;n++)await this.store(`perf_test_${n}`,t);const s=performance.now()-a,r=performance.now();for(let t=0;t<e;t++)await this.retrieve(`perf_test_${t}`);const i=performance.now()-r;for(let t=0;t<e;t++)await this.remove(`perf_test_${t}`);return{writeTime:s/e,readTime:i/e,totalTime:s+i,iterations:e}}catch(a){return null}}}class s{constructor(){this.dbName="FinanceAnalystPro",this.dbVersion=1,this.db=null,this.isAvailable=!1,this.compressionUtils=new e,this.stores={watchlists:{keyPath:"id",autoIncrement:!0,indexes:[{name:"name",keyPath:"name",unique:!0},{name:"created",keyPath:"created"},{name:"lastUpdated",keyPath:"lastUpdated"}]},analysis_history:{keyPath:"id",autoIncrement:!0,indexes:[{name:"ticker",keyPath:"ticker"},{name:"analysisType",keyPath:"analysisType"},{name:"timestamp",keyPath:"timestamp"}]},command_history:{keyPath:"id",autoIncrement:!0,indexes:[{name:"command",keyPath:"command"},{name:"timestamp",keyPath:"timestamp"},{name:"success",keyPath:"success"}]},alerts:{keyPath:"id",autoIncrement:!0,indexes:[{name:"ticker",keyPath:"ticker"},{name:"condition",keyPath:"condition"},{name:"created",keyPath:"created"},{name:"triggered",keyPath:"triggered"}]},cached_data:{keyPath:"key",indexes:[{name:"timestamp",keyPath:"timestamp"},{name:"expiry",keyPath:"expiry"},{name:"dataType",keyPath:"dataType"}]},user_models:{keyPath:"id",autoIncrement:!0,indexes:[{name:"name",keyPath:"name"},{name:"type",keyPath:"type"},{name:"created",keyPath:"created"}]},export_data:{keyPath:"id",autoIncrement:!0,indexes:[{name:"timestamp",keyPath:"timestamp"},{name:"type",keyPath:"type"}]}}}async initialize(){if(!window.indexedDB)return this.isAvailable=!1,{success:!1,available:!1};try{return this.db=await this.openDatabase(),this.isAvailable=!0,await this.cleanupExpiredData(),{success:!0,available:!0,version:this.dbVersion}}catch(t){return this.isAvailable=!1,{success:!1,available:!1,error:t.message}}}async openDatabase(){return new Promise((t,e)=>{const a=indexedDB.open(this.dbName,this.dbVersion);a.onerror=()=>{e(new Error(`Failed to open database: ${a.error}`))},a.onsuccess=()=>{t(a.result)},a.onupgradeneeded=t=>{const e=t.target.result;this.createObjectStores(e)}})}createObjectStores(t){for(const e of Object.keys(this.stores))t.objectStoreNames.contains(e)&&t.deleteObjectStore(e);for(const[e,a]of Object.entries(this.stores)){const s=t.createObjectStore(e,{keyPath:a.keyPath,autoIncrement:a.autoIncrement});a.indexes&&a.indexes.forEach(t=>{s.createIndex(t.name,t.keyPath,{unique:t.unique||!1})})}}async store(t,e,a={}){if(!this.isAvailable)throw new Error("IndexedDB is not available");const{storeName:s="cached_data",metadata:r={},compress:i=!1}=a;try{const a={key:t,data:e,timestamp:Date.now(),metadata:{...r,compressed:i,originalSize:JSON.stringify(e).length}};if(i){const t=await this.compressionUtils.compress(JSON.stringify(e));a.data=t,a.metadata.compressedSize=t.length}return{success:!0,key:await this.performTransaction(s,"readwrite",t=>t.put(a)),storeName:s,size:JSON.stringify(a).length,metadata:a.metadata}}catch(n){throw n}}async retrieve(t,e={}){if(!this.isAvailable)return null;const{storeName:a="cached_data"}=e;try{const e=await this.performTransaction(a,"readonly",e=>e.get(t));if(!e)return null;if(e.metadata&&e.metadata.expiry&&Date.now()>e.metadata.expiry)return await this.remove(t,{storeName:a}),null;let s=e.data;return e.metadata&&e.metadata.compressed&&(s=JSON.parse(await this.compressionUtils.decompress(s))),{data:s,metadata:e.metadata,timestamp:e.timestamp}}catch(s){return null}}async remove(t,e={}){if(!this.isAvailable)return!1;const{storeName:a="cached_data"}=e;try{return await this.performTransaction(a,"readwrite",e=>e.delete(t)),!0}catch(s){return!1}}async clear(t=null){if(!this.isAvailable)return!1;try{if(t)await this.performTransaction(t,"readwrite",t=>t.clear());else for(const t of Object.keys(this.stores))await this.performTransaction(t,"readwrite",t=>t.clear());return!0}catch(e){return!1}}async getKeys(t="cached_data"){if(!this.isAvailable)return[];try{return await this.performTransaction(t,"readonly",t=>t.getAllKeys())}catch(e){return[]}}async getAll(t="cached_data",e={}){if(!this.isAvailable)return[];const{limit:a=null,filter:s=null}=e;try{const e=await this.performTransaction(t,"readonly",t=>t.getAll());let r=e;return s&&(r=e.filter(s)),a&&(r=r.slice(0,a)),r}catch(r){return[]}}async query(t,e,a,s={}){if(!this.isAvailable)return[];const{limit:r=null}=s;try{return await this.performTransaction(t,"readonly",t=>{const s=t.index(e);return r?s.getAll(a,r):s.getAll(a)})}catch(i){return[]}}async getStats(){if(!this.isAvailable)return{available:!1,stores:{},total:{records:0,size:0}};try{const t={available:!0,stores:{},total:{records:0,size:0}};for(const e of Object.keys(this.stores)){const a=await this.getAll(e),s=a.length,r=a.reduce((t,e)=>t+JSON.stringify(e).length,0);t.stores[e]={records:s,size:r},t.total.records+=s,t.total.size+=r}return t}catch(t){return{available:!1,error:t.message}}}async exportAll(){if(!this.isAvailable)return{};try{const t={};for(const e of Object.keys(this.stores))t[e]=await this.getAll(e);return t}catch(t){return{}}}async importData(t,e={}){if(!this.isAvailable)throw new Error("IndexedDB is not available");const{overwrite:a=!1}=e;try{const e={imported:0,skipped:0,errors:0};for(const[r,i]of Object.entries(t))if(this.stores[r])for(const t of i)try{if(!a&&await this.retrieve(t.key||t.id,{storeName:r})){e.skipped++;continue}await this.performTransaction(r,"readwrite",e=>e.put(t)),e.imported++}catch(s){e.errors++}return e}catch(s){throw s}}async cleanupExpiredData(){if(!this.isAvailable)return{cleaned:0};try{let t=0;const e=Date.now(),a=await this.getAll("cached_data");for(const s of a)s.metadata&&s.metadata.expiry&&e>s.metadata.expiry&&(await this.remove(s.key,{storeName:"cached_data"}),t++);return{cleaned:t}}catch(t){return{cleaned:0,error:t.message}}}async performTransaction(t,e,a){return new Promise((s,r)=>{const i=this.db.transaction([t],e),n=i.objectStore(t);i.onerror=()=>{r(new Error(`Transaction failed: ${i.error}`))},i.oncomplete=()=>{};const o=a(n);o.onsuccess=()=>{s(o.result)},o.onerror=()=>{r(new Error(`Operation failed: ${o.error}`))}})}isStorageAvailable(){return this.isAvailable}getInfo(){return{dbName:this.dbName,dbVersion:this.dbVersion,available:this.isAvailable,stores:Object.keys(this.stores),storeCount:Object.keys(this.stores).length}}}class r{constructor(){this.sessionKey="financeanalyst_session",this.userKey="financeanalyst_user",this.preferencesKey="financeanalyst_preferences",this.cryptoUtils=new t,this.currentSession=null,this.currentUser=null,this.sessionTimeout=864e5,this.listeners=new Set,this.defaultPreferences={currency:"USD",precision:2,dateFormat:"YYYY-MM-DD",theme:"dark",notifications:!0,autoSave:!0,commandHistory:!0,dataRetention:30,privacy:{analytics:!1,crashReporting:!0,dataSharing:!1}}}async initialize(){try{return await this.loadSession(),this.setupSessionMonitoring(),{success:!0,hasSession:!!this.currentSession}}catch(t){return{success:!1,error:t.message}}}async createSession(t={}){try{const e=this.generateSessionId(),a=Date.now(),s={id:e,userId:t.id||this.generateUserId(),created:a,lastActivity:a,expires:a+this.sessionTimeout,userAgent:navigator.userAgent,platform:navigator.platform,language:navigator.language,timezone:Intl.DateTimeFormat().resolvedOptions().timeZone,version:"1.0"},r={id:s.userId,name:t.name||"Anonymous User",email:t.email||null,created:t.created||a,lastLogin:a,loginCount:(t.loginCount||0)+1,preferences:{...this.defaultPreferences,...t.preferences}};return await this.storeSession(s),await this.storeUser(r),this.currentSession=s,this.currentUser=r,this.notifyListeners("sessionCreated",{session:s,user:r}),{success:!0,session:s,user:r}}catch(e){throw e}}async loadSession(){try{const t=localStorage.getItem(this.sessionKey),e=localStorage.getItem(this.userKey);if(!t||!e)return null;const a=JSON.parse(t),s=JSON.parse(e);return Date.now()>a.expires?(await this.destroySession(),null):(a.lastActivity=Date.now(),await this.storeSession(a),this.currentSession=a,this.currentUser=s,this.notifyListeners("sessionLoaded",{session:a,user:s}),{session:a,user:s})}catch(t){return await this.destroySession(),null}}async updateActivity(){if(!this.currentSession)return!1;try{return this.currentSession.lastActivity=Date.now(),this.currentSession.expires-Date.now()<.1*this.sessionTimeout&&(this.currentSession.expires=Date.now()+this.sessionTimeout),await this.storeSession(this.currentSession),!0}catch(t){return!1}}async destroySession(){try{const t=this.currentSession,e=this.currentUser;return localStorage.removeItem(this.sessionKey),this.currentSession=null,this.currentUser=null,this.notifyListeners("sessionDestroyed",{session:t,user:e}),!0}catch(t){return!1}}getSession(){return this.currentSession}getUser(){return this.currentUser}isAuthenticated(){return!!(this.currentSession&&Date.now()<this.currentSession.expires)}getPreferences(){return this.currentUser?this.currentUser.preferences:this.defaultPreferences}async updatePreferences(t){if(!this.currentUser)throw new Error("No active user session");try{return this.currentUser.preferences={...this.currentUser.preferences,...t},await this.storeUser(this.currentUser),localStorage.setItem(this.preferencesKey,JSON.stringify(this.currentUser.preferences)),this.notifyListeners("preferencesUpdated",{preferences:this.currentUser.preferences}),this.currentUser.preferences}catch(e){throw e}}getSessionStats(){if(!this.currentSession||!this.currentUser)return null;const t=Date.now(),e=t-this.currentSession.created,a=this.currentSession.expires-t,s=t-this.currentSession.lastActivity;return{sessionId:this.currentSession.id,userId:this.currentUser.id,userName:this.currentUser.name,sessionDuration:e,timeUntilExpiry:a,lastActivityAge:s,loginCount:this.currentUser.loginCount,userCreated:this.currentUser.created,isExpired:a<=0,isActive:s<3e5}}async exportSessionData(){return this.currentSession&&this.currentUser?{session:{...this.currentSession},user:{...this.currentUser},preferences:{...this.currentUser.preferences},exportTimestamp:Date.now()}:null}async importSessionData(t){try{if(!t||!t.session||!t.user)throw new Error("Invalid session data format");const e=t.session,a=t.user;return e.lastActivity=Date.now(),e.expires=Date.now()+this.sessionTimeout,a.lastLogin=Date.now(),await this.storeSession(e),await this.storeUser(a),this.currentSession=e,this.currentUser=a,this.notifyListeners("sessionImported",{session:e,user:a}),{success:!0,session:e,user:a}}catch(e){throw e}}addEventListener(t){this.listeners.add(t)}removeEventListener(t){this.listeners.delete(t)}async storeSession(t){try{localStorage.setItem(this.sessionKey,JSON.stringify(t))}catch(e){throw e}}async storeUser(t){try{localStorage.setItem(this.userKey,JSON.stringify(t))}catch(e){throw e}}generateSessionId(){return"sess_"+Date.now()+"_"+Math.random().toString(36).substr(2,9)}generateUserId(){return"user_"+Date.now()+"_"+Math.random().toString(36).substr(2,9)}setupSessionMonitoring(){let t=Date.now();const e=this.throttle(()=>{const e=Date.now();e-t>6e4&&(this.updateActivity(),t=e)},1e3);["click","keypress","scroll","mousemove"].forEach(t=>{document.addEventListener(t,e,{passive:!0})}),setInterval(()=>{this.currentSession&&Date.now()>this.currentSession.expires&&this.destroySession()},6e4),document.addEventListener("visibilitychange",()=>{document.hidden||this.updateActivity()}),window.addEventListener("beforeunload",()=>{this.updateActivity()})}throttle(t,e){let a;return function(){const s=arguments;a||(t.apply(this,s),a=!0,setTimeout(()=>a=!1,e))}}notifyListeners(t,e){this.listeners.forEach(a=>{try{a(t,e)}catch(s){}})}}class i{constructor(){this.currentVersion="1.0.0",this.migrationKey="financeanalyst_migration_version",this.backupKey="financeanalyst_migration_backup",this.migrations={"0.0.0":{to:"1.0.0",description:"Initial migration to structured persistence layer",migrate:this.migrateToV1_0_0.bind(this)}}}async checkAndMigrate(){try{const t=localStorage.getItem(this.migrationKey);return t?t!==this.currentVersion&&await this.performVersionMigration(t,this.currentVersion):await this.performInitialMigration(),localStorage.setItem(this.migrationKey,this.currentVersion),{success:!0,version:this.currentVersion}}catch(t){return{success:!1,error:t.message}}}async performInitialMigration(){try{const t=await this.detectLegacyData();Object.keys(t).length>0&&(await this.createMigrationBackup(t),await this.migrateToV1_0_0(t))}catch(t){throw t}}async performVersionMigration(t,e){try{const a=this.findMigrationPath(t,e);if(!a.length)throw new Error(`No migration path found from ${t} to ${e}`);const s=await this.exportCurrentData();await this.createMigrationBackup(s,t);for(const t of a)await t.migrate()}catch(a){throw await this.restoreFromBackup(),a}}async detectLegacyData(){const t={};try{const e=localStorage.getItem("commandProcessor_variables");e&&(t.variables=JSON.parse(e));const a=localStorage.getItem("commandProcessor_settings");a&&(t.settings=JSON.parse(a));const s=localStorage.getItem("watchlists");s&&(t.watchlists=JSON.parse(s));const r=localStorage.getItem("alerts");return r&&(t.alerts=JSON.parse(r)),Object.keys(localStorage).forEach(e=>{if(e.startsWith("financeanalyst_")&&!e.includes("migration")&&!e.includes("session")&&!e.includes("user")&&!e.includes("crypto_key"))try{t[e]=JSON.parse(localStorage.getItem(e))}catch(a){t[e]=localStorage.getItem(e)}}),t}catch(e){return{}}}async migrateToV1_0_0(t=null){try{const e=t||await this.detectLegacyData();if(e.watchlists){const t=this.migrateWatchlistsFormat(e.watchlists);localStorage.setItem("financeanalyst_watchlists",JSON.stringify(t))}if(e.alerts){const t=this.migrateAlertsFormat(e.alerts);localStorage.setItem("financeanalyst_alerts",JSON.stringify(t))}if(e.settings){const t=this.migratePreferencesFormat(e.settings);localStorage.setItem("financeanalyst_preferences",JSON.stringify(t))}if(e.variables){const t=this.migrateVariablesFormat(e.variables);localStorage.setItem("financeanalyst_user_variables",JSON.stringify(t))}await this.cleanupLegacyData(e)}catch(e){throw e}}migrateWatchlistsFormat(t){const e={};return Array.isArray(t)?t.forEach((t,a)=>{const s=t.name||`Watchlist ${a+1}`;e[s]={tickers:t.tickers||t.stocks||[],created:t.created||(new Date).toISOString().split("T")[0],lastUpdated:t.lastUpdated||null}}):"object"==typeof t&&Object.entries(t).forEach(([t,a])=>{e[t]={tickers:a.tickers||a.stocks||[],created:a.created||(new Date).toISOString().split("T")[0],lastUpdated:a.lastUpdated||null}}),e}migrateAlertsFormat(t){return Array.isArray(t)?t.map(t=>({id:t.id||Date.now()+Math.random(),ticker:t.ticker,condition:t.condition,value:t.value,created:t.created||(new Date).toISOString().split("T")[0],triggered:t.triggered||!1})):[]}migratePreferencesFormat(t){return{currency:t.currency||"USD",precision:t.precision||2,dateFormat:t.dateFormat||"YYYY-MM-DD",theme:t.theme||"dark",notifications:!1!==t.notifications,autoSave:!1!==t.autoSave,commandHistory:!1!==t.commandHistory,dataRetention:t.dataRetention||30,privacy:{analytics:t.analytics||!1,crashReporting:!1!==t.crashReporting,dataSharing:t.dataSharing||!1}}}migrateVariablesFormat(t){return{...t}}async cleanupLegacyData(t){try{["commandProcessor_variables","commandProcessor_settings","watchlists","alerts"].forEach(t=>{localStorage.getItem(t)&&localStorage.removeItem(t)}),Object.keys(t).forEach(t=>{!t.startsWith("financeanalyst_")||t.includes("migration")||t.includes("session")||t.includes("user")||t.includes("crypto_key")||localStorage.removeItem(t)})}catch(e){}}async createMigrationBackup(t,e="legacy"){try{const a={version:e,timestamp:(new Date).toISOString(),data:t};localStorage.setItem(this.backupKey,JSON.stringify(a))}catch(a){}}async restoreFromBackup(){try{const t=localStorage.getItem(this.backupKey);if(!t)throw new Error("No migration backup found");const e=JSON.parse(t);return"legacy"===e.version&&Object.entries(e.data).forEach(([t,e])=>{localStorage.setItem(t,"string"==typeof e?e:JSON.stringify(e))}),!0}catch(t){return!1}}async exportCurrentData(){const t={};return Object.keys(localStorage).forEach(e=>{if(e.startsWith("financeanalyst_"))try{t[e]=JSON.parse(localStorage.getItem(e))}catch(a){t[e]=localStorage.getItem(e)}}),t}findMigrationPath(t,e){const a=this.migrations[t];return a&&a.to===e?[a]:[]}getMigrationStatus(){const t=localStorage.getItem(this.migrationKey),e=!!localStorage.getItem(this.backupKey);return{currentVersion:this.currentVersion,storedVersion:t,needsMigration:t!==this.currentVersion,hasBackup:e,availableMigrations:Object.keys(this.migrations)}}clearBackup(){localStorage.removeItem(this.backupKey)}}const n=new class{constructor(){this.localStorage=new a,this.indexedDB=new s,this.sessionManager=new r,this.migrationService=new i,this.isInitialized=!1,this.storageQuota=null,this.listeners=new Map,this.storageStrategy={localStorage:["user_preferences","session_data","ui_state","recent_commands","quick_settings"],indexedDB:["watchlists","analysis_history","command_history","alerts","cached_data","user_models","export_data"]}}async initialize(){if(!this.isInitialized)try{return await this.checkStorageAvailability(),await Promise.all([this.localStorage.initialize(),this.indexedDB.initialize(),this.sessionManager.initialize()]),await this.migrationService.checkAndMigrate(),await this.estimateStorageQuota(),this.isInitialized=!0,{success:!0,storageQuota:this.storageQuota,availableStorage:await this.getAvailableStorage()}}catch(t){throw new Error(`Persistence initialization failed: ${t.message}`)}}async store(t,e,a={}){await this.ensureInitialized();const{storage:s=this.determineStorageLayer(t),encrypt:r=!1,compress:i=!1,ttl:n=null}=a;try{const a={timestamp:Date.now(),version:"1.0",encrypted:r,compressed:i,ttl:n,size:JSON.stringify(e).length};let o;if("localStorage"===s)o=await this.localStorage.store(t,e,{encrypt:r,ttl:n});else{if("indexedDB"!==s)throw new Error(`Unknown storage layer: ${s}`);o=await this.indexedDB.store(t,e,{metadata:a,compress:i})}return this.notifyListeners("store",{key:t,storage:s,metadata:a}),o}catch(o){throw o}}async retrieve(t,e={}){await this.ensureInitialized();const{storage:a=this.determineStorageLayer(t),decrypt:s=!1}=e;try{let e;if(e="localStorage"===a?await this.localStorage.retrieve(t,{decrypt:s}):"indexedDB"===a?await this.indexedDB.retrieve(t):await this.localStorage.retrieve(t,{decrypt:s})||await this.indexedDB.retrieve(t),e&&e.metadata&&e.metadata.ttl){if(Date.now()>e.metadata.timestamp+e.metadata.ttl)return await this.remove(t,{storage:a}),null}return e?e.data||e:null}catch(r){return null}}async remove(t,e={}){await this.ensureInitialized();const{storage:a="both"}=e;try{const e=[];return"localStorage"!==a&&"both"!==a||e.push(this.localStorage.remove(t)),"indexedDB"!==a&&"both"!==a||e.push(this.indexedDB.remove(t)),await Promise.all(e),this.notifyListeners("remove",{key:t,storage:a}),!0}catch(s){throw s}}async clear(t={}){await this.ensureInitialized();const{storage:e="both",confirm:a=!1}=t;if(!a)throw new Error("Clear operation requires explicit confirmation");try{const t=[];return"localStorage"!==e&&"both"!==e||t.push(this.localStorage.clear()),"indexedDB"!==e&&"both"!==e||t.push(this.indexedDB.clear()),await Promise.all(t),this.notifyListeners("clear",{storage:e}),!0}catch(s){throw s}}async getStorageStats(){await this.ensureInitialized();try{const[t,e]=await Promise.all([this.localStorage.getStats(),this.indexedDB.getStats()]),a=t.used+e.used;return{localStorage:t,indexedDB:e,total:{used:a,available:await this.getAvailableStorage(),quota:this.storageQuota,usagePercentage:this.storageQuota?a/this.storageQuota*100:0}}}catch(t){return null}}async exportData(t={}){await this.ensureInitialized();const{format:e="json",includeMetadata:a=!0,compress:s=!1}=t;try{const[s,r]=await Promise.all([this.localStorage.exportAll(),this.indexedDB.exportAll()]),i={version:"1.0",timestamp:(new Date).toISOString(),localStorage:s,indexedDB:r};return a&&(i.metadata={userAgent:navigator.userAgent,storageStats:await this.getStorageStats(),exportOptions:t}),{data:i,size:JSON.stringify(i).length,format:e}}catch(r){throw r}}async importData(t,e={}){await this.ensureInitialized();const{overwrite:a=!1,validate:s=!0,backup:r=!0}=e;try{if(s&&!this.validateImportData(t))throw new Error("Invalid import data format");if(r){const t=await this.exportData();await this.store("backup_before_import",t,{storage:"indexedDB",ttl:6048e5})}return t.localStorage&&await this.localStorage.importData(t.localStorage,{overwrite:a}),t.indexedDB&&await this.indexedDB.importData(t.indexedDB,{overwrite:a}),this.notifyListeners("import",{size:JSON.stringify(t).length}),{success:!0,imported:{localStorage:Object.keys(t.localStorage||{}).length,indexedDB:Object.keys(t.indexedDB||{}).length}}}catch(i){throw i}}addEventListener(t,e){this.listeners.has(t)||this.listeners.set(t,new Set),this.listeners.get(t).add(e)}removeEventListener(t,e){this.listeners.has(t)&&this.listeners.get(t).delete(e)}async ensureInitialized(){this.isInitialized||await this.initialize()}determineStorageLayer(t){return this.storageStrategy.localStorage.includes(t)?"localStorage":this.storageStrategy.indexedDB.includes(t)?"indexedDB":"localStorage"}async checkStorageAvailability(){if(!window.localStorage)throw new Error("localStorage is not available");if(!window.indexedDB)throw new Error("IndexedDB is not available");return!0}async estimateStorageQuota(){if("storage"in navigator&&"estimate"in navigator.storage){const t=await navigator.storage.estimate();return this.storageQuota=t.quota,t}return null}async getAvailableStorage(){if("storage"in navigator&&"estimate"in navigator.storage){const t=await navigator.storage.estimate();return t.quota-t.usage}return null}validateImportData(t){return t&&"object"==typeof t&&t.version&&(t.localStorage||t.indexedDB)}notifyListeners(t,e){this.listeners.has(t)&&this.listeners.get(t).forEach(t=>{try{t(e)}catch(a){}})}},o=new class{constructor(){this.cryptoUtils=new t,this.compressionUtils=new e,this.backupVersion="1.0.0",this.maxBackupSize=52428800,this.maxBackups=10}async createBackup(t={}){const{includeSettings:e=!0,includeWatchlists:a=!0,includeAlerts:s=!0,includeHistory:r=!0,includeCachedData:i=!1,encrypt:o=!1,compress:c=!0,description:l=""}=t;try{await n.ensureInitialized();const t={version:this.backupVersion,timestamp:(new Date).toISOString(),description:l,metadata:{userAgent:navigator.userAgent,platform:navigator.platform,language:navigator.language,timezone:Intl.DateTimeFormat().resolvedOptions().timeZone},data:{}};e&&(t.data.settings=await n.retrieve("user_preferences")||{},t.data.session=await n.retrieve("session_data")||{}),a&&(t.data.watchlists=await n.retrieve("watchlists")||{}),s&&(t.data.alerts=await n.retrieve("alerts")||[]),r&&(t.data.commandHistory=await n.retrieve("command_history")||[],t.data.analysisHistory=await n.retrieve("analysis_history")||[]),i&&(t.data.cachedData=await n.retrieve("cached_data")||{});let h=JSON.stringify(t);const u=h.length;if(u>this.maxBackupSize)throw new Error(`Backup too large: ${u} bytes exceeds ${this.maxBackupSize} bytes`);c&&(h=await this.compressionUtils.compress(h),t.metadata.compressed=!0,t.metadata.compressionRatio=h.length/u),o&&(h=await this.cryptoUtils.encrypt(h),t.metadata.encrypted=!0);const d=this.generateBackupId();return await this.storeBackup(d,h,t.metadata),await this.cleanupOldBackups(),{success:!0,backupId:d,size:h.length,originalSize:u,metadata:t.metadata,timestamp:t.timestamp}}catch(h){throw h}}async restoreBackup(t,e={}){const{overwrite:a=!1,selectiveRestore:s=null,createBackupBeforeRestore:r=!0}=e;try{await n.ensureInitialized(),r&&await this.createBackup({description:`Auto-backup before restore from ${t}`,compress:!0});const e=await this.retrieveBackup(t);if(!e)throw new Error(`Backup ${t} not found`);let o=e.data;const c=e.metadata;c.encrypted&&(o=await this.cryptoUtils.decrypt(o)),c.compressed&&(o=await this.compressionUtils.decompress(o));const l=JSON.parse(o);if(!this.isVersionCompatible(l.version))throw new Error(`Backup version ${l.version} is not compatible with current version ${this.backupVersion}`);const h=s?this.filterBackupData(l.data,s):l.data,u={restored:0,skipped:0,errors:0,details:{}};for(const[t,s]of Object.entries(h))try{if(await n.retrieve(t)&&!a){u.skipped++,u.details[t]="skipped (exists)";continue}await n.store(t,s,{storage:this.determineStorageType(t)}),u.restored++,u.details[t]="restored"}catch(i){u.errors++,u.details[t]=`error: ${i.message}`}return{success:!0,backupId:t,backupTimestamp:l.timestamp,restoreTimestamp:(new Date).toISOString(),results:u}}catch(i){throw i}}async listBackups(){try{const t=await n.indexedDB.getKeys("export_data"),e=[];for(const a of t)if(a.startsWith("backup_")){const t=await n.indexedDB.retrieve(a,{storeName:"export_data"});t&&e.push({id:a,timestamp:t.metadata.timestamp,description:t.metadata.description||"",size:t.metadata.size||0,compressed:t.metadata.compressed||!1,encrypted:t.metadata.encrypted||!1})}return e.sort((t,e)=>new Date(e.timestamp)-new Date(t.timestamp)),e}catch(t){return[]}}async deleteBackup(t){try{return await n.indexedDB.remove(t,{storeName:"export_data"}),!0}catch(e){return!1}}async exportBackupToFile(t,e=null){try{const a=await this.retrieveBackup(t);if(!a)throw new Error(`Backup ${t} not found`);const s={backupId:t,...a},r=JSON.stringify(s,null,2),i=new Blob([r],{type:"application/json"});return{blob:i,filename:e||`financeanalyst_backup_${t}_${(new Date).toISOString().split("T")[0]}.json`,size:i.size,type:"application/json"}}catch(a){throw a}}async importBackupFromFile(t){try{const e=JSON.parse(t);if(!e.backupId||!e.data||!e.metadata)throw new Error("Invalid backup file format");return await this.storeBackup(e.backupId,e.data,e.metadata),{success:!0,backupId:e.backupId,timestamp:e.metadata.timestamp}}catch(e){throw e}}async getBackupStats(){try{const t=await this.listBackups();return{totalBackups:t.length,totalSize:t.reduce((t,e)=>t+(e.size||0),0),oldestBackup:t.length>0?t[t.length-1].timestamp:null,newestBackup:t.length>0?t[0].timestamp:null,encryptedBackups:t.filter(t=>t.encrypted).length,compressedBackups:t.filter(t=>t.compressed).length}}catch(t){return null}}async storeBackup(t,e,a){const s={id:t,data:e,metadata:{...a,timestamp:(new Date).toISOString(),size:e.length},timestamp:Date.now(),type:"backup"};await n.indexedDB.store(t,s,{storeName:"export_data",metadata:s.metadata})}async retrieveBackup(t){return await n.indexedDB.retrieve(t,{storeName:"export_data"})}generateBackupId(){return`backup_${Date.now()}_${Math.random().toString(36).substr(2,9)}`}async cleanupOldBackups(){try{const t=await this.listBackups();if(t.length>this.maxBackups){const e=t.slice(this.maxBackups);for(const t of e)await this.deleteBackup(t.id)}}catch(t){}}isVersionCompatible(t){return t===this.backupVersion}filterBackupData(t,e){const a={};return e.forEach(e=>{t[e]&&(a[e]=t[e])}),a}determineStorageType(t){return["settings","session","user_preferences"].includes(t)?"localStorage":"indexedDB"}},c=new class{constructor(){this.retentionPolicies={command_history:30,analysis_history:90,cached_data:7,export_data:30,session_data:1},this.privacySettings={dataRetention:!0,analytics:!1,crashReporting:!0,dataSharing:!1,cookieConsent:!1,trackingConsent:!1},this.dataCategories={essential:["user_preferences","session_data","watchlists","alerts"],functional:["command_history","user_variables"],analytics:["usage_stats","performance_metrics"],marketing:[],external:["cached_data"]}}async initialize(){try{const t=await n.retrieve("privacy_settings");t&&(this.privacySettings={...this.privacySettings,...t});const e=await n.retrieve("retention_policies");return e&&(this.retentionPolicies={...this.retentionPolicies,...e}),this.scheduleCleanup(),{success:!0,settings:this.privacySettings}}catch(t){return{success:!1,error:t.message}}}async updatePrivacySettings(t){try{const e={...this.privacySettings};return this.privacySettings={...this.privacySettings,...t},await n.store("privacy_settings",this.privacySettings,{storage:"localStorage"}),await this.handlePrivacySettingChanges(e,this.privacySettings),{success:!0,settings:this.privacySettings}}catch(e){throw e}}async handlePrivacySettingChanges(t,e){t.dataRetention&&!e.dataRetention&&await this.cleanupNonEssentialData(),t.analytics&&!e.analytics&&await this.cleanupAnalyticsData(),t.dataSharing&&!e.dataSharing&&await this.removeDataSharingMarkers()}async setRetentionPolicy(t,e){try{return this.retentionPolicies[t]=e,await n.store("retention_policies",this.retentionPolicies,{storage:"localStorage"}),await this.cleanupExpiredData(t),{success:!0,policy:{[t]:e}}}catch(a){throw a}}async cleanupExpiredData(t=null){const e={cleaned:0,errors:0,details:{}};try{const s=t?[t]:Object.keys(this.retentionPolicies);for(const t of s){const s=this.retentionPolicies[t];if(s)try{const a=await this.cleanupDataType(t,s);e.cleaned+=a,e.details[t]=a}catch(a){e.errors++,e.details[t]=`Error: ${a.message}`}}return e}catch(a){throw a}}async cleanupDataType(t,e){const a=Date.now()-24*e*60*60*1e3;let s=0;try{switch(t){case"command_history":s=await this.cleanupCommandHistory(a);break;case"analysis_history":s=await this.cleanupAnalysisHistory(a);break;case"cached_data":s=await this.cleanupCachedData(a);break;case"export_data":s=await this.cleanupExportData(a);break;case"session_data":s=await this.cleanupSessionData(a)}return s}catch(r){return 0}}async cleanupCommandHistory(t){const e=await n.retrieve("command_history")||[],a=e.filter(e=>new Date(e.timestamp).getTime()>t);return a.length<e.length?(await n.store("command_history",a,{storage:"indexedDB"}),e.length-a.length):0}async cleanupAnalysisHistory(t){const e=await n.indexedDB.getAll("analysis_history");let a=0;for(const s of e)s.timestamp<t&&(await n.indexedDB.remove(s.id,{storeName:"analysis_history"}),a++);return a}async cleanupCachedData(t){const e=await n.indexedDB.getAll("cached_data");let a=0;for(const s of e)s.timestamp<t&&(await n.indexedDB.remove(s.key,{storeName:"cached_data"}),a++);return a}async cleanupExportData(t){const e=await n.indexedDB.getAll("export_data");let a=0;for(const s of e)s.timestamp<t&&(await n.indexedDB.remove(s.id,{storeName:"export_data"}),a++);return a}async cleanupSessionData(t){return 0}async cleanupNonEssentialData(){const t=[...this.dataCategories.functional,...this.dataCategories.analytics,...this.dataCategories.external];let e=0;for(const s of t)try{"command_history"===s?(await n.store("command_history",[],{storage:"indexedDB"}),e++):"cached_data"===s&&(await n.indexedDB.clear("cached_data"),e++)}catch(a){}return e}async cleanupAnalyticsData(){const t=this.dataCategories.analytics;for(const a of t)try{await n.remove(a)}catch(e){}}async removeDataSharingMarkers(){}async exportUserData(t={}){const{includeEssential:e=!0,includeFunctional:a=!0,includeAnalytics:s=!1,format:r="json"}=t;try{const t={exportTimestamp:(new Date).toISOString(),privacySettings:this.privacySettings,retentionPolicies:this.retentionPolicies,data:{}};if(e)for(const e of this.dataCategories.essential){const a=await n.retrieve(e);a&&(t.data[e]=a)}if(a)for(const e of this.dataCategories.functional){const a=await n.retrieve(e);a&&(t.data[e]=a)}if(s)for(const e of this.dataCategories.analytics){const a=await n.retrieve(e);a&&(t.data[e]=a)}return{success:!0,data:t,size:JSON.stringify(t).length,format:r}}catch(i){throw i}}async deleteAllUserData(t=!1){if(!t)throw new Error("Data deletion requires explicit confirmation");try{const t=await o.createBackup({description:"Final backup before data deletion",compress:!0,encrypt:!0});if(await n.clear({storage:"both",confirm:!0}),localStorage.clear(),window.indexedDB){const t=await indexedDB.databases();for(const e of t)e.name.includes("FinanceAnalyst")&&indexedDB.deleteDatabase(e.name)}return{success:!0,backup:t.backupId,timestamp:(new Date).toISOString()}}catch(e){throw e}}async getPrivacyReport(){try{const t=await n.getStorageStats(),e=await this.cleanupExpiredData();return{privacySettings:this.privacySettings,retentionPolicies:this.retentionPolicies,dataCategories:this.dataCategories,storageStats:t,lastCleanup:e,compliance:{gdprCompliant:this.privacySettings.dataRetention,ccpaCompliant:!this.privacySettings.dataSharing,retentionPoliciesActive:Object.keys(this.retentionPolicies).length>0}}}catch(t){throw t}}scheduleCleanup(){setInterval(async()=>{try{await this.cleanupExpiredData()}catch(t){}},864e5),setTimeout(()=>{this.cleanupExpiredData().catch(t=>{})},5e3)}getPrivacySettings(){return{...this.privacySettings}}getRetentionPolicies(){return{...this.retentionPolicies}}},l=new class{constructor(){this.cryptoUtils=new t,this.syncEndpoint=null,this.syncInterval=3e5,this.lastSyncTime=null,this.syncInProgress=!1,this.conflictResolutionStrategy="client_wins",this.listeners=new Set,this.syncQueue=[],this.maxQueueSize=100}async initialize(t={}){try{this.syncEndpoint=t.endpoint||null,this.syncInterval=t.interval||this.syncInterval,this.conflictResolutionStrategy=t.conflictResolution||this.conflictResolutionStrategy,this.lastSyncTime=await n.retrieve("last_sync_time");const e=await n.retrieve("sync_queue");return e&&Array.isArray(e)&&(this.syncQueue=e),this.syncEndpoint&&this.setupPeriodicSync(),{success:!0,endpoint:this.syncEndpoint}}catch(e){return{success:!1,error:e.message}}}async queueSyncOperation(t){try{const e={id:this.generateOperationId(),type:t.type,dataType:t.dataType,key:t.key,data:t.data,timestamp:Date.now(),retries:0};return this.syncQueue.push(e),this.syncQueue.length>this.maxQueueSize&&(this.syncQueue=this.syncQueue.slice(-this.maxQueueSize)),await n.store("sync_queue",this.syncQueue,{storage:"localStorage"}),navigator.onLine&&this.syncEndpoint&&this.processSyncQueue().catch(t=>{}),e.id}catch(e){throw e}}async processSyncQueue(){if(this.syncInProgress||!this.syncEndpoint||!navigator.onLine)return{processed:0,failed:0};this.syncInProgress=!0;let t=0,e=0;try{const s=[...this.syncQueue];for(const r of s)try{await this.syncOperation(r),this.syncQueue=this.syncQueue.filter(t=>t.id!==r.id),t++}catch(a){r.retries++,r.retries>3&&(this.syncQueue=this.syncQueue.filter(t=>t.id!==r.id),e++)}return await n.store("sync_queue",this.syncQueue,{storage:"localStorage"}),this.lastSyncTime=Date.now(),await n.store("last_sync_time",this.lastSyncTime,{storage:"localStorage"}),this.notifyListeners("syncCompleted",{processed:t,failed:e}),{processed:t,failed:e}}finally{this.syncInProgress=!1}}async syncOperation(t){if(!this.syncEndpoint)throw new Error("No sync endpoint configured");return await new Promise(t=>setTimeout(t,100)),{success:!0,operation:t.id}}async performFullSync(){if(this.syncInProgress||!this.syncEndpoint)return{success:!1,reason:"Sync in progress or no endpoint"};this.syncInProgress=!0;try{const t=await o.createBackup({description:"Pre-sync backup",compress:!0}),e=await this.getLocalSyncData(),a=await this.getRemoteData(),s=await this.resolveConflicts(e,a);return await this.applyMergedData(s),this.lastSyncTime=Date.now(),await n.store("last_sync_time",this.lastSyncTime,{storage:"localStorage"}),this.syncQueue=[],await n.store("sync_queue",this.syncQueue,{storage:"localStorage"}),this.notifyListeners("fullSyncCompleted",{backup:t.backupId}),{success:!0,timestamp:this.lastSyncTime,backup:t.backupId}}catch(t){throw this.notifyListeners("syncFailed",{error:t.message}),t}finally{this.syncInProgress=!1}}async getLocalSyncData(){const t={},e=["watchlists","alerts","user_preferences","user_variables"];for(const a of e){const e=await n.retrieve(a);e&&(t[a]={data:e,lastModified:Date.now(),checksum:await this.calculateChecksum(e)})}return t}async getRemoteData(){return{}}async resolveConflicts(t,e){const a={},s=new Set([...Object.keys(t),...Object.keys(e)]);for(const r of s){const s=t[r],i=e[r];!s&&i?a[r]=i:s&&!i?a[r]=s:s&&i&&(a[r]=await this.resolveDataConflict(r,s,i))}return a}async resolveDataConflict(t,e,a){switch(this.conflictResolutionStrategy){case"client_wins":default:return e;case"server_wins":return a;case"merge":return await this.mergeData(t,e,a);case"latest_wins":return e.lastModified>a.lastModified?e:a}}async mergeData(t,e,a){switch(t){case"watchlists":return this.mergeWatchlists(e.data,a.data);case"alerts":return this.mergeAlerts(e.data,a.data);case"user_preferences":return{...a.data,...e.data};default:return e}}mergeWatchlists(t,e){const a={...e};return Object.entries(t).forEach(([t,e])=>{(!a[t]||new Date(e.lastUpdated)>new Date(a[t].lastUpdated))&&(a[t]=e)}),a}mergeAlerts(t,e){const a=[...e],s=new Set(e.map(t=>t.id));return t.forEach(t=>{s.has(t.id)||a.push(t)}),a}async applyMergedData(t){for(const[e,a]of Object.entries(t))await n.store(e,a.data,{storage:this.determineStorageType(e)})}async calculateChecksum(t){const e=JSON.stringify(t);return await this.cryptoUtils.hash(e)}setupPeriodicSync(){setInterval(()=>{navigator.onLine&&!this.syncInProgress&&this.processSyncQueue().catch(t=>{})},this.syncInterval),window.addEventListener("online",()=>{this.processSyncQueue().catch(t=>{})})}getSyncStatus(){return{lastSyncTime:this.lastSyncTime,syncInProgress:this.syncInProgress,queueSize:this.syncQueue.length,isOnline:navigator.onLine,hasEndpoint:!!this.syncEndpoint,strategy:this.conflictResolutionStrategy}}addEventListener(t){this.listeners.add(t)}removeEventListener(t){this.listeners.delete(t)}generateOperationId(){return"sync_"+Date.now()+"_"+Math.random().toString(36).substr(2,9)}determineStorageType(t){return["user_preferences","user_variables"].includes(t)?"localStorage":"indexedDB"}notifyListeners(t,e){this.listeners.forEach(a=>{try{a(t,e)}catch(s){}})}},h=new class{constructor(){this.testResults=[],this.isRunning=!1}async runAllTests(){if(this.isRunning)return this.testResults;this.isRunning=!0,this.testResults=[];try{await this.testPersistenceManagerInitialization(),await this.testDataStorageAndRetrieval(),await this.testDataRemoval(),await this.testStorageStatistics(),await this.testBackupCreation(),await this.testBackupListing(),await this.testBackupRestore(),await this.testPrivacySettings(),await this.testDataCleanup(),await this.testSyncStatus(),await this.testDataLifecycle(),await this.testErrorHandling();const t=this.testResults.filter(t=>t.passed).length,e=this.testResults.length;return{passed:t,total:e,success:t===e,results:this.testResults}}catch(t){return{passed:0,total:this.testResults.length,success:!1,error:t.message,results:this.testResults}}finally{this.isRunning=!1}}async testPersistenceManagerInitialization(){const t="Persistence Manager Initialization";try{const e=await n.initialize();this.assert(!0===e.success,t,"Should initialize successfully",e),this.assert(!0===n.isInitialized,t,"Should set initialized flag",{isInitialized:n.isInitialized})}catch(e){this.recordFailure(t,e.message)}}async testDataStorageAndRetrieval(){const t="Data Storage and Retrieval";try{const e={test:!0,timestamp:Date.now(),data:["item1","item2","item3"]},a=await n.store("test_data",e,{storage:"localStorage"});this.assert(!0===a.success,t,"Should store data successfully",a);const s=await n.retrieve("test_data");this.assert(JSON.stringify(s)===JSON.stringify(e),t,"Should retrieve stored data correctly",{stored:e,retrieved:s});const r=await n.store("test_indexed_data",e,{storage:"indexedDB"});this.assert(!0===r.success,t,"Should store data in IndexedDB",r)}catch(e){this.recordFailure(t,e.message)}}async testDataRemoval(){const t="Data Removal";try{await n.store("test_removal",{data:"to_be_removed"});const e=await n.remove("test_removal");this.assert(!0===e,t,"Should remove data successfully",{removeResult:e});const a=await n.retrieve("test_removal");this.assert(null===a,t,"Should return null for removed data",{retrievedData:a})}catch(e){this.recordFailure(t,e.message)}}async testStorageStatistics(){const t="Storage Statistics";try{const e=await n.getStorageStats();this.assert(null!==e&&"object"==typeof e,t,"Should return storage statistics",e),this.assert("number"==typeof e.total.used,t,"Should include total usage",{totalUsed:e.total.used})}catch(e){this.recordFailure(t,e.message)}}async testBackupCreation(){const t="Backup Creation";try{await n.store("backup_test_data",{test:"backup_data",timestamp:Date.now()});const e=await o.createBackup({description:"Test backup",compress:!0});this.assert(!0===e.success,t,"Should create backup successfully",e),this.assert("string"==typeof e.backupId,t,"Should return backup ID",{backupId:e.backupId})}catch(e){this.recordFailure(t,e.message)}}async testBackupListing(){const t="Backup Listing";try{const e=await o.listBackups();this.assert(Array.isArray(e),t,"Should return array of backups",{backupsCount:e.length})}catch(e){this.recordFailure(t,e.message)}}async testBackupRestore(){const t="Backup Restore";try{const e=await o.listBackups();if(e.length>0){const a=e[0].id,s=await o.restoreBackup(a,{overwrite:!1});this.assert(!0===s.success,t,"Should restore backup successfully",s)}else this.recordSkip(t,"No backups available for restore test")}catch(e){this.recordFailure(t,e.message)}}async testPrivacySettings(){const t="Privacy Settings";try{const e=c.getPrivacySettings();this.assert("object"==typeof e,t,"Should return privacy settings",e),await c.updatePrivacySettings({analytics:!1});const a=c.getPrivacySettings();this.assert(!1===a.analytics,t,"Should update privacy settings",{analytics:a.analytics})}catch(e){this.recordFailure(t,e.message)}}async testDataCleanup(){const t="Data Cleanup";try{const e=await c.cleanupExpiredData();this.assert("number"==typeof e.cleaned,t,"Should return cleanup results",e)}catch(e){this.recordFailure(t,e.message)}}async testSyncStatus(){const t="Sync Status";try{const e=l.getSyncStatus();this.assert("object"==typeof e,t,"Should return sync status",e),this.assert("boolean"==typeof e.isOnline,t,"Should include online status",{isOnline:e.isOnline})}catch(e){this.recordFailure(t,e.message)}}async testDataLifecycle(){const t="Data Lifecycle";try{const e="lifecycle_test",a={lifecycle:!0,step:1};await n.store(e,a);const s=await n.retrieve(e),r={...a,step:2};await n.store(e,r);const i=await n.retrieve(e);await n.remove(e);const o=await n.retrieve(e);this.assert(1===s.step&&2===i.step&&null===o,t,"Should handle complete data lifecycle",{initial:s?.step,updated:i?.step,afterRemoval:o})}catch(e){this.recordFailure(t,e.message)}}async testErrorHandling(){const t="Error Handling";try{const a=await n.retrieve("non_existent_key_12345");this.assert(null===a,t,"Should handle non-existent keys gracefully",{invalidResult:a});try{await o.restoreBackup("invalid_backup_id"),this.recordFailure(t,"Should have thrown error for invalid backup ID")}catch(e){this.assert(!0,t,"Should throw error for invalid backup ID",{error:e.message})}}catch(e){this.recordFailure(t,e.message)}}assert(t,e,a,s=null){const r={testName:e,description:a,passed:!!t,data:s,timestamp:(new Date).toISOString()};this.testResults.push(r)}recordFailure(t,e){const a={testName:t,description:"Test failed with error",passed:!1,error:e,timestamp:(new Date).toISOString()};this.testResults.push(a)}recordSkip(t,e){const a={testName:t,description:"Test skipped",passed:!0,skipped:!0,reason:e,timestamp:(new Date).toISOString()};this.testResults.push(a)}getTestSummary(){const t=this.testResults.length,e=this.testResults.filter(t=>t.passed).length;return{total:t,passed:e,failed:this.testResults.filter(t=>!t.passed).length,skipped:this.testResults.filter(t=>t.skipped).length,successRate:t>0?e/t*100:0,results:this.testResults}}};window.testPersistence=()=>h.runAllTests();export{h as a,c as b,o as c,n as p,l as s};
//# sourceMappingURL=persistence-CVb4Ip9D.js.map
