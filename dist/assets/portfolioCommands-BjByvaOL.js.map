{"version":3,"file":"portfolioCommands-BjByvaOL.js","sources":["../../src/services/financialModelingEngine.js","../../src/services/dataFetching.js","../../src/services/commands/portfolioCommands.js"],"sourcesContent":["// import { apiLogger } from '../utils/apiLogger.js';\n\n/**\n * Advanced Financial Modeling Engine\n * Provides comprehensive DCF, LBO, and valuation modeling capabilities\n */\nclass FinancialModelingEngine {\n  constructor() {\n    this.modelCache = new Map();\n    this.assumptions = this.getDefaultAssumptions();\n  }\n\n  /**\n   * Get default financial modeling assumptions\n   */\n  getDefaultAssumptions() {\n    return {\n      dcf: {\n        projectionYears: 5,\n        terminalGrowthRate: 0.025,\n        riskFreeRate: 0.045,\n        marketPremium: 0.065,\n        taxRate: 0.21,\n        capexAsPercentOfRevenue: 0.03,\n        nwcAsPercentOfRevenue: 0.05,\n        depreciationAsPercentOfRevenue: 0.025,\n        // Enhanced DCF parameters\n        normalizedMarginTarget: null, // For margin normalization\n        cyclicalAdjustment: false,\n        industryBeta: 1.0,\n        sizeAdjustment: 0.0, // Small company premium\n        countryRiskPremium: 0.0,\n        liquidityDiscount: 0.0\n      },\n      lbo: {\n        holdingPeriod: 5,\n        debtMultiples: { senior: 4.0, subordinated: 1.5, total: 5.5 },\n        interestRates: { senior: 0.055, subordinated: 0.095 },\n        managementFeeRate: 0.02,\n        carriedInterestRate: 0.2,\n        ebitdaGrowthRate: 0.05,\n        debtPaydownRate: 0.5\n      },\n      monte_carlo: {\n        iterations: 10000,\n        confidenceIntervals: [0.05, 0.25, 0.5, 0.75, 0.95],\n        correlationMatrix: null\n      }\n    };\n  }\n\n  /**\n   * Build comprehensive DCF model with multiple scenarios\n   * @param {Object} inputs - DCF model inputs\n   * @param {Object} scenarios - Different scenario assumptions\n   * @returns {Object} Complete DCF analysis\n   */\n  buildDCFModel(inputs, scenarios = {}) {\n    const {\n      symbol,\n      companyName,\n      currentRevenue: _currentRevenue,\n      historicalGrowthRates: _historicalGrowthRates = [],\n      margins: _margins = {},\n      balanceSheetData: _balanceSheetData = {},\n      marketData: _marketData = {},\n      assumptions = {}\n    } = inputs;\n\n    // Merge with default assumptions\n    const modelAssumptions = { ...this.assumptions.dcf, ...assumptions };\n\n    // Build base case scenario\n    const baseCase = this.calculateDCFScenario(inputs, modelAssumptions, 'Base Case');\n\n    // Build additional scenarios\n    const scenarioResults = {};\n\n    // Bull case: Higher growth, lower discount rate\n    if (scenarios.bull !== false) {\n      const bullAssumptions = {\n        ...modelAssumptions,\n        revenueGrowthRate: (modelAssumptions.revenueGrowthRate || 0.1) * 1.3,\n        terminalGrowthRate: Math.min(modelAssumptions.terminalGrowthRate * 1.2, 0.04),\n        wacc: (modelAssumptions.wacc || 0.1) * 0.9\n      };\n      scenarioResults.bull = this.calculateDCFScenario(inputs, bullAssumptions, 'Bull Case');\n    }\n\n    // Bear case: Lower growth, higher discount rate\n    if (scenarios.bear !== false) {\n      const bearAssumptions = {\n        ...modelAssumptions,\n        revenueGrowthRate: (modelAssumptions.revenueGrowthRate || 0.1) * 0.7,\n        terminalGrowthRate: Math.max(modelAssumptions.terminalGrowthRate * 0.8, 0.015),\n        wacc: (modelAssumptions.wacc || 0.1) * 1.1\n      };\n      scenarioResults.bear = this.calculateDCFScenario(inputs, bearAssumptions, 'Bear Case');\n    }\n\n    // Calculate sensitivity analysis\n    const sensitivityAnalysis = this.performDCFSensitivityAnalysis(inputs, modelAssumptions);\n\n    return {\n      symbol,\n      companyName,\n      modelType: 'DCF',\n      timestamp: new Date().toISOString(),\n      baseCase,\n      scenarios: scenarioResults,\n      sensitivityAnalysis,\n      assumptions: modelAssumptions,\n      summary: this.generateDCFSummary(baseCase, scenarioResults, inputs.currentPrice)\n    };\n  }\n\n  /**\n   * Calculate DCF for a specific scenario\n   * @param {Object} inputs - Model inputs\n   * @param {Object} assumptions - Scenario assumptions\n   * @param {string} scenarioName - Name of the scenario\n   * @returns {Object} DCF calculation results\n   */\n  calculateDCFScenario(inputs, assumptions, scenarioName) {\n    const {\n      currentRevenue,\n      currentPrice,\n      sharesOutstanding,\n      totalDebt = 0,\n      cash = 0\n    } = inputs;\n\n    // Project revenues\n    const revenueProjections = this.projectRevenues(\n      currentRevenue,\n      assumptions.revenueGrowthRate || 0.1,\n      assumptions.projectionYears\n    );\n\n    // Project operating metrics\n    const operatingProjections = this.projectOperatingMetrics(\n      revenueProjections,\n      assumptions\n    );\n\n    // Calculate free cash flows\n    const fcfProjections = this.calculateFreeCashFlows(\n      operatingProjections,\n      assumptions\n    );\n\n    // Calculate terminal value\n    const finalFCF = fcfProjections[fcfProjections.length - 1]?.unleveredFCF || 0;\n    const terminalValue = this.calculateTerminalValue(\n      finalFCF,\n      assumptions.terminalGrowthRate,\n      assumptions.wacc\n    );\n\n    // Calculate present values\n    const fcfValues = fcfProjections.map(fcf => fcf?.unleveredFCF || 0);\n    const pvOfCashFlows = this.calculatePresentValue(fcfValues, assumptions.wacc);\n    const pvOfTerminalValue = this.calculatePresentValue([terminalValue], assumptions.wacc, assumptions.projectionYears);\n\n    // Calculate enterprise and equity values\n    const enterpriseValue = pvOfCashFlows + pvOfTerminalValue;\n    const equityValue = enterpriseValue - totalDebt + cash;\n    const pricePerShare = equityValue / sharesOutstanding;\n\n    // Calculate valuation metrics\n    const upside = currentPrice ? ((pricePerShare - currentPrice) / currentPrice) * 100 : null;\n\n    return {\n      scenarioName,\n      revenueProjections,\n      operatingProjections,\n      fcfProjections,\n      terminalValue,\n      pvOfCashFlows,\n      pvOfTerminalValue,\n      enterpriseValue,\n      equityValue,\n      pricePerShare,\n      currentPrice,\n      upside,\n      wacc: assumptions.wacc,\n      terminalGrowthRate: assumptions.terminalGrowthRate,\n      impliedMultiples: this.calculateImpliedMultiples(enterpriseValue, operatingProjections)\n    };\n  }\n\n  /**\n   * Project revenue growth over multiple years\n   * @param {number} baseRevenue - Starting revenue\n   * @param {number|Array} growthRates - Growth rate(s)\n   * @param {number} years - Number of years to project\n   * @returns {Array} Revenue projections\n   */\n  projectRevenues(baseRevenue, growthRates, years) {\n    const projections = [];\n    let currentRevenue = baseRevenue;\n\n    for (let i = 0; i < years; i++) {\n      const growthRate = Array.isArray(growthRates)\n        ? growthRates[i] || growthRates[growthRates.length - 1]\n        : growthRates * Math.pow(0.95, i); // Declining growth rate\n\n      currentRevenue *= (1 + growthRate);\n      projections.push({\n        year: i + 1,\n        revenue: currentRevenue,\n        growthRate\n      });\n    }\n\n    return projections;\n  }\n\n  /**\n   * Project operating metrics (EBITDA, margins, etc.)\n   * @param {Array} revenueProjections - Revenue projections\n   * @param {Object} assumptions - Model assumptions\n   * @returns {Array} Operating projections\n   */\n  projectOperatingMetrics(revenueProjections, assumptions) {\n    return revenueProjections.map((projection, _index) => {\n      const ebitdaMargin = assumptions.ebitdaMargin || 0.2;\n      const ebitda = projection.revenue * ebitdaMargin;\n      const depreciation = projection.revenue * assumptions.depreciationAsPercentOfRevenue;\n      const ebit = ebitda - depreciation;\n      const taxes = ebit * assumptions.taxRate;\n      const nopat = ebit - taxes;\n\n      return {\n        ...projection,\n        ebitda,\n        ebitdaMargin,\n        depreciation,\n        ebit,\n        taxes,\n        nopat\n      };\n    });\n  }\n\n  /**\n   * Calculate free cash flows with enhanced methodology\n   * @param {Array} operatingProjections - Operating projections\n   * @param {Object} assumptions - Model assumptions\n   * @returns {Array} Free cash flow projections with detailed breakdown\n   */\n  calculateFreeCashFlows(operatingProjections, assumptions) {\n    return operatingProjections.map((projection, index) => {\n      // More sophisticated CapEx modeling\n      const maintenanceCapex = projection.revenue * (assumptions.maintenanceCapexRate || 0.015);\n      const growthCapex = index > 0 ?\n        (projection.revenue - operatingProjections[index - 1].revenue) * (assumptions.growthCapexRate || 0.8) : 0;\n      const totalCapex = maintenanceCapex + growthCapex;\n\n      // Enhanced working capital calculation\n      const nwcChange = this.calculateWorkingCapitalChange(projection, operatingProjections[index - 1], assumptions);\n\n      // Add non-cash charges beyond depreciation\n      const stockBasedComp = projection.revenue * (assumptions.stockBasedCompRate || 0.005);\n      const otherNonCash = projection.revenue * (assumptions.otherNonCashRate || 0.001);\n      const totalNonCash = projection.depreciation + stockBasedComp + otherNonCash;\n\n      // Calculate unlevered FCF\n      const fcf = projection.nopat + totalNonCash - totalCapex - nwcChange;\n\n      return {\n        year: index + 1,\n        nopat: projection.nopat,\n        depreciation: projection.depreciation,\n        stockBasedComp,\n        otherNonCash,\n        totalNonCash,\n        maintenanceCapex,\n        growthCapex,\n        totalCapex,\n        nwcChange,\n        unleveredFCF: fcf,\n        fcfMargin: projection.revenue > 0 ? fcf / projection.revenue : 0\n      };\n    });\n  }\n\n  /**\n   * Calculate working capital change with detailed components\n   * @param {Object} currentProjection - Current year projection\n   * @param {Object} priorProjection - Prior year projection\n   * @param {Object} assumptions - Model assumptions\n   * @returns {number} Working capital change\n   */\n  calculateWorkingCapitalChange(currentProjection, priorProjection, assumptions) {\n    if (!priorProjection) {\n      return currentProjection.revenue * assumptions.nwcAsPercentOfRevenue;\n    }\n\n    // Component-based NWC calculation\n    const receivablesDays = assumptions.receivablesDays || 45;\n    const inventoryDays = assumptions.inventoryDays || 30;\n    const payablesDays = assumptions.payablesDays || 35;\n\n    const currentReceivables = (currentProjection.revenue * receivablesDays) / 365;\n    const currentInventory = (currentProjection.revenue * inventoryDays) / 365 * (assumptions.cogsPct || 0.6);\n    const currentPayables = (currentProjection.revenue * payablesDays) / 365 * (assumptions.cogsPct || 0.6);\n    const currentNWC = currentReceivables + currentInventory - currentPayables;\n\n    const priorReceivables = (priorProjection.revenue * receivablesDays) / 365;\n    const priorInventory = (priorProjection.revenue * inventoryDays) / 365 * (assumptions.cogsPct || 0.6);\n    const priorPayables = (priorProjection.revenue * payablesDays) / 365 * (assumptions.cogsPct || 0.6);\n    const priorNWC = priorReceivables + priorInventory - priorPayables;\n\n    return currentNWC - priorNWC;\n  }\n\n  /**\n   * Calculate terminal value using Gordon Growth Model with validation\n   * @param {number} finalFCF - Final year free cash flow\n   * @param {number} terminalGrowthRate - Terminal growth rate\n   * @param {number} discountRate - Discount rate (WACC)\n   * @param {Object} options - Additional options for terminal value calculation\n   * @returns {number} Terminal value\n   */\n  calculateTerminalValue(finalFCF, terminalGrowthRate, discountRate, options = {}) {\n    // Enhanced validation\n    if (discountRate <= terminalGrowthRate) {\n      throw new Error('Discount rate must be greater than terminal growth rate');\n    }\n\n    if (terminalGrowthRate < 0 || terminalGrowthRate > 0.05) {\n      console.warn(`Terminal growth rate ${(terminalGrowthRate * 100).toFixed(2)}% is outside typical range (0-5%)`);\n    }\n\n    if (finalFCF <= 0) {\n      console.warn('Final year FCF is negative or zero, terminal value calculation may be unreliable');\n    }\n\n    // Multiple terminal value methods\n    const { method = 'gordon', exitMultiple = null, fadeToGrowth: _fadeToGrowth = false } = options;\n\n    switch (method) {\n      case 'gordon':\n        return (finalFCF * (1 + terminalGrowthRate)) / (discountRate - terminalGrowthRate);\n\n      case 'exit_multiple':\n        if (exitMultiple && finalFCF > 0) {\n          // Assume FCF approximates EBITDA for multiple calculation\n          return finalFCF * exitMultiple;\n        }\n        return (finalFCF * (1 + terminalGrowthRate)) / (discountRate - terminalGrowthRate);\n\n      case 'fade_to_growth': {\n        // Implement fade-to-growth model where high growth fades to long-term rate\n        const fadeYears = options.fadeYears || 5;\n        const longTermGrowth = options.longTermGrowth || 0.025;\n        let terminalValue = 0;\n\n        for (let year = 1; year <= fadeYears; year++) {\n          const fadeRate = terminalGrowthRate * Math.pow((fadeYears - year + 1) / fadeYears, 2) +\n                          longTermGrowth * Math.pow(year / fadeYears, 2);\n          const yearFCF = finalFCF * Math.pow(1 + fadeRate, year);\n          terminalValue += yearFCF / Math.pow(1 + discountRate, year);\n        }\n\n        // Add perpetual value after fade period\n        const finalFadeFCF = finalFCF * Math.pow(1 + longTermGrowth, fadeYears);\n        const perpetualValue = finalFadeFCF / (discountRate - longTermGrowth);\n        terminalValue += perpetualValue / Math.pow(1 + discountRate, fadeYears);\n\n        return terminalValue;\n      }\n\n      default:\n        return (finalFCF * (1 + terminalGrowthRate)) / (discountRate - terminalGrowthRate);\n    }\n  }\n\n  /**\n   * Calculate present value of cash flows\n   * @param {Array} cashFlows - Array of cash flows\n   * @param {number} discountRate - Discount rate\n   * @param {number} startYear - Starting year for discounting\n   * @returns {number} Present value\n   */\n  calculatePresentValue(cashFlows, discountRate, startYear = 0) {\n    return cashFlows.reduce((pv, cf, index) => {\n      const year = startYear + index + 1;\n      return pv + cf / Math.pow(1 + discountRate, year);\n    }, 0);\n  }\n\n  /**\n   * Calculate comprehensive implied valuation multiples\n   * @param {number} enterpriseValue - Enterprise value\n   * @param {Array} operatingProjections - Operating projections\n   * @param {Array} fcfProjections - Free cash flow projections\n   * @param {number} currentRevenue - Current year revenue\n   * @returns {Object} Comprehensive implied multiples\n   */\n  calculateImpliedMultiples(enterpriseValue, operatingProjections, fcfProjections = [], currentRevenue = 0) {\n    const currentYearEbitda = operatingProjections[0]?.ebitda || 0;\n    const nextYearEbitda = operatingProjections[1]?.ebitda || 0;\n    const currentYearEbit = operatingProjections[0]?.ebit || 0;\n    const nextYearEbit = operatingProjections[1]?.ebit || 0;\n    const nextYearRevenue = operatingProjections[1]?.revenue || 0;\n    const currentYearFCF = fcfProjections[0]?.unleveredFCF || 0;\n    const nextYearFCF = fcfProjections[1]?.unleveredFCF || 0;\n\n    return {\n      // Revenue multiples\n      evToCurrentRevenue: currentRevenue ? enterpriseValue / currentRevenue : null,\n      evToForwardRevenue: nextYearRevenue ? enterpriseValue / nextYearRevenue : null,\n\n      // EBITDA multiples\n      evToCurrentEbitda: currentYearEbitda ? enterpriseValue / currentYearEbitda : null,\n      evToForwardEbitda: nextYearEbitda ? enterpriseValue / nextYearEbitda : null,\n\n      // EBIT multiples\n      evToCurrentEbit: currentYearEbit ? enterpriseValue / currentYearEbit : null,\n      evToForwardEbit: nextYearEbit ? enterpriseValue / nextYearEbit : null,\n\n      // FCF multiples\n      evToCurrentFCF: currentYearFCF ? enterpriseValue / currentYearFCF : null,\n      evToForwardFCF: nextYearFCF ? enterpriseValue / nextYearFCF : null,\n\n      // PEG ratio approximation (P/E to Growth)\n      pegRatio: this.calculatePEGRatio(operatingProjections, enterpriseValue)\n    };\n  }\n\n  /**\n   * Calculate PEG ratio approximation\n   * @param {Array} operatingProjections - Operating projections\n   * @param {number} enterpriseValue - Enterprise value\n   * @returns {number} PEG ratio\n   */\n  calculatePEGRatio(operatingProjections, enterpriseValue) {\n    if (operatingProjections.length < 2) return null;\n\n    const currentEarnings = operatingProjections[0]?.nopat || 0;\n    const futureEarnings = operatingProjections[operatingProjections.length - 1]?.nopat || 0;\n\n    if (currentEarnings <= 0 || futureEarnings <= 0) return null;\n\n    const growthRate = Math.pow(futureEarnings / currentEarnings, 1 / (operatingProjections.length - 1)) - 1;\n    const peRatio = enterpriseValue / currentEarnings;\n\n    return growthRate > 0 ? peRatio / (growthRate * 100) : null;\n  }\n\n  /**\n   * Perform sensitivity analysis on key variables\n   * @param {Object} inputs - Model inputs\n   * @param {Object} baseAssumptions - Base case assumptions\n   * @returns {Object} Sensitivity analysis results\n   */\n  performDCFSensitivityAnalysis(inputs, baseAssumptions) {\n    const sensitivityVars = {\n      revenueGrowthRate: [-0.02, -0.01, 0, 0.01, 0.02],\n      wacc: [-0.005, -0.0025, 0, 0.0025, 0.005],\n      terminalGrowthRate: [-0.005, -0.0025, 0, 0.0025, 0.005],\n      ebitdaMargin: [-0.02, -0.01, 0, 0.01, 0.02]\n    };\n\n    const results = {};\n\n    Object.entries(sensitivityVars).forEach(([variable, variations]) => {\n      results[variable] = variations.map(variation => {\n        const adjustedAssumptions = {\n          ...baseAssumptions,\n          [variable]: (baseAssumptions[variable] || 0) + variation\n        };\n\n        try {\n          const scenario = this.calculateDCFScenario(inputs, adjustedAssumptions, `${variable}_${variation}`);\n          return {\n            variation,\n            pricePerShare: scenario.pricePerShare,\n            upside: scenario.upside\n          };\n        } catch (error) {\n          return {\n            variation,\n            pricePerShare: null,\n            upside: null,\n            error: error.message\n          };\n        }\n      });\n    });\n\n    return results;\n  }\n\n  /**\n   * Generate DCF model summary\n   * @param {Object} baseCase - Base case results\n   * @param {Object} scenarios - Scenario results\n   * @param {number} currentPrice - Current stock price\n   * @returns {Object} Model summary\n   */\n  generateDCFSummary(baseCase, scenarios, currentPrice) {\n    const allScenarios = [baseCase, ...Object.values(scenarios)];\n    const pricesPerShare = allScenarios.map(s => s.pricePerShare).filter(p => p !== null);\n\n    return {\n      priceRange: {\n        min: Math.min(...pricesPerShare),\n        max: Math.max(...pricesPerShare),\n        average: pricesPerShare.reduce((sum, p) => sum + p, 0) / pricesPerShare.length\n      },\n      recommendation: this.generateRecommendation(baseCase, currentPrice),\n      keyMetrics: {\n        baseCase: {\n          pricePerShare: baseCase.pricePerShare,\n          upside: baseCase.upside,\n          enterpriseValue: baseCase.enterpriseValue\n        },\n        currentPrice,\n        impliedReturn: baseCase.upside\n      }\n    };\n  }\n\n  /**\n   * Generate investment recommendation\n   * @param {Object} baseCase - Base case DCF results\n   * @param {number} currentPrice - Current stock price\n   * @returns {Object} Investment recommendation\n   */\n  generateRecommendation(baseCase, currentPrice) {\n    if (!currentPrice || !baseCase.pricePerShare) {\n      return {\n        rating: 'INSUFFICIENT_DATA',\n        confidence: 0,\n        upside: null,\n        reasoning: 'Insufficient data for reliable recommendation.'\n      };\n    }\n\n    const upside = baseCase.upside;\n    let rating, confidence;\n\n    if (upside > 20) {\n      rating = 'STRONG_BUY';\n      confidence = Math.min(95, 70 + (upside - 20) * 1.25);\n    } else if (upside > 10) {\n      rating = 'BUY';\n      confidence = Math.min(85, 60 + (upside - 10) * 2);\n    } else if (upside > -10) {\n      rating = 'HOLD';\n      confidence = Math.min(75, 50 + Math.abs(upside) * 2.5);\n    } else if (upside > -20) {\n      rating = 'SELL';\n      confidence = Math.min(85, 60 + Math.abs(upside + 10) * 2);\n    } else {\n      rating = 'STRONG_SELL';\n      confidence = Math.min(95, 70 + Math.abs(upside + 20) * 1.25);\n    }\n\n    return {\n      rating,\n      confidence: Math.round(confidence),\n      upside,\n      reasoning: this.generateRecommendationReasoning(rating, upside)\n    };\n  }\n\n  /**\n   * Generate reasoning for investment recommendation\n   * @param {string} rating - Investment rating\n   * @param {number} upside - Upside percentage\n   * @returns {string} Recommendation reasoning\n   */\n  generateRecommendationReasoning(rating, upside) {\n    const upsideAbs = Math.abs(upside);\n\n    switch (rating) {\n      case 'STRONG_BUY':\n        return `Strong upside potential of ${upside.toFixed(1)}% suggests significant undervaluation based on DCF analysis.`;\n      case 'BUY':\n        return `Moderate upside of ${upside.toFixed(1)}% indicates the stock is undervalued relative to intrinsic value.`;\n      case 'HOLD':\n        return `Fair valuation with ${upside >= 0 ? 'limited upside' : 'modest downside'} of ${upsideAbs.toFixed(1)}%.`;\n      case 'SELL':\n        return `Downside risk of ${upsideAbs.toFixed(1)}% suggests the stock is overvalued based on fundamental analysis.`;\n      case 'STRONG_SELL':\n        return `Significant downside of ${upsideAbs.toFixed(1)}% indicates substantial overvaluation.`;\n      default:\n        return 'Insufficient data for reliable recommendation.';\n    }\n  }\n}\n\n// Export singleton instance\nexport const financialModelingEngine = new FinancialModelingEngine();\nexport default FinancialModelingEngine;\n","import axios from 'axios';\n\nimport { apiLogger } from '../utils/apiLogger.js';\n\nimport { financialModelingEngine } from './financialModelingEngine.js';\nimport { lboModelingEngine } from './lboModelingEngine.js';\nimport secureApiClient from './secureApiClient.js';\n\n// SECURITY NOTE: All API calls now route through secure backend proxy\n// No API keys are exposed in frontend code\n\n// Mock data sources configuration for fallback\nconst DATA_SOURCES = {\n  ALPHA_VANTAGE: {\n    baseURL: 'https://www.alphavantage.co/query',\n    apiKey: import.meta.env.VITE_ALPHA_VANTAGE_API_KEY || 'demo'\n  },\n  FMP: {\n    baseURL: 'https://financialmodelingprep.com/api/v3',\n    apiKey: import.meta.env.VITE_FMP_API_KEY || 'demo'\n  },\n  SEC_EDGAR: {\n    baseURL: 'https://data.sec.gov',\n    apiKey: null\n  }\n};\n\n// Mock API key validator\nconst apiKeyValidator = {\n  validateAllKeys: async() => ({\n    valid: true,\n    recommendations: ['API keys validated successfully']\n  })\n};\n\n// Rate limiting configuration\nconst RATE_LIMITS = {\n  ALPHA_VANTAGE: { requests: 5, period: 60000 }, // 5 requests per minute\n  FMP: { requests: 250, period: 86400000 }, // 250 requests per day\n  SEC_EDGAR: { requests: 10, period: 1000 } // 10 requests per second\n};\n\n// Advanced retry configuration\nconst RETRY_CONFIG = {\n  maxRetries: 3,\n  baseDelay: 1000, // 1 second base delay\n  maxDelay: 30000, // 30 seconds max delay\n  exponentialBase: 2,\n  jitterFactor: 0.1, // 10% jitter\n  retryableStatusCodes: [408, 429, 500, 502, 503, 504],\n  retryableErrors: ['ECONNRESET', 'ENOTFOUND', 'ECONNREFUSED', 'ETIMEDOUT']\n};\n\n/**\n * Circuit breaker configuration\n */\nconst CIRCUIT_BREAKER_CONFIG = {\n  failureThreshold: 5, // Number of failures before opening circuit\n  recoveryTimeout: 30000, // 30 seconds before attempting to close circuit\n  monitoringPeriod: 60000, // 1 minute monitoring window\n  halfOpenMaxCalls: 3 // Max calls to test in half-open state\n};\n\n/**\n * Circuit breaker states\n */\nconst CIRCUIT_STATES = {\n  CLOSED: 'CLOSED', // Normal operation\n  OPEN: 'OPEN', // Circuit is open, failing fast\n  HALF_OPEN: 'HALF_OPEN' // Testing if service has recovered\n};\n\n/**\n * Circuit breaker implementation to prevent cascading failures\n */\nclass CircuitBreaker {\n  constructor(name, config = CIRCUIT_BREAKER_CONFIG) {\n    this.name = name;\n    this.config = { ...CIRCUIT_BREAKER_CONFIG, ...config };\n    this.state = CIRCUIT_STATES.CLOSED;\n    this.failureCount = 0;\n    this.lastFailureTime = null;\n    this.halfOpenCallCount = 0;\n    this.successCount = 0;\n    this.totalCalls = 0;\n  }\n\n  /**\n   * Check if circuit breaker allows the call\n   * @returns {boolean} Whether the call is allowed\n   */\n  canExecute() {\n    const now = Date.now();\n\n    switch (this.state) {\n      case CIRCUIT_STATES.CLOSED:\n        return true;\n\n      case CIRCUIT_STATES.OPEN:\n        // Check if recovery timeout has passed\n        if (now - this.lastFailureTime >= this.config.recoveryTimeout) {\n          this.state = CIRCUIT_STATES.HALF_OPEN;\n          this.halfOpenCallCount = 0;\n          console.log(`ðŸ”„ Circuit breaker ${this.name} transitioning to HALF_OPEN`);\n          return true;\n        }\n        return false;\n\n      case CIRCUIT_STATES.HALF_OPEN:\n        return this.halfOpenCallCount < this.config.halfOpenMaxCalls;\n\n      default:\n        return false;\n    }\n  }\n\n  /**\n   * Record a successful call\n   */\n  recordSuccess() {\n    this.successCount++;\n    this.totalCalls++;\n\n    switch (this.state) {\n      case CIRCUIT_STATES.HALF_OPEN:\n        this.halfOpenCallCount++;\n        // If we've successfully completed enough calls in half-open, close the circuit\n        if (this.halfOpenCallCount >= this.config.halfOpenMaxCalls) {\n          this.state = CIRCUIT_STATES.CLOSED;\n          this.failureCount = 0;\n          this.halfOpenCallCount = 0;\n          console.log(`âœ… Circuit breaker ${this.name} closed - service recovered`);\n        }\n        break;\n\n      case CIRCUIT_STATES.CLOSED:\n        // Reset failure count on success\n        this.failureCount = 0;\n        break;\n    }\n  }\n\n  /**\n   * Record a failed call\n   */\n  recordFailure() {\n    this.failureCount++;\n    this.totalCalls++;\n    this.lastFailureTime = Date.now();\n\n    switch (this.state) {\n      case CIRCUIT_STATES.CLOSED:\n        if (this.failureCount >= this.config.failureThreshold) {\n          this.state = CIRCUIT_STATES.OPEN;\n          console.warn(\n            `ðŸš¨ Circuit breaker ${this.name} opened - too many failures (${this.failureCount})`\n          );\n        }\n        break;\n\n      case CIRCUIT_STATES.HALF_OPEN:\n        // Any failure in half-open state reopens the circuit\n        this.state = CIRCUIT_STATES.OPEN;\n        this.halfOpenCallCount = 0;\n        console.warn(`ðŸš¨ Circuit breaker ${this.name} reopened - failure during recovery test`);\n        break;\n    }\n  }\n\n  /**\n   * Get circuit breaker status\n   * @returns {Object} Status information\n   */\n  getStatus() {\n    return {\n      name: this.name,\n      state: this.state,\n      failureCount: this.failureCount,\n      successCount: this.successCount,\n      totalCalls: this.totalCalls,\n      failureRate: this.totalCalls > 0 ? this.failureCount / this.totalCalls : 0,\n      lastFailureTime: this.lastFailureTime,\n      isOpen: this.state === CIRCUIT_STATES.OPEN,\n      nextRetryTime:\n        this.state === CIRCUIT_STATES.OPEN\n          ? this.lastFailureTime + this.config.recoveryTimeout\n          : null\n    };\n  }\n\n  /**\n   * Execute function with circuit breaker protection\n   * @param {Function} fn - Function to execute\n   * @returns {Promise} Result of the function\n   */\n  async execute(fn) {\n    if (!this.canExecute()) {\n      const error = new Error(`Circuit breaker ${this.name} is OPEN - failing fast`);\n      error.circuitBreakerOpen = true;\n      throw error;\n    }\n\n    try {\n      const result = await fn();\n      this.recordSuccess();\n      return result;\n    } catch (error) {\n      this.recordFailure();\n      throw error;\n    }\n  }\n}\n\n/**\n * Advanced retry utility with exponential backoff and jitter\n */\nclass _RetryManager {\n  constructor(config = RETRY_CONFIG) {\n    this.config = { ...RETRY_CONFIG, ...config };\n  }\n\n  /**\n   * Calculate delay with exponential backoff and jitter\n   * @param {number} attempt - Current attempt number (0-based)\n   * @returns {number} Delay in milliseconds\n   */\n  calculateDelay(attempt) {\n    const exponentialDelay = this.config.baseDelay * Math.pow(this.config.exponentialBase, attempt);\n    const jitter = exponentialDelay * this.config.jitterFactor * Math.random();\n    const delay = exponentialDelay + jitter;\n    return Math.min(delay, this.config.maxDelay);\n  }\n\n  /**\n   * Check if error is retryable\n   * @param {Error} error - Error to check\n   * @returns {boolean} Whether error is retryable\n   */\n  isRetryableError(error) {\n    // Check for network errors\n    if (error.code && this.config.retryableErrors.includes(error.code)) {\n      return true;\n    }\n\n    // Check for HTTP status codes\n    if (\n      error.response?.status &&\n      this.config.retryableStatusCodes.includes(error.response.status)\n    ) {\n      return true;\n    }\n\n    // Check for timeout errors\n    if (error.message?.includes('timeout')) {\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Execute function with retry logic\n   * @param {Function} fn - Async function to execute\n   * @param {string} operation - Operation name for logging\n   * @returns {Promise} Result of the function\n   */\n  async executeWithRetry(fn, operation = 'API call') {\n    let lastError;\n\n    for (let attempt = 0; attempt <= this.config.maxRetries; attempt++) {\n      try {\n        const result = await fn();\n\n        // Log successful retry if this wasn't the first attempt\n        if (attempt > 0) {\n          console.log(`âœ… ${operation} succeeded on attempt ${attempt + 1}`);\n        }\n\n        return result;\n      } catch (error) {\n        lastError = error;\n\n        // Don't retry on the last attempt\n        if (attempt === this.config.maxRetries) {\n          break;\n        }\n\n        // Check if error is retryable\n        if (!this.isRetryableError(error)) {\n          console.warn(`âŒ ${operation} failed with non-retryable error:`, error.message);\n          throw error;\n        }\n\n        const delay = this.calculateDelay(attempt);\n        console.warn(\n          `âš ï¸ ${operation} failed (attempt ${attempt + 1}/${this.config.maxRetries + 1}), retrying in ${delay}ms:`,\n          error.message\n        );\n\n        // Wait before retrying\n        await new Promise(resolve => setTimeout(resolve, delay));\n      }\n    }\n\n    // All retries exhausted\n    console.error(\n      `âŒ ${operation} failed after ${this.config.maxRetries + 1} attempts:`,\n      lastError.message\n    );\n    throw lastError;\n  }\n}\n\nclass DataFetchingService {\n  constructor() {\n    this.cache = new Map();\n    this.cacheExpiry = new Map();\n    this.logger = apiLogger;\n    this.client = secureApiClient;\n\n    // Log service initialization\n    this.logger.log('INFO', 'ðŸš€ DataFetchingService initialized (using secure backend proxy)');\n  }\n\n  initializeCircuitBreakers(config) {\n    const circuitBreakers = {};\n    const sources = ['ALPHA_VANTAGE', 'FMP', 'SEC_EDGAR', 'YAHOO_FINANCE'];\n\n    sources.forEach(source => {\n      circuitBreakers[source] = new CircuitBreaker(source, config);\n    });\n\n    return circuitBreakers;\n  }\n\n  initializeRateLimiters() {\n    const rateLimits = this.customRateLimits || RATE_LIMITS;\n    Object.keys(rateLimits).forEach(source => {\n      this.rateLimiters[source] = {\n        requests: [],\n        limit: rateLimits[source].requests,\n        period: rateLimits[source].period\n      };\n    });\n  }\n\n  async checkRateLimit(source) {\n    const limiter = this.rateLimiters[source];\n    if (!limiter) return true;\n\n    const now = Date.now();\n    limiter.requests = limiter.requests.filter(time => now - time < limiter.period);\n\n    if (limiter.requests.length >= limiter.limit) {\n      const oldestRequest = Math.min(...limiter.requests);\n      const waitTime = limiter.period - (now - oldestRequest);\n\n      // Log rate limiting event\n      this.logger.logRateLimit(source, waitTime, limiter.limit - limiter.requests.length);\n\n      throw new Error(\n        `Rate limit exceeded for ${source}. Please wait ${Math.ceil(waitTime / 1000)} seconds.`\n      );\n    }\n\n    limiter.requests.push(now);\n    return true;\n  }\n\n  getCacheKey(method, params) {\n    return `${method}_${JSON.stringify(params)}`;\n  }\n\n  getFromCache(key) {\n    const expiry = this.cacheExpiry.get(key);\n    if (expiry && Date.now() > expiry) {\n      this.cache.delete(key);\n      this.cacheExpiry.delete(key);\n      this.logger.logCache('miss', key, { reason: 'expired' });\n      return null;\n    }\n    const cached = this.cache.get(key);\n    if (cached !== undefined) {\n      this.logger.logCache('hit', key, { size: JSON.stringify(cached).length });\n      return cached;\n    }\n    this.logger.logCache('miss', key, { reason: 'not_found' });\n    return null;\n  }\n\n  setCache(key, data, ttlMinutes = 60) {\n    this.cache.set(key, data);\n    this.cacheExpiry.set(key, Date.now() + ttlMinutes * 60 * 1000);\n    this.logger.logCache('set', key, {\n      ttlMinutes,\n      size: JSON.stringify(data).length,\n      expiresAt: new Date(Date.now() + ttlMinutes * 60 * 1000).toISOString()\n    });\n  }\n\n  generateMockData(ticker, dataType) {\n    // Generate realistic mock data for demo purposes\n    const basePrice = 100 + Math.random() * 200;\n    const marketCap = 1000000000 + Math.random() * 10000000000;\n\n    // Map common tickers to realistic company names\n    const companyNames = {\n      AAPL: 'Apple Inc.',\n      MSFT: 'Microsoft Corporation',\n      GOOGL: 'Alphabet Inc.',\n      AMZN: 'Amazon.com Inc.',\n      META: 'Meta Platforms Inc.',\n      TSLA: 'Tesla Inc.',\n      NVDA: 'NVIDIA Corporation'\n    };\n\n    switch (dataType) {\n      case 'profile':\n        return {\n          symbol: ticker,\n          companyName: companyNames[ticker] || `${ticker} Corporation`,\n          mktCap: marketCap,\n          pe: 15 + Math.random() * 20,\n          pb: 1 + Math.random() * 4,\n          beta: 0.8 + Math.random() * 0.8,\n          sector: 'Technology',\n          industry: 'Software',\n          sharesOutstanding: marketCap / basePrice,\n          enterpriseValueOverEBITDA: 10 + Math.random() * 15,\n          debtToEquity: Math.random() * 2,\n          revenueTTM: marketCap * 0.8,\n          grossProfitMargin: 0.3 + Math.random() * 0.4,\n          netProfitMargin: 0.1 + Math.random() * 0.2,\n          returnOnEquityTTM: 0.1 + Math.random() * 0.2,\n          returnOnAssetsTTM: 0.05 + Math.random() * 0.15,\n          effectiveTaxRateTTM: 0.21,\n          fullTimeEmployees: 1000 + Math.random() * 50000,\n          ipoDate: '2010-01-01',\n          range: `$${(basePrice * 0.8).toFixed(2)} - $${(basePrice * 1.3).toFixed(2)}`\n        };\n\n      case 'marketData':\n        return {\n          symbol: ticker,\n          currentPrice: basePrice,\n          previousClose: basePrice * (0.98 + Math.random() * 0.04),\n          marketCap,\n          volume: 1000000 + Math.random() * 5000000,\n          currency: 'USD'\n        };\n\n      case 'incomeStatement':\n      case 'income': {\n        const revenue = marketCap * 0.8;\n        return [\n          {\n            revenue,\n            ebitda: revenue * 0.25,\n            netIncome: revenue * 0.15,\n            capex: revenue * 0.05,\n            interestExpense: revenue * 0.02,\n            grossProfitMargin: 0.6\n          }\n        ];\n      }\n\n      case 'balanceSheet':\n        return [\n          {\n            totalDebt: marketCap * 0.3,\n            cashAndCashEquivalents: marketCap * 0.1,\n            totalCurrentAssets: marketCap * 0.4,\n            totalCurrentLiabilities: marketCap * 0.2\n          }\n        ];\n\n      case 'cashFlow':\n        return [\n          {\n            freeCashFlow: marketCap * 0.12\n          }\n        ];\n\n      default:\n        return null;\n    }\n  }\n\n  async fetchCompanyProfile(ticker) {\n    const cacheKey = this.getCacheKey('profile', { ticker });\n    const cached = this.getFromCache(cacheKey);\n    if (cached) return cached;\n\n    try {\n      const profile = await this.client.getCompanyProfile(ticker);\n      this.setCache(cacheKey, profile, 1440); // Cache for 24 hours\n      return profile;\n    } catch (error) {\n      this.logger.log('ERROR', `Failed to fetch company profile for ${ticker}`, { error: error.message });\n      throw new Error(`Failed to fetch company profile: ${error.message}`);\n    }\n  }\n\n  async fetchFinancialStatements(\n    ticker,\n    statement = 'income-statement',\n    period = 'annual',\n    limit = 5\n  ) {\n    const cacheKey = this.getCacheKey('financials', { ticker, statement, period, limit });\n    const cached = this.getFromCache(cacheKey);\n    if (cached) return cached;\n\n    try {\n      const data = await this.client.fetchFinancialStatements(ticker, statement, period, limit);\n      this.setCache(cacheKey, data, 360); // Cache for 6 hours\n      return data;\n    } catch (error) {\n      this.logger.log('ERROR', `Failed to fetch ${statement} for ${ticker}`, { error: error.message });\n      throw new Error(`Failed to fetch ${statement}: ${error.message}`);\n    }\n  }\n\n  async fetchMarketData(ticker, range = '1y') {\n    const cacheKey = this.getCacheKey('market', { ticker, range });\n    const cached = this.getFromCache(cacheKey);\n    if (cached) return cached;\n\n    try {\n      const data = await this.client.fetchMarketData(ticker, range);\n      this.setCache(cacheKey, data, 15); // Cache for 15 minutes\n      return data;\n    } catch (error) {\n      this.logger.log('ERROR', `Failed to fetch market data for ${ticker}`, { error: error.message });\n      throw new Error(`Failed to fetch market data: ${error.message}`);\n    }\n  }\n\n  async fetchMarketDataAlternative(ticker) {\n    if (this.demoMode) {\n      const mockData = this.generateMockData(ticker, 'marketData');\n      return mockData;\n    }\n\n    try {\n      return await this.retryManager.executeWithRetry(async() => {\n        await this.checkRateLimit('ALPHA_VANTAGE');\n\n        const response = await axios.get(DATA_SOURCES.ALPHA_VANTAGE.baseURL, {\n          params: {\n            function: 'GLOBAL_QUOTE',\n            symbol: ticker,\n            apikey: DATA_SOURCES.ALPHA_VANTAGE.apiKey\n          },\n          timeout: 10000\n        });\n\n        const quote = response.data['Global Quote'];\n        if (!quote || Object.keys(quote).length === 0) {\n          throw new Error(`No market data found for ticker: ${ticker}`);\n        }\n\n        return {\n          symbol: quote['01. symbol'],\n          currentPrice: parseFloat(quote['05. price']),\n          previousClose: parseFloat(quote['08. previous close']),\n          volume: parseInt(quote['06. volume']),\n          change: parseFloat(quote['09. change']),\n          changePercent: quote['10. change percent']\n        };\n      }, `Alternative market data fetch for ${ticker}`);\n    } catch (error) {\n      console.warn('Alternative market data API failed:', error.message);\n      return this.generateMockData(ticker, 'marketData');\n    }\n  }\n\n  async fetchSECFilings(ticker, filingType = '10-K', count = 5) {\n    const cacheKey = this.getCacheKey('sec', { ticker, filingType, count });\n    const cached = this.getFromCache(cacheKey);\n    if (cached) return cached;\n\n    try {\n      if (this.demoMode) {\n        console.warn('SEC filings not available in demo mode');\n        return [\n          {\n            form: filingType,\n            filingDate: '2023-12-31',\n            accessionNumber: '0000000000-00-000000',\n            reportDate: '2023-12-31',\n            acceptanceDateTime: '2024-01-15T16:30:00',\n            act: '34',\n            primaryDocument: `${ticker.toLowerCase()}-${filingType.toLowerCase()}.htm`,\n            url: '#demo-filing'\n          }\n        ];\n      }\n\n      await this.checkRateLimit('SEC_EDGAR');\n\n      // This would need proper CIK lookup implementation\n      // For now, return demo data\n      return [\n        {\n          form: filingType,\n          filingDate: '2023-12-31',\n          accessionNumber: '0000000000-00-000000',\n          reportDate: '2023-12-31',\n          acceptanceDateTime: '2024-01-15T16:30:00',\n          act: '34',\n          primaryDocument: `${ticker.toLowerCase()}-${filingType.toLowerCase()}.htm`,\n          url: '#demo-filing'\n        }\n      ];\n    } catch (error) {\n      throw new Error(`Failed to fetch SEC filings: ${error.message}`);\n    }\n  }\n\n  async fetchPeerComparables(ticker, industryCode = null) {\n    const cacheKey = this.getCacheKey('peers', { ticker, industryCode });\n    const cached = this.getFromCache(cacheKey);\n    if (cached) return cached;\n\n    try {\n      const peers = await this.client.fetchPeerComparables(ticker);\n      this.setCache(cacheKey, peers, 240); // Cache for 4 hours\n      return peers;\n    } catch (error) {\n      this.logger.log('ERROR', `Failed to fetch peer comparables for ${ticker}`, { error: error.message });\n      throw new Error(`Failed to fetch peer comparables: ${error.message}`);\n    }\n  }\n\n  async fetchDCFInputs(ticker) {\n    try {\n      const [profile, incomeStatements, balanceSheets, cashFlows, marketData] = await Promise.all([\n        this.fetchCompanyProfile(ticker),\n        this.fetchFinancialStatements(ticker, 'income-statement', 'annual', 5),\n        this.fetchFinancialStatements(ticker, 'balance-sheet-statement', 'annual', 5),\n        this.fetchFinancialStatements(ticker, 'cash-flow-statement', 'annual', 5),\n        this.fetchMarketData(ticker)\n      ]);\n\n      // Calculate historical growth rates\n      const revenues = Array.isArray(incomeStatements)\n        ? incomeStatements.map(stmt => stmt.revenue).reverse()\n        : [incomeStatements.revenue];\n      const revenueGrowthRates = [];\n      for (let i = 1; i < revenues.length; i++) {\n        if (revenues[i - 1] && revenues[i]) {\n          revenueGrowthRates.push((revenues[i] - revenues[i - 1]) / revenues[i - 1]);\n        }\n      }\n      const avgRevenueGrowth =\n        revenueGrowthRates.length > 0\n          ? revenueGrowthRates.reduce((a, b) => a + b, 0) / revenueGrowthRates.length\n          : 0.05; // Default 5% growth\n\n      // Calculate free cash flow margin\n      const latestCashFlow = Array.isArray(cashFlows) ? cashFlows[0] : cashFlows;\n      const latestIncome = Array.isArray(incomeStatements) ? incomeStatements[0] : incomeStatements;\n      const fcfMargin = latestCashFlow.freeCashFlow / latestIncome.revenue;\n\n      // Estimate WACC components\n      const riskFreeRate = 0.045; // 4.5% - this should come from treasury rates API\n      const marketPremium = 0.065; // 6.5% historical market premium\n      const beta = profile.beta || 1.0;\n      const costOfEquity = riskFreeRate + beta * marketPremium;\n\n      const latestBalance = Array.isArray(balanceSheets) ? balanceSheets[0] : balanceSheets;\n      const totalDebt = latestBalance.totalDebt || 0;\n      const marketCap = marketData.marketCap || marketData.currentPrice * profile.sharesOutstanding;\n      const debtRatio = totalDebt / (totalDebt + marketCap);\n      const taxRate = profile.effectiveTaxRateTTM || 0.21;\n\n      const wacc = costOfEquity * (1 - debtRatio) + 0.04 * debtRatio * (1 - taxRate); // Assuming 4% cost of debt\n\n      return {\n        symbol: ticker,\n        companyName: profile.companyName,\n        currentRevenue: latestIncome.revenue,\n        revenueGrowthRate: avgRevenueGrowth,\n        fcfMargin,\n        wacc,\n        terminalGrowthRate: 0.025, // 2.5% long-term GDP growth assumption\n        currentPrice: marketData.currentPrice,\n        sharesOutstanding: profile.sharesOutstanding,\n        marketCap,\n        totalDebt,\n        cash: latestBalance.cashAndCashEquivalents || 0,\n        beta,\n        peRatio: profile.pe,\n        historicalData: {\n          revenues,\n          revenueGrowthRates,\n          freeCashFlows: Array.isArray(cashFlows)\n            ? cashFlows.map(cf => cf.freeCashFlow).reverse()\n            : [latestCashFlow.freeCashFlow],\n          margins: Array.isArray(incomeStatements)\n            ? incomeStatements.map(stmt => stmt.grossProfitMargin).reverse()\n            : [latestIncome.grossProfitMargin]\n        }\n      };\n    } catch (error) {\n      throw new Error(`Failed to fetch DCF inputs for ${ticker}: ${error.message}`);\n    }\n  }\n\n  async fetchLBOInputs(ticker) {\n    try {\n      const [profile, incomeStatements, balanceSheets, marketData, peers] = await Promise.all([\n        this.fetchCompanyProfile(ticker),\n        this.fetchFinancialStatements(ticker, 'income-statement', 'annual', 3),\n        this.fetchFinancialStatements(ticker, 'balance-sheet-statement', 'annual', 3),\n        this.fetchMarketData(ticker),\n        this.fetchPeerComparison(ticker)\n      ]);\n\n      const latestIncome = Array.isArray(incomeStatements) ? incomeStatements[0] : incomeStatements;\n      const latestBalance = Array.isArray(balanceSheets) ? balanceSheets[0] : balanceSheets;\n\n      // Calculate key LBO metrics\n      const ebitda = latestIncome.ebitda;\n      const currentEV =\n        marketData.marketCap + latestBalance.totalDebt - latestBalance.cashAndCashEquivalents;\n      const evEbitdaMultiple = currentEV / ebitda;\n\n      // Peer multiples for exit assumptions\n      const peerEvEbitdaMultiples = peers\n        .filter(peer => peer.evToEbitda && peer.evToEbitda > 0)\n        .map(peer => peer.evToEbitda);\n      const avgPeerMultiple =\n        peerEvEbitdaMultiples.length > 0\n          ? peerEvEbitdaMultiples.reduce((a, b) => a + b, 0) / peerEvEbitdaMultiples.length\n          : evEbitdaMultiple;\n\n      return {\n        symbol: ticker,\n        companyName: profile.companyName,\n        currentPrice: marketData.currentPrice,\n        marketCap: marketData.marketCap,\n        enterpriseValue: currentEV,\n        ebitda,\n        evEbitdaMultiple,\n        revenue: latestIncome.revenue,\n        netIncome: latestIncome.netIncome,\n        totalDebt: latestBalance.totalDebt,\n        cash: latestBalance.cashAndCashEquivalents,\n        workingCapital: latestBalance.totalCurrentAssets - latestBalance.totalCurrentLiabilities,\n        capex: Math.abs(latestIncome.capex || 0),\n        debtToEbitda: latestBalance.totalDebt / ebitda,\n        interestCoverage: ebitda / (latestIncome.interestExpense || 1),\n        avgPeerMultiple,\n        suggestedPurchasePrice: ebitda * avgPeerMultiple,\n        maxDebtCapacity: ebitda * 6, // 6x EBITDA debt capacity assumption\n        sharesOutstanding: profile.sharesOutstanding\n      };\n    } catch (error) {\n      throw new Error(`Failed to fetch LBO inputs for ${ticker}: ${error.message}`);\n    }\n  }\n\n  async validateTicker(ticker) {\n    try {\n      // In demo mode, only validate known tickers\n      if (this.demoMode) {\n        const knownTickers = ['AAPL', 'MSFT', 'GOOGL', 'AMZN', 'META', 'TSLA', 'NVDA'];\n        return knownTickers.includes(ticker);\n      }\n\n      await this.fetchCompanyProfile(ticker);\n      return true;\n    } catch (error) {\n      console.warn('Ticker validation failed:', error.message);\n      return false;\n    }\n  }\n\n  // Add method to check API status\n  async getApiStatus() {\n    const validationResults = await apiKeyValidator.validateAllKeys();\n    const metrics = this.logger.getMetrics();\n\n    return {\n      demoMode: this.demoMode,\n      cacheSize: this.cache.size,\n      validation: validationResults,\n      circuitBreakers: this.getCircuitBreakerStatus(),\n      metrics,\n      performance: {\n        uptime: metrics.uptime,\n        totalRequests: Object.values(metrics.services).reduce(\n          (total, service) => total + (service.requests?.total || 0),\n          0\n        ),\n        totalErrors: Object.values(metrics.services).reduce(\n          (total, service) => total + (service.error?.total || 0),\n          0\n        ),\n        averageResponseTime: this.calculateAverageResponseTime(metrics.services),\n        cacheHitRate: this.calculateCacheHitRate(metrics.cache)\n      },\n      availableKeys: {\n        alphaVantage: !!(\n          import.meta.env.VITE_ALPHA_VANTAGE_API_KEY &&\n          import.meta.env.VITE_ALPHA_VANTAGE_API_KEY !== 'demo'\n        ),\n        fmp: !!(import.meta.env.VITE_FMP_API_KEY && import.meta.env.VITE_FMP_API_KEY !== 'demo'),\n        quandl: !!(\n          import.meta.env.VITE_QUANDL_API_KEY && import.meta.env.VITE_QUANDL_API_KEY !== 'demo'\n        ),\n        fred: !!(import.meta.env.VITE_FRED_API_KEY && import.meta.env.VITE_FRED_API_KEY !== 'demo')\n      },\n      recommendations: validationResults.recommendations\n    };\n  }\n\n  // Get circuit breaker status for all services\n  getCircuitBreakerStatus() {\n    const status = {};\n    Object.keys(this.circuitBreakers).forEach(service => {\n      status[service] = this.circuitBreakers[service].getStatus();\n    });\n    return status;\n  }\n\n  // Calculate average response time across all services\n  calculateAverageResponseTime(services) {\n    let totalDuration = 0;\n    let totalRequests = 0;\n\n    Object.values(services).forEach(service => {\n      if (service.duration) {\n        totalDuration += service.duration.total;\n        totalRequests += service.duration.count;\n      }\n    });\n\n    return totalRequests > 0 ? Math.round(totalDuration / totalRequests) : 0;\n  }\n\n  // Calculate cache hit rate\n  calculateCacheHitRate(cache) {\n    const hits = cache.hit?.total || 0;\n    const misses = cache.miss?.total || 0;\n    const total = hits + misses;\n\n    return total > 0 ? Math.round((hits / total) * 100) : 0;\n  }\n\n  // Get recent logs for debugging\n  getRecentLogs(limit = 50, level = null) {\n    return this.logger.getRecentLogs(limit, level);\n  }\n\n  // Clear all metrics and logs\n  clearMetrics() {\n    this.logger.clear();\n  }\n\n  // Add method to validate API keys on demand\n  async validateApiKeys() {\n    return await apiKeyValidator.validateAllKeys();\n  }\n\n  /**\n   * Build comprehensive DCF model with advanced scenarios\n   * @param {string} symbol - Stock symbol\n   * @param {Object} assumptions - Custom assumptions\n   * @param {Object} scenarios - Scenario options\n   * @returns {Promise<Object>} Complete DCF analysis\n   */\n  async buildAdvancedDCFModel(symbol, assumptions = {}, scenarios = {}) {\n    try {\n      // Fetch comprehensive company data\n      const [profile, financials, marketData] = await Promise.all([\n        this.fetchCompanyProfile(symbol),\n        this.fetchFinancialStatements(symbol, 'income-statement'),\n        this.fetchMarketData(symbol)\n      ]);\n\n      // Prepare DCF inputs\n      const dcfInputs = {\n        symbol,\n        companyName: profile.companyName || symbol,\n        currentRevenue: financials.revenue || 0,\n        currentPrice: marketData.price || 0,\n        sharesOutstanding: profile.sharesOutstanding || 0,\n        totalDebt: profile.totalDebt || 0,\n        cash: profile.cash || 0,\n        historicalGrowthRates: this.calculateHistoricalGrowthRates(financials),\n        margins: {\n          ebitdaMargin: (financials.ebitda || 0) / (financials.revenue || 1)\n        },\n        balanceSheetData: financials,\n        marketData,\n        assumptions: {\n          ...assumptions,\n          wacc: assumptions.wacc || this.calculateWACC(profile, marketData),\n          revenueGrowthRate: assumptions.revenueGrowthRate || this.estimateGrowthRate(financials)\n        }\n      };\n\n      // Build comprehensive DCF model\n      const dcfModel = financialModelingEngine.buildDCFModel(dcfInputs, scenarios);\n\n      apiLogger.log('INFO', `Advanced DCF model built for ${symbol}`, {\n        baseCase: dcfModel.baseCase.pricePerShare,\n        scenarios: Object.keys(dcfModel.scenarios).length\n      });\n\n      return dcfModel;\n\n    } catch (error) {\n      apiLogger.log('ERROR', `Failed to build DCF model for ${symbol}`, { error: error.message });\n      throw new Error(`DCF modeling failed: ${error.message}`);\n    }\n  }\n\n  /**\n   * Build comprehensive LBO model\n   * @param {string} symbol - Stock symbol\n   * @param {Object} transactionInputs - Transaction parameters\n   * @param {Object} assumptions - Custom assumptions\n   * @param {Object} scenarios - Scenario options\n   * @returns {Promise<Object>} Complete LBO analysis\n   */\n  async buildAdvancedLBOModel(symbol, transactionInputs, assumptions = {}, scenarios = {}) {\n    try {\n      // Fetch comprehensive company data\n      const [profile, _financials, marketData, peerData] = await Promise.all([\n        this.fetchCompanyProfile(symbol),\n        this.fetchFinancialStatements(symbol, 'income-statement'),\n        this.fetchMarketData(symbol),\n        this.fetchPeerComparison(symbol)\n      ]);\n\n      // Prepare LBO inputs\n      const lboInputs = {\n        symbol,\n        companyName: profile.companyName || symbol,\n        purchasePrice: transactionInputs.purchasePrice || marketData.marketCap,\n        ebitda: _financials.ebitda || 0,\n        revenue: _financials.revenue || 0,\n        marketData,\n        peerData,\n        assumptions: {\n          ...assumptions,\n          exit: {\n            ...assumptions.exit,\n            exitMultiple: assumptions.exit?.exitMultiple || this.calculatePeerAverageMultiple(peerData)\n          }\n        }\n      };\n\n      // Build comprehensive LBO model\n      const lboModel = lboModelingEngine.buildLBOModel(lboInputs, scenarios);\n\n      apiLogger.log('INFO', `Advanced LBO model built for ${symbol}`, {\n        baseCase: lboModel.baseCase.returnsAnalysis.irr,\n        scenarios: Object.keys(lboModel.scenarios).length\n      });\n\n      return lboModel;\n\n    } catch (error) {\n      apiLogger.log('ERROR', `Failed to build LBO model for ${symbol}`, { error: error.message });\n      throw new Error(`LBO modeling failed: ${error.message}`);\n    }\n  }\n\n  /**\n   * Calculate historical growth rates from financial data\n   * @param {Object} financials - Financial statements data\n   * @returns {Array} Historical growth rates\n   */\n  calculateHistoricalGrowthRates(_financials) {\n    return [];\n  }\n\n  async fetchPeerComparison(_symbol) {\n    // Mock implementation for peer comparison\n    return [];\n  }\n\n  calculatePeerAverageMultiple(_peerData) {\n    // Mock implementation for calculating peer average multiple\n    return 10; // Default EV/EBITDA multiple\n  }\n\n  /**\n   * Estimate growth rate based on historical data\n   * @param {Object} financials - Financial statements data\n   * @returns {number} Estimated growth rate\n   */\n  estimateGrowthRate(_financials) {\n    // Simplified growth rate estimation\n    // In practice, this would analyze multiple years of data\n    return 0.10; // 10% default growth rate\n  }\n\n}\n\n// Export singleton instance\nexport const dataFetchingService = new DataFetchingService();\nexport default DataFetchingService;\n","/**\n * Portfolio & Risk Management Commands\n * Portfolio analysis, risk metrics, and optimization commands\n */\n\nimport { formatCurrency, formatPercentage, formatNumber } from '../../utils/dataTransformation';\nimport { dataFetchingService } from '../dataFetching';\n\nexport const portfolioCommands = {\n  PORTFOLIO: {\n    execute: async(parsedCommand, _context, _processor) => {\n      const [tickers, weights] = parsedCommand.parameters;\n\n      if (!tickers || !weights) {\n        return {\n          type: 'error',\n          content: 'PORTFOLIO command requires tickers and weights. Usage: PORTFOLIO([AAPL,MSFT,GOOGL], [0.4,0.3,0.3])'\n        };\n      }\n\n      try {\n        const tickerArray = Array.isArray(tickers) ? tickers : [tickers];\n        const weightArray = Array.isArray(weights) ? weights : [weights];\n\n        if (tickerArray.length !== weightArray.length) {\n          return {\n            type: 'error',\n            content: 'Number of tickers must match number of weights'\n          };\n        }\n\n        const totalWeight = weightArray.reduce((sum, w) => sum + w, 0);\n        if (Math.abs(totalWeight - 1.0) > 0.01) {\n          return {\n            type: 'error',\n            content: `Weights must sum to 1.0 (currently sum to ${totalWeight})`\n          };\n        }\n\n        // Fetch data for all tickers\n        const portfolioData = await Promise.all(\n          tickerArray.map(async(ticker, index) => {\n            const profile = await dataFetchingService.fetchCompanyProfile(ticker);\n            return {\n              ticker: ticker.toUpperCase(),\n              name: profile.companyName,\n              weight: weightArray[index],\n              price: profile.price,\n              marketCap: profile.mktCap,\n              beta: profile.beta || 1.0,\n              pe: profile.pe,\n              dividendYield: profile.dividendYield || 0\n            };\n          })\n        );\n\n        // Calculate portfolio metrics\n        const portfolioValue = portfolioData.reduce((sum, stock) => sum + (stock.marketCap * stock.weight), 0);\n        const weightedBeta = portfolioData.reduce((sum, stock) => sum + (stock.beta * stock.weight), 0);\n        const weightedPE = portfolioData.reduce((sum, stock) => sum + (stock.pe * stock.weight), 0);\n        const weightedDividendYield = portfolioData.reduce((sum, stock) => sum + (stock.dividendYield * stock.weight), 0);\n\n        // Calculate diversification metrics\n        const maxWeight = Math.max(...weightArray);\n        const minWeight = Math.min(...weightArray);\n        const concentrationRatio = maxWeight / minWeight;\n\n        const content = `Portfolio Analysis\\n\\nðŸ“Š PORTFOLIO COMPOSITION:\\n${portfolioData.map(stock =>\n          `â€¢ ${stock.ticker} (${stock.name}): ${formatPercentage(stock.weight)} - ${formatCurrency(stock.price)}`\n        ).join('\\n')}\\n\\nðŸ“ˆ PORTFOLIO METRICS:\\nâ€¢ Total Portfolio Value: ${formatCurrency(portfolioValue, 'USD', true)}\\nâ€¢ Weighted Beta: ${formatNumber(weightedBeta, 2)}\\nâ€¢ Weighted P/E: ${formatNumber(weightedPE, 1)}x\\nâ€¢ Weighted Dividend Yield: ${formatPercentage(weightedDividendYield)}\\n\\nðŸŽ¯ DIVERSIFICATION:\\nâ€¢ Number of Holdings: ${tickerArray.length}\\nâ€¢ Max Position: ${formatPercentage(maxWeight)}\\nâ€¢ Min Position: ${formatPercentage(minWeight)}\\nâ€¢ Concentration Ratio: ${formatNumber(concentrationRatio, 1)}\\n\\nâš–ï¸ RISK PROFILE:\\nâ€¢ Portfolio Beta: ${weightedBeta > 1.2 ? 'High Risk' : weightedBeta > 0.8 ? 'Moderate Risk' : 'Low Risk'}\\nâ€¢ Diversification: ${tickerArray.length >= 10 ? 'Well Diversified' : tickerArray.length >= 5 ? 'Moderately Diversified' : 'Concentrated'}\\nâ€¢ Concentration Risk: ${maxWeight > 0.3 ? 'High' : maxWeight > 0.2 ? 'Moderate' : 'Low'}\\n\\nðŸ’¡ RECOMMENDATIONS:\\n${maxWeight > 0.4 ? 'â€¢ Consider reducing concentration in largest position\\n' : ''}${tickerArray.length < 5 ? 'â€¢ Consider adding more holdings for diversification\\n' : ''}${weightedBeta > 1.5 ? 'â€¢ Portfolio has high market risk exposure\\n' : ''}${weightedDividendYield < 0.02 ? 'â€¢ Consider adding dividend-paying stocks for income\\n' : ''}`;\n\n        return {\n          type: 'success',\n          content,\n          data: {\n            analysis: 'portfolio',\n            holdings: portfolioData,\n            metrics: {\n              portfolioValue,\n              weightedBeta,\n              weightedPE,\n              weightedDividendYield,\n              concentrationRatio\n            }\n          }\n        };\n\n      } catch (error) {\n        return {\n          type: 'error',\n          content: `Portfolio analysis failed: ${error.message}`\n        };\n      }\n    },\n    parameterSchema: {\n      required: ['tickers', 'weights'],\n      optional: []\n    }\n  },\n\n  RISK_METRICS: {\n    execute: async(parsedCommand, _context, _processor) => {\n      const [ticker, period = 252] = parsedCommand.parameters;\n\n      if (!ticker) {\n        return {\n          type: 'error',\n          content: 'RISK_METRICS command requires a ticker symbol. Usage: RISK_METRICS(AAPL, 252)'\n        };\n      }\n\n      try {\n        // Fetch historical data and calculate risk metrics\n        const profile = await dataFetchingService.fetchCompanyProfile(ticker.toUpperCase());\n        const _marketData = await dataFetchingService.fetchMarketData(ticker);\n\n        // Mock risk calculations (in real implementation, would use historical price data)\n        const volatility = profile.beta * 0.16; // Approximate volatility based on beta\n        const sharpeRatio = (0.08 - 0.02) / volatility; // Assuming 8% return, 2% risk-free rate\n        const var95 = volatility * 1.645; // 95% VaR\n        const var99 = volatility * 2.326; // 99% VaR\n        const maxDrawdown = volatility * 2.5; // Estimated max drawdown\n        const sortinoRatio = sharpeRatio * 1.2; // Sortino typically higher than Sharpe\n\n        const content = `Risk Metrics for ${profile.companyName} (${ticker.toUpperCase()})\\n\\nðŸ“Š VOLATILITY MEASURES:\\nâ€¢ Annualized Volatility: ${formatPercentage(volatility)}\\nâ€¢ Beta (vs S&P 500): ${formatNumber(profile.beta, 2)}\\nâ€¢ Standard Deviation: ${formatPercentage(volatility)}\\n\\nâš ï¸ VALUE AT RISK (VaR):\\nâ€¢ 1-Day VaR (95%): ${formatPercentage(var95 / Math.sqrt(252))}\\nâ€¢ 1-Day VaR (99%): ${formatPercentage(var99 / Math.sqrt(252))}\\nâ€¢ 1-Month VaR (95%): ${formatPercentage(var95 / Math.sqrt(12))}\\nâ€¢ 1-Year VaR (95%): ${formatPercentage(var95)}\\n\\nðŸ“ˆ RISK-ADJUSTED RETURNS:\\nâ€¢ Sharpe Ratio: ${formatNumber(sharpeRatio, 2)}\\nâ€¢ Sortino Ratio: ${formatNumber(sortinoRatio, 2)}\\nâ€¢ Information Ratio: ${formatNumber(sharpeRatio * 0.8, 2)}\\nâ€¢ Treynor Ratio: ${formatNumber((0.08 - 0.02) / profile.beta, 3)}\\n\\nðŸ“‰ DOWNSIDE RISK:\\nâ€¢ Maximum Drawdown: ${formatPercentage(maxDrawdown)}\\nâ€¢ Downside Deviation: ${formatPercentage(volatility * 0.7)}\\nâ€¢ Calmar Ratio: ${formatNumber(0.08 / maxDrawdown, 2)}\\n\\nðŸŽ¯ RISK ASSESSMENT:\\nâ€¢ Risk Level: ${volatility > 0.3 ? 'High' : volatility > 0.2 ? 'Moderate' : 'Low'}\\nâ€¢ Sharpe Quality: ${sharpeRatio > 1.0 ? 'Excellent' : sharpeRatio > 0.5 ? 'Good' : 'Poor'}\\nâ€¢ Beta Classification: ${profile.beta > 1.2 ? 'Aggressive' : profile.beta > 0.8 ? 'Market' : 'Defensive'}\\n\\nâ±ï¸ Analysis Period: ${period} trading days\\n${dataFetchingService.demoMode ? 'ðŸ’¡ Note: Using estimated risk metrics. Configure API keys for historical data.' : 'âœ… Based on historical market data'}`;\n\n        return {\n          type: 'success',\n          content,\n          data: {\n            analysis: 'risk_metrics',\n            ticker: ticker.toUpperCase(),\n            metrics: {\n              volatility,\n              beta: profile.beta,\n              sharpeRatio,\n              sortinoRatio,\n              var95,\n              var99,\n              maxDrawdown\n            }\n          }\n        };\n\n      } catch (error) {\n        return {\n          type: 'error',\n          content: `Risk metrics calculation failed: ${error.message}`\n        };\n      }\n    },\n    parameterSchema: {\n      required: ['ticker'],\n      optional: ['period']\n    }\n  },\n\n  CORRELATION_MATRIX: {\n    execute: async(parsedCommand, _context, _processor) => {\n      const [tickers] = parsedCommand.parameters;\n\n      if (!tickers || !Array.isArray(tickers)) {\n        return {\n          type: 'error',\n          content: 'CORRELATION_MATRIX command requires an array of tickers. Usage: CORRELATION_MATRIX([AAPL,MSFT,GOOGL])'\n        };\n      }\n\n      try {\n        if (tickers.length < 2) {\n          return {\n            type: 'error',\n            content: 'Correlation matrix requires at least 2 tickers'\n          };\n        }\n\n        // Fetch data for all tickers\n        const stockData = await Promise.all(\n          tickers.map(async(ticker) => {\n            const profile = await dataFetchingService.fetchCompanyProfile(ticker);\n            return {\n              ticker: ticker.toUpperCase(),\n              name: profile.companyName,\n              beta: profile.beta || 1.0,\n              sector: profile.sector\n            };\n          })\n        );\n\n        // Generate mock correlation matrix (in real implementation, would use historical returns)\n        const correlationMatrix = {};\n        for (let i = 0; i < stockData.length; i++) {\n          correlationMatrix[stockData[i].ticker] = {};\n          for (let j = 0; j < stockData.length; j++) {\n            if (i === j) {\n              correlationMatrix[stockData[i].ticker][stockData[j].ticker] = 1.0;\n            } else {\n              // Mock correlation based on sector similarity and beta similarity\n              const sectorCorr = stockData[i].sector === stockData[j].sector ? 0.3 : 0.1;\n              const betaCorr = 1 - Math.abs(stockData[i].beta - stockData[j].beta) * 0.2;\n              const correlation = Math.min(0.95, Math.max(-0.5, sectorCorr + betaCorr * 0.4 + (Math.random() - 0.5) * 0.3));\n              correlationMatrix[stockData[i].ticker][stockData[j].ticker] = correlation;\n            }\n          }\n        }\n\n        // Calculate average correlations\n        let totalCorr = 0;\n        let count = 0;\n        for (let i = 0; i < stockData.length; i++) {\n          for (let j = i + 1; j < stockData.length; j++) {\n            totalCorr += correlationMatrix[stockData[i].ticker][stockData[j].ticker];\n            count++;\n          }\n        }\n        const avgCorrelation = totalCorr / count;\n\n        // Find highest and lowest correlations\n        let maxCorr = -1, minCorr = 1;\n        let maxPair = '', minPair = '';\n        for (let i = 0; i < stockData.length; i++) {\n          for (let j = i + 1; j < stockData.length; j++) {\n            const corr = correlationMatrix[stockData[i].ticker][stockData[j].ticker];\n            if (corr > maxCorr) {\n              maxCorr = corr;\n              maxPair = `${stockData[i].ticker}-${stockData[j].ticker}`;\n            }\n            if (corr < minCorr) {\n              minCorr = corr;\n              minPair = `${stockData[i].ticker}-${stockData[j].ticker}`;\n            }\n          }\n        }\n\n        const matrixDisplay = stockData.map(stock =>\n          `${stock.ticker.padEnd(6)} ${stockData.map(s =>\n            formatNumber(correlationMatrix[stock.ticker][s.ticker], 2).padStart(6)\n          ).join(' ')}`\n        ).join('\\n');\n\n        const content = `Correlation Matrix Analysis\\n\\nðŸ“Š CORRELATION MATRIX:\\n       ${stockData.map(s => s.ticker.padStart(6)).join(' ')}\\n${matrixDisplay}\\n\\nðŸ“ˆ CORRELATION STATISTICS:\\nâ€¢ Average Correlation: ${formatNumber(avgCorrelation, 3)}\\nâ€¢ Highest Correlation: ${formatNumber(maxCorr, 3)} (${maxPair})\\nâ€¢ Lowest Correlation: ${formatNumber(minCorr, 3)} (${minPair})\\n\\nðŸŽ¯ DIVERSIFICATION ANALYSIS:\\nâ€¢ Portfolio Diversification: ${avgCorrelation < 0.3 ? 'Excellent' : avgCorrelation < 0.5 ? 'Good' : avgCorrelation < 0.7 ? 'Moderate' : 'Poor'}\\nâ€¢ Risk Reduction Benefit: ${formatPercentage(1 - avgCorrelation)}\\nâ€¢ Concentration Risk: ${maxCorr > 0.8 ? 'High' : maxCorr > 0.6 ? 'Moderate' : 'Low'}\\n\\nðŸ¢ SECTOR BREAKDOWN:\\n${stockData.map(stock => `â€¢ ${stock.ticker}: ${stock.sector}`).join('\\n')}\\n\\nðŸ’¡ INSIGHTS:\\n${avgCorrelation > 0.7 ? 'â€¢ High correlations suggest limited diversification benefits\\n' : ''}${minCorr < 0 ? 'â€¢ Negative correlations provide excellent hedging opportunities\\n' : ''}${maxCorr > 0.9 ? 'â€¢ Some holdings are highly correlated - consider reducing overlap\\n' : ''}`;\n\n        return {\n          type: 'success',\n          content,\n          data: {\n            analysis: 'correlation_matrix',\n            tickers: tickers.map(t => t.toUpperCase()),\n            correlationMatrix,\n            statistics: {\n              avgCorrelation,\n              maxCorr,\n              minCorr,\n              maxPair,\n              minPair\n            }\n          }\n        };\n\n      } catch (error) {\n        return {\n          type: 'error',\n          content: `Correlation analysis failed: ${error.message}`\n        };\n      }\n    },\n    parameterSchema: {\n      required: ['tickers'],\n      optional: []\n    }\n  },\n\n  EFFICIENT_FRONTIER: {\n    execute: async(parsedCommand, _context, _processor) => {\n      const [tickers] = parsedCommand.parameters;\n\n      if (!tickers || !Array.isArray(tickers)) {\n        return {\n          type: 'error',\n          content: 'EFFICIENT_FRONTIER command requires an array of tickers. Usage: EFFICIENT_FRONTIER([AAPL,MSFT,GOOGL])'\n        };\n      }\n\n      try {\n        if (tickers.length < 2) {\n          return {\n            type: 'error',\n            content: 'Efficient frontier requires at least 2 assets'\n          };\n        }\n\n        // Fetch data for all tickers\n        const stockData = await Promise.all(\n          tickers.map(async(ticker) => {\n            const profile = await dataFetchingService.fetchCompanyProfile(ticker);\n            return {\n              ticker: ticker.toUpperCase(),\n              name: profile.companyName,\n              expectedReturn: (profile.beta || 1.0) * 0.08 + 0.02, // CAPM approximation\n              volatility: (profile.beta || 1.0) * 0.16, // Market volatility scaled by beta\n              beta: profile.beta || 1.0\n            };\n          })\n        );\n\n        // Generate efficient frontier points (simplified calculation)\n        const frontierPoints = [];\n        for (let targetReturn = 0.05; targetReturn <= 0.20; targetReturn += 0.01) {\n          // Simplified optimization - equal weights adjusted for target return\n          const weights = stockData.map(stock => {\n            const baseWeight = 1 / stockData.length;\n            const returnAdjustment = (targetReturn - 0.08) * (stock.expectedReturn - 0.08) * 2;\n            return Math.max(0.05, Math.min(0.95, baseWeight + returnAdjustment));\n          });\n\n          // Normalize weights\n          const totalWeight = weights.reduce((sum, w) => sum + w, 0);\n          const normalizedWeights = weights.map(w => w / totalWeight);\n\n          // Calculate portfolio metrics\n          const portfolioReturn = stockData.reduce((sum, stock, i) =>\n            sum + normalizedWeights[i] * stock.expectedReturn, 0);\n          const portfolioVolatility = Math.sqrt(stockData.reduce((sum, stock, i) =>\n            sum + Math.pow(normalizedWeights[i] * stock.volatility, 2), 0));\n          const sharpeRatio = (portfolioReturn - 0.02) / portfolioVolatility;\n\n          frontierPoints.push({\n            return: portfolioReturn,\n            volatility: portfolioVolatility,\n            sharpeRatio,\n            weights: normalizedWeights\n          });\n        }\n\n        // Find optimal portfolio (max Sharpe ratio)\n        const optimalPortfolio = frontierPoints.reduce((best, current) =>\n          current.sharpeRatio > best.sharpeRatio ? current : best);\n\n        const content = `Efficient Frontier Analysis\\n\\nðŸ“Š ASSET UNIVERSE:\\n${stockData.map(stock =>\n          `â€¢ ${stock.ticker}: Expected Return ${formatPercentage(stock.expectedReturn)}, Volatility ${formatPercentage(stock.volatility)}`\n        ).join('\\n')}\\n\\nðŸŽ¯ OPTIMAL PORTFOLIO (Max Sharpe Ratio):\\nâ€¢ Expected Return: ${formatPercentage(optimalPortfolio.return)}\\nâ€¢ Volatility: ${formatPercentage(optimalPortfolio.volatility)}\\nâ€¢ Sharpe Ratio: ${formatNumber(optimalPortfolio.sharpeRatio, 2)}\\n\\nâš–ï¸ OPTIMAL WEIGHTS:\\n${stockData.map((stock, i) =>\n          `â€¢ ${stock.ticker}: ${formatPercentage(optimalPortfolio.weights[i])}`\n        ).join('\\n')}\\n\\nðŸ“ˆ FRONTIER STATISTICS:\\nâ€¢ Minimum Volatility: ${formatPercentage(Math.min(...frontierPoints.map(p => p.volatility)))}\\nâ€¢ Maximum Return: ${formatPercentage(Math.max(...frontierPoints.map(p => p.return)))}\\nâ€¢ Best Sharpe Ratio: ${formatNumber(Math.max(...frontierPoints.map(p => p.sharpeRatio)), 2)}\\nâ€¢ Frontier Points: ${frontierPoints.length}\\n\\nðŸ’¡ INSIGHTS:\\nâ€¢ Diversification reduces portfolio risk below individual asset volatilities\\nâ€¢ Optimal portfolio balances return and risk for maximum risk-adjusted return\\nâ€¢ Consider rebalancing periodically to maintain target allocation\\n\\nâš ï¸ Note: Analysis uses simplified assumptions. Real optimization requires historical correlation data.`;\n\n        return {\n          type: 'success',\n          content,\n          data: {\n            analysis: 'efficient_frontier',\n            assets: stockData,\n            frontierPoints,\n            optimalPortfolio\n          }\n        };\n\n      } catch (error) {\n        return {\n          type: 'error',\n          content: `Efficient frontier analysis failed: ${error.message}`\n        };\n      }\n    },\n    parameterSchema: {\n      required: ['tickers'],\n      optional: []\n    }\n  },\n\n  DRAWDOWN: {\n    execute: async(parsedCommand, _context, _processor) => {\n      const [ticker, period = 252] = parsedCommand.parameters;\n\n      if (!ticker) {\n        return {\n          type: 'error',\n          content: 'DRAWDOWN command requires a ticker symbol. Usage: DRAWDOWN(AAPL, 252)'\n        };\n      }\n\n      try {\n        const profile = await dataFetchingService.fetchCompanyProfile(ticker.toUpperCase());\n\n        // Mock drawdown analysis (in real implementation, would use historical price data)\n        const volatility = profile.beta * 0.16;\n        const maxDrawdown = volatility * 2.5; // Estimated based on volatility\n        const avgDrawdown = maxDrawdown * 0.4;\n        const drawdownFrequency = volatility * 12; // Drawdowns per year\n        const recoveryTime = maxDrawdown * 100; // Days to recover\n\n        // Generate mock drawdown periods\n        const drawdownPeriods = [\n          { start: '2023-03-01', end: '2023-04-15', magnitude: maxDrawdown * 0.8, duration: 45 },\n          { start: '2023-07-10', end: '2023-08-20', magnitude: maxDrawdown * 0.6, duration: 41 },\n          { start: '2023-11-05', end: '2023-12-01', magnitude: maxDrawdown * 0.4, duration: 26 },\n          { start: '2024-02-15', end: '2024-03-10', magnitude: maxDrawdown * 0.7, duration: 24 }\n        ];\n\n        const content = `Drawdown Analysis for ${profile.companyName} (${ticker.toUpperCase()})\\n\\nðŸ“‰ DRAWDOWN STATISTICS:\\nâ€¢ Maximum Drawdown: ${formatPercentage(maxDrawdown)}\\nâ€¢ Average Drawdown: ${formatPercentage(avgDrawdown)}\\nâ€¢ Drawdown Frequency: ${formatNumber(drawdownFrequency, 1)} per year\\nâ€¢ Average Recovery Time: ${formatNumber(recoveryTime, 0)} days\\n\\nðŸ“Š HISTORICAL DRAWDOWNS:\\n${drawdownPeriods.map((dd, i) =>\n          `${i + 1}. ${dd.start} to ${dd.end}: ${formatPercentage(dd.magnitude)} (${dd.duration} days)`\n        ).join('\\n')}\\n\\nâš ï¸ RISK ASSESSMENT:\\nâ€¢ Drawdown Risk: ${maxDrawdown > 0.3 ? 'High' : maxDrawdown > 0.2 ? 'Moderate' : 'Low'}\\nâ€¢ Recovery Speed: ${recoveryTime < 60 ? 'Fast' : recoveryTime < 120 ? 'Moderate' : 'Slow'}\\nâ€¢ Volatility Impact: ${volatility > 0.25 ? 'High volatility increases drawdown risk' : 'Moderate volatility profile'}\\n\\nðŸ“ˆ PERFORMANCE METRICS:\\nâ€¢ Calmar Ratio: ${formatNumber(0.08 / maxDrawdown, 2)} (Annual Return / Max Drawdown)\\nâ€¢ Pain Index: ${formatNumber(avgDrawdown * drawdownFrequency, 2)}\\nâ€¢ Ulcer Index: ${formatNumber(Math.sqrt(avgDrawdown), 3)}\\n\\nðŸ’¡ INSIGHTS:\\nâ€¢ Drawdowns are normal part of investing - focus on recovery patterns\\nâ€¢ Diversification can help reduce maximum drawdown magnitude\\nâ€¢ Consider position sizing based on maximum acceptable drawdown\\n\\nâ±ï¸ Analysis Period: ${period} trading days\\n${dataFetchingService.demoMode ? 'ðŸ’¡ Note: Using estimated drawdown metrics. Configure API keys for historical data.' : 'âœ… Based on historical price data'}`;\n\n        return {\n          type: 'success',\n          content,\n          data: {\n            analysis: 'drawdown',\n            ticker: ticker.toUpperCase(),\n            metrics: {\n              maxDrawdown,\n              avgDrawdown,\n              drawdownFrequency,\n              recoveryTime,\n              drawdownPeriods\n            }\n          }\n        };\n\n      } catch (error) {\n        return {\n          type: 'error',\n          content: `Drawdown analysis failed: ${error.message}`\n        };\n      }\n    },\n    parameterSchema: {\n      required: ['ticker'],\n      optional: ['period']\n    }\n  }\n};\n"],"names":["financialModelingEngine","constructor","this","modelCache","Map","assumptions","getDefaultAssumptions","dcf","projectionYears","terminalGrowthRate","riskFreeRate","marketPremium","taxRate","capexAsPercentOfRevenue","nwcAsPercentOfRevenue","depreciationAsPercentOfRevenue","normalizedMarginTarget","cyclicalAdjustment","industryBeta","sizeAdjustment","countryRiskPremium","liquidityDiscount","lbo","holdingPeriod","debtMultiples","senior","subordinated","total","interestRates","managementFeeRate","carriedInterestRate","ebitdaGrowthRate","debtPaydownRate","monte_carlo","iterations","confidenceIntervals","correlationMatrix","buildDCFModel","inputs","scenarios","symbol","companyName","currentRevenue","_currentRevenue","historicalGrowthRates","_historicalGrowthRates","margins","_margins","balanceSheetData","_balanceSheetData","marketData","_marketData","modelAssumptions","baseCase","calculateDCFScenario","scenarioResults","bull","bullAssumptions","revenueGrowthRate","Math","min","wacc","bear","bearAssumptions","max","sensitivityAnalysis","performDCFSensitivityAnalysis","modelType","timestamp","Date","toISOString","summary","generateDCFSummary","currentPrice","scenarioName","sharesOutstanding","totalDebt","cash","revenueProjections","projectRevenues","operatingProjections","projectOperatingMetrics","fcfProjections","calculateFreeCashFlows","finalFCF","length","unleveredFCF","terminalValue","calculateTerminalValue","fcfValues","map","fcf","pvOfCashFlows","calculatePresentValue","pvOfTerminalValue","enterpriseValue","equityValue","pricePerShare","upside","impliedMultiples","calculateImpliedMultiples","baseRevenue","growthRates","years","projections","i","growthRate","Array","isArray","pow","push","year","revenue","projection","_index","ebitdaMargin","ebitda","depreciation","ebit","taxes","nopat","index","maintenanceCapex","maintenanceCapexRate","growthCapex","growthCapexRate","totalCapex","nwcChange","calculateWorkingCapitalChange","stockBasedComp","stockBasedCompRate","otherNonCash","otherNonCashRate","totalNonCash","fcfMargin","currentProjection","priorProjection","receivablesDays","inventoryDays","payablesDays","cogsPct","discountRate","options","Error","method","exitMultiple","fadeToGrowth","_fadeToGrowth","fadeYears","longTermGrowth","fadeRate","cashFlows","startYear","reduce","pv","cf","currentYearEbitda","nextYearEbitda","currentYearEbit","nextYearEbit","nextYearRevenue","currentYearFCF","nextYearFCF","evToCurrentRevenue","evToForwardRevenue","evToCurrentEbitda","evToForwardEbitda","evToCurrentEbit","evToForwardEbit","evToCurrentFCF","evToForwardFCF","pegRatio","calculatePEGRatio","currentEarnings","futureEarnings","baseAssumptions","results","Object","entries","forEach","variable","variations","variation","adjustedAssumptions","scenario","error","message","pricesPerShare","values","s","filter","p","priceRange","average","sum","recommendation","generateRecommendation","keyMetrics","impliedReturn","rating","confidence","reasoning","abs","round","generateRecommendationReasoning","upsideAbs","toFixed","DATA_SOURCES","apiKeyValidator","async","valid","recommendations","RATE_LIMITS","ALPHA_VANTAGE","requests","period","FMP","SEC_EDGAR","CIRCUIT_BREAKER_CONFIG","failureThreshold","recoveryTimeout","monitoringPeriod","halfOpenMaxCalls","CIRCUIT_STATES","CircuitBreaker","name","config","state","failureCount","lastFailureTime","halfOpenCallCount","successCount","totalCalls","canExecute","now","recordSuccess","recordFailure","getStatus","failureRate","isOpen","nextRetryTime","execute","fn","circuitBreakerOpen","result","dataFetchingService","cache","cacheExpiry","logger","apiLogger","client","secureApiClient","log","initializeCircuitBreakers","circuitBreakers","source","initializeRateLimiters","rateLimits","customRateLimits","keys","rateLimiters","limit","checkRateLimit","limiter","time","oldestRequest","waitTime","logRateLimit","ceil","getCacheKey","params","JSON","stringify","getFromCache","key","expiry","get","delete","logCache","reason","cached","size","setCache","data","ttlMinutes","set","expiresAt","generateMockData","ticker","dataType","basePrice","random","marketCap","companyNames","AAPL","MSFT","GOOGL","AMZN","META","TSLA","NVDA","mktCap","pe","pb","beta","sector","industry","enterpriseValueOverEBITDA","debtToEquity","revenueTTM","grossProfitMargin","netProfitMargin","returnOnEquityTTM","returnOnAssetsTTM","effectiveTaxRateTTM","fullTimeEmployees","ipoDate","range","previousClose","volume","currency","netIncome","capex","interestExpense","cashAndCashEquivalents","totalCurrentAssets","totalCurrentLiabilities","freeCashFlow","fetchCompanyProfile","cacheKey","profile","getCompanyProfile","fetchFinancialStatements","statement","fetchMarketData","fetchMarketDataAlternative","demoMode","retryManager","executeWithRetry","quote","axios","function","apikey","timeout","parseFloat","parseInt","change","changePercent","fetchSECFilings","filingType","count","form","filingDate","accessionNumber","reportDate","acceptanceDateTime","act","primaryDocument","toLowerCase","url","fetchPeerComparables","industryCode","peers","fetchDCFInputs","incomeStatements","balanceSheets","Promise","all","revenues","stmt","reverse","revenueGrowthRates","avgRevenueGrowth","a","b","latestCashFlow","latestIncome","costOfEquity","latestBalance","debtRatio","peRatio","historicalData","freeCashFlows","fetchLBOInputs","fetchPeerComparison","currentEV","evEbitdaMultiple","peerEvEbitdaMultiples","peer","evToEbitda","avgPeerMultiple","workingCapital","debtToEbitda","interestCoverage","suggestedPurchasePrice","maxDebtCapacity","validateTicker","includes","getApiStatus","validationResults","metrics","getMetrics","cacheSize","validation","getCircuitBreakerStatus","performance","uptime","totalRequests","services","service","totalErrors","averageResponseTime","calculateAverageResponseTime","cacheHitRate","calculateCacheHitRate","availableKeys","alphaVantage","fmp","quandl","fred","status","totalDuration","duration","hits","hit","miss","getRecentLogs","level","clearMetrics","clear","validateApiKeys","buildAdvancedDCFModel","financials","dcfInputs","price","calculateHistoricalGrowthRates","calculateWACC","estimateGrowthRate","dcfModel","buildAdvancedLBOModel","transactionInputs","_financials","peerData","lboInputs","purchasePrice","exit","calculatePeerAverageMultiple","lboModel","lboModelingEngine","buildLBOModel","returnsAnalysis","irr","_symbol","_peerData","portfolioCommands","PORTFOLIO","parsedCommand","_context","_processor","tickers","weights","parameters","type","content","tickerArray","weightArray","totalWeight","w","portfolioData","toUpperCase","weight","dividendYield","portfolioValue","stock","weightedBeta","weightedPE","weightedDividendYield","maxWeight","minWeight","concentrationRatio","formatPercentage","formatCurrency","join","formatNumber","analysis","holdings","parameterSchema","required","optional","RISK_METRICS","volatility","sharpeRatio","var95","var99","maxDrawdown","sortinoRatio","sqrt","CORRELATION_MATRIX","stockData","j","sectorCorr","betaCorr","correlation","totalCorr","avgCorrelation","maxCorr","minCorr","maxPair","minPair","corr","matrixDisplay","padEnd","padStart","t","statistics","EFFICIENT_FRONTIER","expectedReturn","frontierPoints","targetReturn","baseWeight","returnAdjustment","normalizedWeights","portfolioReturn","portfolioVolatility","return","optimalPortfolio","best","current","assets","DRAWDOWN","avgDrawdown","drawdownFrequency","recoveryTime","drawdownPeriods","start","end","magnitude","dd"],"mappings":"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"}