{"version":3,"file":"persistence-CVb4Ip9D.js","sources":["../../src/services/utils/CryptoUtils.js","../../src/services/utils/CompressionUtils.js","../../src/services/persistence/LocalStorageService.js","../../src/services/persistence/IndexedDBService.js","../../src/services/persistence/SessionManager.js","../../src/services/persistence/DataMigrationService.js","../../src/services/persistence/PersistenceManager.js","../../src/services/persistence/BackupService.js","../../src/services/persistence/PrivacyService.js","../../src/services/persistence/SyncService.js","../../src/services/persistence/PersistenceTestSuite.js"],"sourcesContent":["/**\n * Crypto Utils\n * Provides encryption and decryption utilities for data persistence\n */\n\nexport class CryptoUtils {\n  constructor() {\n    this.algorithm = 'AES-GCM';\n    this.keyLength = 256;\n    this.ivLength = 12; // 96 bits for GCM\n    this.tagLength = 16; // 128 bits for GCM\n    this.textEncoder = new TextEncoder();\n    this.textDecoder = new TextDecoder();\n    \n    // Generate or retrieve encryption key\n    this.initializeKey();\n  }\n\n  /**\n   * Initialize encryption key\n   */\n  async initializeKey() {\n    try {\n      // Try to get existing key from localStorage\n      const storedKey = localStorage.getItem('financeanalyst_crypto_key');\n      \n      if (storedKey) {\n        // Import existing key\n        const keyData = this.base64ToArrayBuffer(storedKey);\n        this.cryptoKey = await crypto.subtle.importKey(\n          'raw',\n          keyData,\n          { name: this.algorithm },\n          false,\n          ['encrypt', 'decrypt']\n        );\n      } else {\n        // Generate new key\n        this.cryptoKey = await crypto.subtle.generateKey(\n          {\n            name: this.algorithm,\n            length: this.keyLength\n          },\n          true,\n          ['encrypt', 'decrypt']\n        );\n\n        // Store key for future use\n        const exportedKey = await crypto.subtle.exportKey('raw', this.cryptoKey);\n        const keyString = this.arrayBufferToBase64(exportedKey);\n        localStorage.setItem('financeanalyst_crypto_key', keyString);\n      }\n\n      console.log('✅ Crypto key initialized');\n    } catch (error) {\n      console.error('❌ Failed to initialize crypto key:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Encrypt data\n   */\n  async encrypt(data) {\n    if (!this.cryptoKey) {\n      await this.initializeKey();\n    }\n\n    try {\n      // Convert string to ArrayBuffer\n      const dataBuffer = this.textEncoder.encode(data);\n      \n      // Generate random IV\n      const iv = crypto.getRandomValues(new Uint8Array(this.ivLength));\n      \n      // Encrypt data\n      const encryptedBuffer = await crypto.subtle.encrypt(\n        {\n          name: this.algorithm,\n          iv: iv\n        },\n        this.cryptoKey,\n        dataBuffer\n      );\n\n      // Combine IV and encrypted data\n      const combined = new Uint8Array(iv.length + encryptedBuffer.byteLength);\n      combined.set(iv, 0);\n      combined.set(new Uint8Array(encryptedBuffer), iv.length);\n\n      // Convert to base64 for storage\n      return this.arrayBufferToBase64(combined.buffer);\n\n    } catch (error) {\n      console.error('Encryption failed:', error);\n      throw new Error(`Encryption failed: ${error.message}`);\n    }\n  }\n\n  /**\n   * Decrypt data\n   */\n  async decrypt(encryptedData) {\n    if (!this.cryptoKey) {\n      await this.initializeKey();\n    }\n\n    try {\n      // Convert base64 to ArrayBuffer\n      const combined = this.base64ToArrayBuffer(encryptedData);\n      \n      // Extract IV and encrypted data\n      const iv = combined.slice(0, this.ivLength);\n      const encryptedBuffer = combined.slice(this.ivLength);\n\n      // Decrypt data\n      const decryptedBuffer = await crypto.subtle.decrypt(\n        {\n          name: this.algorithm,\n          iv: iv\n        },\n        this.cryptoKey,\n        encryptedBuffer\n      );\n\n      // Convert back to string\n      return this.textDecoder.decode(decryptedBuffer);\n\n    } catch (error) {\n      console.error('Decryption failed:', error);\n      throw new Error(`Decryption failed: ${error.message}`);\n    }\n  }\n\n  /**\n   * Generate hash of data\n   */\n  async hash(data) {\n    try {\n      const dataBuffer = this.textEncoder.encode(data);\n      const hashBuffer = await crypto.subtle.digest('SHA-256', dataBuffer);\n      return this.arrayBufferToBase64(hashBuffer);\n    } catch (error) {\n      console.error('Hashing failed:', error);\n      throw new Error(`Hashing failed: ${error.message}`);\n    }\n  }\n\n  /**\n   * Verify data integrity\n   */\n  async verifyIntegrity(data, expectedHash) {\n    try {\n      const actualHash = await this.hash(data);\n      return actualHash === expectedHash;\n    } catch (error) {\n      console.error('Integrity verification failed:', error);\n      return false;\n    }\n  }\n\n  /**\n   * Generate secure random string\n   */\n  generateRandomString(length = 32) {\n    const array = new Uint8Array(length);\n    crypto.getRandomValues(array);\n    return this.arrayBufferToBase64(array.buffer).substring(0, length);\n  }\n\n  /**\n   * Derive key from password (for future use)\n   */\n  async deriveKeyFromPassword(password, salt) {\n    try {\n      const passwordBuffer = this.textEncoder.encode(password);\n      const saltBuffer = this.textEncoder.encode(salt);\n\n      // Import password as key material\n      const keyMaterial = await crypto.subtle.importKey(\n        'raw',\n        passwordBuffer,\n        { name: 'PBKDF2' },\n        false,\n        ['deriveKey']\n      );\n\n      // Derive key using PBKDF2\n      const derivedKey = await crypto.subtle.deriveKey(\n        {\n          name: 'PBKDF2',\n          salt: saltBuffer,\n          iterations: 100000,\n          hash: 'SHA-256'\n        },\n        keyMaterial,\n        {\n          name: this.algorithm,\n          length: this.keyLength\n        },\n        false,\n        ['encrypt', 'decrypt']\n      );\n\n      return derivedKey;\n\n    } catch (error) {\n      console.error('Key derivation failed:', error);\n      throw new Error(`Key derivation failed: ${error.message}`);\n    }\n  }\n\n  /**\n   * Check if Web Crypto API is available\n   */\n  isAvailable() {\n    return !!(window.crypto && window.crypto.subtle);\n  }\n\n  /**\n   * Get encryption info\n   */\n  getInfo() {\n    return {\n      algorithm: this.algorithm,\n      keyLength: this.keyLength,\n      ivLength: this.ivLength,\n      available: this.isAvailable(),\n      keyInitialized: !!this.cryptoKey\n    };\n  }\n\n  // Utility methods\n\n  /**\n   * Convert ArrayBuffer to base64 string\n   */\n  arrayBufferToBase64(buffer) {\n    const bytes = new Uint8Array(buffer);\n    let binary = '';\n    for (let i = 0; i < bytes.byteLength; i++) {\n      binary += String.fromCharCode(bytes[i]);\n    }\n    return btoa(binary);\n  }\n\n  /**\n   * Convert base64 string to ArrayBuffer\n   */\n  base64ToArrayBuffer(base64) {\n    const binary = atob(base64);\n    const bytes = new Uint8Array(binary.length);\n    for (let i = 0; i < binary.length; i++) {\n      bytes[i] = binary.charCodeAt(i);\n    }\n    return bytes.buffer;\n  }\n\n  /**\n   * Securely clear sensitive data from memory\n   */\n  clearSensitiveData(data) {\n    if (data instanceof ArrayBuffer) {\n      const view = new Uint8Array(data);\n      crypto.getRandomValues(view);\n    } else if (typeof data === 'string') {\n      // For strings, we can't directly clear memory in JavaScript\n      // but we can at least overwrite the reference\n      data = null;\n    }\n  }\n\n  /**\n   * Test encryption/decryption performance\n   */\n  async performanceTest() {\n    if (!this.isAvailable()) {\n      return null;\n    }\n\n    const testData = JSON.stringify({\n      test: 'performance',\n      data: new Array(1000).fill('test data for performance testing'),\n      timestamp: Date.now()\n    });\n\n    const iterations = 50;\n\n    try {\n      // Test encryption performance\n      const encryptStart = performance.now();\n      let encrypted;\n      for (let i = 0; i < iterations; i++) {\n        encrypted = await this.encrypt(testData);\n      }\n      const encryptTime = performance.now() - encryptStart;\n\n      // Test decryption performance\n      const decryptStart = performance.now();\n      for (let i = 0; i < iterations; i++) {\n        await this.decrypt(encrypted);\n      }\n      const decryptTime = performance.now() - decryptStart;\n\n      return {\n        encryptTime: encryptTime / iterations,\n        decryptTime: decryptTime / iterations,\n        totalTime: encryptTime + decryptTime,\n        dataSize: testData.length,\n        encryptedSize: encrypted.length,\n        compressionRatio: encrypted.length / testData.length,\n        iterations\n      };\n\n    } catch (error) {\n      console.error('Crypto performance test failed:', error);\n      return null;\n    }\n  }\n}\n","/**\n * Compression Utils\n * Provides data compression utilities for efficient storage\n */\n\nexport class CompressionUtils {\n  constructor() {\n    this.compressionFormat = 'gzip';\n    this.textEncoder = new TextEncoder();\n    this.textDecoder = new TextDecoder();\n  }\n\n  /**\n   * Compress data using browser's native compression\n   */\n  async compress(data) {\n    try {\n      // Check if CompressionStream is available (modern browsers)\n      if ('CompressionStream' in window) {\n        return await this.compressWithStream(data);\n      } else {\n        // Fallback to LZ-string compression\n        return await this.compressWithLZString(data);\n      }\n    } catch (error) {\n      console.error('Compression failed:', error);\n      // Return original data if compression fails\n      return data;\n    }\n  }\n\n  /**\n   * Decompress data\n   */\n  async decompress(compressedData) {\n    try {\n      // Try native decompression first\n      if ('DecompressionStream' in window && this.isNativeCompressed(compressedData)) {\n        return await this.decompressWithStream(compressedData);\n      } else {\n        // Try LZ-string decompression\n        return await this.decompressWithLZString(compressedData);\n      }\n    } catch (error) {\n      console.error('Decompression failed:', error);\n      // Return original data if decompression fails\n      return compressedData;\n    }\n  }\n\n  /**\n   * Compress using native CompressionStream\n   */\n  async compressWithStream(data) {\n    const stream = new CompressionStream(this.compressionFormat);\n    const writer = stream.writable.getWriter();\n    const reader = stream.readable.getReader();\n\n    // Write data to compression stream\n    const dataBuffer = this.textEncoder.encode(data);\n    writer.write(dataBuffer);\n    writer.close();\n\n    // Read compressed data\n    const chunks = [];\n    let done = false;\n    \n    while (!done) {\n      const { value, done: readerDone } = await reader.read();\n      done = readerDone;\n      if (value) {\n        chunks.push(value);\n      }\n    }\n\n    // Combine chunks and convert to base64\n    const totalLength = chunks.reduce((sum, chunk) => sum + chunk.length, 0);\n    const combined = new Uint8Array(totalLength);\n    let offset = 0;\n    \n    for (const chunk of chunks) {\n      combined.set(chunk, offset);\n      offset += chunk.length;\n    }\n\n    // Add marker to identify native compression\n    return 'NATIVE_GZIP:' + this.arrayBufferToBase64(combined.buffer);\n  }\n\n  /**\n   * Decompress using native DecompressionStream\n   */\n  async decompressWithStream(compressedData) {\n    // Remove marker\n    const data = compressedData.replace('NATIVE_GZIP:', '');\n    const compressedBuffer = this.base64ToArrayBuffer(data);\n\n    const stream = new DecompressionStream(this.compressionFormat);\n    const writer = stream.writable.getWriter();\n    const reader = stream.readable.getReader();\n\n    // Write compressed data to decompression stream\n    writer.write(new Uint8Array(compressedBuffer));\n    writer.close();\n\n    // Read decompressed data\n    const chunks = [];\n    let done = false;\n    \n    while (!done) {\n      const { value, done: readerDone } = await reader.read();\n      done = readerDone;\n      if (value) {\n        chunks.push(value);\n      }\n    }\n\n    // Combine chunks and convert to string\n    const totalLength = chunks.reduce((sum, chunk) => sum + chunk.length, 0);\n    const combined = new Uint8Array(totalLength);\n    let offset = 0;\n    \n    for (const chunk of chunks) {\n      combined.set(chunk, offset);\n      offset += chunk.length;\n    }\n\n    return this.textDecoder.decode(combined);\n  }\n\n  /**\n   * Compress using LZ-string algorithm (fallback)\n   */\n  async compressWithLZString(data) {\n    // Simple LZ77-style compression implementation\n    const dictionary = new Map();\n    const result = [];\n    let dictSize = 256;\n    \n    // Initialize dictionary with single characters\n    for (let i = 0; i < 256; i++) {\n      dictionary.set(String.fromCharCode(i), i);\n    }\n\n    let current = '';\n    for (let i = 0; i < data.length; i++) {\n      const char = data[i];\n      const combined = current + char;\n      \n      if (dictionary.has(combined)) {\n        current = combined;\n      } else {\n        result.push(dictionary.get(current));\n        dictionary.set(combined, dictSize++);\n        current = char;\n      }\n    }\n    \n    if (current) {\n      result.push(dictionary.get(current));\n    }\n\n    // Convert to base64\n    const compressed = new Uint16Array(result);\n    return 'LZ_STRING:' + this.arrayBufferToBase64(compressed.buffer);\n  }\n\n  /**\n   * Decompress LZ-string compressed data\n   */\n  async decompressWithLZString(compressedData) {\n    // Remove marker\n    const data = compressedData.replace('LZ_STRING:', '');\n    const buffer = this.base64ToArrayBuffer(data);\n    const compressed = new Uint16Array(buffer);\n\n    const dictionary = new Map();\n    let dictSize = 256;\n    \n    // Initialize dictionary\n    for (let i = 0; i < 256; i++) {\n      dictionary.set(i, String.fromCharCode(i));\n    }\n\n    let result = '';\n    let previous = String.fromCharCode(compressed[0]);\n    result += previous;\n\n    for (let i = 1; i < compressed.length; i++) {\n      const code = compressed[i];\n      let current;\n      \n      if (dictionary.has(code)) {\n        current = dictionary.get(code);\n      } else if (code === dictSize) {\n        current = previous + previous[0];\n      } else {\n        throw new Error('Invalid compressed data');\n      }\n      \n      result += current;\n      dictionary.set(dictSize++, previous + current[0]);\n      previous = current;\n    }\n\n    return result;\n  }\n\n  /**\n   * Check if data is compressed with native compression\n   */\n  isNativeCompressed(data) {\n    return typeof data === 'string' && data.startsWith('NATIVE_GZIP:');\n  }\n\n  /**\n   * Check if data is compressed with LZ-string\n   */\n  isLZStringCompressed(data) {\n    return typeof data === 'string' && data.startsWith('LZ_STRING:');\n  }\n\n  /**\n   * Check if data appears to be compressed\n   */\n  isCompressed(data) {\n    return this.isNativeCompressed(data) || this.isLZStringCompressed(data);\n  }\n\n  /**\n   * Get compression ratio\n   */\n  getCompressionRatio(originalData, compressedData) {\n    const originalSize = new Blob([originalData]).size;\n    const compressedSize = new Blob([compressedData]).size;\n    return compressedSize / originalSize;\n  }\n\n  /**\n   * Estimate compression benefit\n   */\n  async estimateCompressionBenefit(data) {\n    try {\n      const originalSize = new Blob([data]).size;\n      const compressed = await this.compress(data);\n      const compressedSize = new Blob([compressed]).size;\n      \n      return {\n        originalSize,\n        compressedSize,\n        ratio: compressedSize / originalSize,\n        savings: originalSize - compressedSize,\n        savingsPercentage: ((originalSize - compressedSize) / originalSize) * 100,\n        worthCompressing: compressedSize < originalSize * 0.9 // 10% savings threshold\n      };\n    } catch (error) {\n      return {\n        originalSize: new Blob([data]).size,\n        compressedSize: new Blob([data]).size,\n        ratio: 1,\n        savings: 0,\n        savingsPercentage: 0,\n        worthCompressing: false,\n        error: error.message\n      };\n    }\n  }\n\n  /**\n   * Check if compression is available\n   */\n  isAvailable() {\n    return 'CompressionStream' in window || true; // LZ-string fallback always available\n  }\n\n  /**\n   * Get compression info\n   */\n  getInfo() {\n    return {\n      nativeCompressionAvailable: 'CompressionStream' in window,\n      fallbackAvailable: true,\n      defaultFormat: this.compressionFormat,\n      available: this.isAvailable()\n    };\n  }\n\n  /**\n   * Test compression performance\n   */\n  async performanceTest() {\n    const testData = JSON.stringify({\n      test: 'compression performance',\n      data: new Array(1000).fill('This is test data for compression performance testing. '.repeat(10)),\n      numbers: new Array(100).fill(0).map((_, i) => i),\n      timestamp: Date.now()\n    });\n\n    const iterations = 20;\n\n    try {\n      // Test compression performance\n      const compressStart = performance.now();\n      let compressed;\n      for (let i = 0; i < iterations; i++) {\n        compressed = await this.compress(testData);\n      }\n      const compressTime = performance.now() - compressStart;\n\n      // Test decompression performance\n      const decompressStart = performance.now();\n      for (let i = 0; i < iterations; i++) {\n        await this.decompress(compressed);\n      }\n      const decompressTime = performance.now() - decompressStart;\n\n      const compressionRatio = this.getCompressionRatio(testData, compressed);\n\n      return {\n        compressTime: compressTime / iterations,\n        decompressTime: decompressTime / iterations,\n        totalTime: compressTime + decompressTime,\n        originalSize: testData.length,\n        compressedSize: compressed.length,\n        compressionRatio,\n        savingsPercentage: (1 - compressionRatio) * 100,\n        iterations,\n        method: this.isNativeCompressed(compressed) ? 'native' : 'lz-string'\n      };\n\n    } catch (error) {\n      console.error('Compression performance test failed:', error);\n      return null;\n    }\n  }\n\n  // Utility methods\n\n  /**\n   * Convert ArrayBuffer to base64 string\n   */\n  arrayBufferToBase64(buffer) {\n    const bytes = new Uint8Array(buffer);\n    let binary = '';\n    for (let i = 0; i < bytes.byteLength; i++) {\n      binary += String.fromCharCode(bytes[i]);\n    }\n    return btoa(binary);\n  }\n\n  /**\n   * Convert base64 string to ArrayBuffer\n   */\n  base64ToArrayBuffer(base64) {\n    const binary = atob(base64);\n    const bytes = new Uint8Array(binary.length);\n    for (let i = 0; i < binary.length; i++) {\n      bytes[i] = binary.charCodeAt(i);\n    }\n    return bytes.buffer;\n  }\n}\n","/**\n * Local Storage Service\n * Manages localStorage operations with encryption, compression, and data validation\n */\n\nimport { CryptoUtils } from '../utils/CryptoUtils';\nimport { CompressionUtils } from '../utils/CompressionUtils';\n\nexport class LocalStorageService {\n  constructor() {\n    this.prefix = 'financeanalyst_';\n    this.isAvailable = false;\n    this.maxSize = 5 * 1024 * 1024; // 5MB typical localStorage limit\n    this.cryptoUtils = new CryptoUtils();\n    this.compressionUtils = new CompressionUtils();\n  }\n\n  /**\n   * Initialize the localStorage service\n   */\n  async initialize() {\n    try {\n      // Test localStorage availability\n      const testKey = this.prefix + 'test';\n      localStorage.setItem(testKey, 'test');\n      localStorage.removeItem(testKey);\n      \n      this.isAvailable = true;\n      console.log('✅ LocalStorage service initialized');\n      \n      return { success: true, available: true };\n    } catch (error) {\n      console.warn('⚠️ LocalStorage not available:', error);\n      this.isAvailable = false;\n      return { success: false, available: false, error: error.message };\n    }\n  }\n\n  /**\n   * Store data in localStorage\n   */\n  async store(key, data, options = {}) {\n    if (!this.isAvailable) {\n      throw new Error('localStorage is not available');\n    }\n\n    const {\n      encrypt = false,\n      compress = false,\n      ttl = null,\n      validate = true\n    } = options;\n\n    try {\n      // Validate data if requested\n      if (validate && !this.validateData(data)) {\n        throw new Error('Invalid data format');\n      }\n\n      // Prepare storage object\n      const storageObject = {\n        data,\n        metadata: {\n          timestamp: Date.now(),\n          version: '1.0',\n          encrypted: encrypt,\n          compressed: compress,\n          ttl,\n          originalSize: JSON.stringify(data).length\n        }\n      };\n\n      let serializedData = JSON.stringify(storageObject);\n\n      // Compress if requested\n      if (compress) {\n        serializedData = await this.compressionUtils.compress(serializedData);\n        storageObject.metadata.compressedSize = serializedData.length;\n      }\n\n      // Encrypt if requested\n      if (encrypt) {\n        serializedData = await this.cryptoUtils.encrypt(serializedData);\n      }\n\n      // Check size limits\n      if (serializedData.length > this.maxSize) {\n        throw new Error(`Data too large: ${serializedData.length} bytes exceeds ${this.maxSize} bytes`);\n      }\n\n      // Store in localStorage\n      const storageKey = this.prefix + key;\n      localStorage.setItem(storageKey, serializedData);\n\n      return {\n        success: true,\n        key: storageKey,\n        size: serializedData.length,\n        metadata: storageObject.metadata\n      };\n\n    } catch (error) {\n      console.error(`Failed to store data in localStorage for key \"${key}\":`, error);\n      throw error;\n    }\n  }\n\n  /**\n   * Retrieve data from localStorage\n   */\n  async retrieve(key, options = {}) {\n    if (!this.isAvailable) {\n      return null;\n    }\n\n    const { decrypt = false, validateTTL = true } = options;\n\n    try {\n      const storageKey = this.prefix + key;\n      let serializedData = localStorage.getItem(storageKey);\n\n      if (!serializedData) {\n        return null;\n      }\n\n      // Decrypt if needed\n      if (decrypt) {\n        serializedData = await this.cryptoUtils.decrypt(serializedData);\n      }\n\n      // Decompress if needed\n      let storageObject;\n      try {\n        storageObject = JSON.parse(serializedData);\n      } catch (parseError) {\n        // Try decompression first\n        try {\n          const decompressed = await this.compressionUtils.decompress(serializedData);\n          storageObject = JSON.parse(decompressed);\n        } catch (decompressError) {\n          throw new Error('Failed to parse stored data');\n        }\n      }\n\n      // Validate TTL\n      if (validateTTL && storageObject.metadata && storageObject.metadata.ttl) {\n        const now = Date.now();\n        const expiry = storageObject.metadata.timestamp + storageObject.metadata.ttl;\n        \n        if (now > expiry) {\n          await this.remove(key);\n          return null;\n        }\n      }\n\n      return {\n        data: storageObject.data,\n        metadata: storageObject.metadata\n      };\n\n    } catch (error) {\n      console.error(`Failed to retrieve data from localStorage for key \"${key}\":`, error);\n      return null;\n    }\n  }\n\n  /**\n   * Remove data from localStorage\n   */\n  async remove(key) {\n    if (!this.isAvailable) {\n      return false;\n    }\n\n    try {\n      const storageKey = this.prefix + key;\n      localStorage.removeItem(storageKey);\n      return true;\n    } catch (error) {\n      console.error(`Failed to remove data from localStorage for key \"${key}\":`, error);\n      return false;\n    }\n  }\n\n  /**\n   * Clear all application data from localStorage\n   */\n  async clear() {\n    if (!this.isAvailable) {\n      return false;\n    }\n\n    try {\n      const keys = Object.keys(localStorage);\n      const appKeys = keys.filter(key => key.startsWith(this.prefix));\n      \n      appKeys.forEach(key => {\n        localStorage.removeItem(key);\n      });\n\n      return true;\n    } catch (error) {\n      console.error('Failed to clear localStorage:', error);\n      return false;\n    }\n  }\n\n  /**\n   * Get all keys for this application\n   */\n  async getKeys() {\n    if (!this.isAvailable) {\n      return [];\n    }\n\n    try {\n      const keys = Object.keys(localStorage);\n      return keys\n        .filter(key => key.startsWith(this.prefix))\n        .map(key => key.substring(this.prefix.length));\n    } catch (error) {\n      console.error('Failed to get localStorage keys:', error);\n      return [];\n    }\n  }\n\n  /**\n   * Get storage statistics\n   */\n  async getStats() {\n    if (!this.isAvailable) {\n      return { available: false, used: 0, keys: 0 };\n    }\n\n    try {\n      const keys = await this.getKeys();\n      let totalSize = 0;\n      let itemCount = 0;\n      const itemSizes = {};\n\n      for (const key of keys) {\n        const storageKey = this.prefix + key;\n        const data = localStorage.getItem(storageKey);\n        if (data) {\n          const size = data.length;\n          totalSize += size;\n          itemCount++;\n          itemSizes[key] = size;\n        }\n      }\n\n      return {\n        available: true,\n        used: totalSize,\n        keys: itemCount,\n        maxSize: this.maxSize,\n        usagePercentage: (totalSize / this.maxSize) * 100,\n        itemSizes,\n        largestItem: Object.entries(itemSizes).reduce((max, [key, size]) => \n          size > max.size ? { key, size } : max, { key: null, size: 0 })\n      };\n\n    } catch (error) {\n      console.error('Failed to get localStorage stats:', error);\n      return { available: false, used: 0, keys: 0, error: error.message };\n    }\n  }\n\n  /**\n   * Export all application data\n   */\n  async exportAll() {\n    if (!this.isAvailable) {\n      return {};\n    }\n\n    try {\n      const keys = await this.getKeys();\n      const exportData = {};\n\n      for (const key of keys) {\n        const data = await this.retrieve(key, { validateTTL: false });\n        if (data) {\n          exportData[key] = data;\n        }\n      }\n\n      return exportData;\n    } catch (error) {\n      console.error('Failed to export localStorage data:', error);\n      return {};\n    }\n  }\n\n  /**\n   * Import data into localStorage\n   */\n  async importData(importData, options = {}) {\n    if (!this.isAvailable) {\n      throw new Error('localStorage is not available');\n    }\n\n    const { overwrite = false } = options;\n\n    try {\n      const results = {\n        imported: 0,\n        skipped: 0,\n        errors: 0\n      };\n\n      for (const [key, data] of Object.entries(importData)) {\n        try {\n          // Check if key exists and overwrite setting\n          const existing = await this.retrieve(key, { validateTTL: false });\n          if (existing && !overwrite) {\n            results.skipped++;\n            continue;\n          }\n\n          // Import the data\n          await this.store(key, data.data, {\n            encrypt: data.metadata?.encrypted || false,\n            compress: data.metadata?.compressed || false,\n            ttl: data.metadata?.ttl || null\n          });\n\n          results.imported++;\n        } catch (error) {\n          console.error(`Failed to import key \"${key}\":`, error);\n          results.errors++;\n        }\n      }\n\n      return results;\n    } catch (error) {\n      console.error('Failed to import localStorage data:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Check if localStorage has enough space for data\n   */\n  async hasSpace(dataSize) {\n    if (!this.isAvailable) {\n      return false;\n    }\n\n    try {\n      const stats = await this.getStats();\n      return (stats.used + dataSize) <= this.maxSize;\n    } catch (error) {\n      return false;\n    }\n  }\n\n  /**\n   * Cleanup expired items\n   */\n  async cleanup() {\n    if (!this.isAvailable) {\n      return { cleaned: 0 };\n    }\n\n    try {\n      const keys = await this.getKeys();\n      let cleaned = 0;\n\n      for (const key of keys) {\n        const data = await this.retrieve(key, { validateTTL: true });\n        if (!data) {\n          cleaned++; // Item was expired and removed\n        }\n      }\n\n      return { cleaned };\n    } catch (error) {\n      console.error('Failed to cleanup localStorage:', error);\n      return { cleaned: 0, error: error.message };\n    }\n  }\n\n  /**\n   * Validate data before storage\n   */\n  validateData(data) {\n    try {\n      // Check if data is serializable\n      JSON.stringify(data);\n      \n      // Check for circular references\n      const seen = new WeakSet();\n      const checkCircular = (obj) => {\n        if (obj !== null && typeof obj === 'object') {\n          if (seen.has(obj)) {\n            return false;\n          }\n          seen.add(obj);\n          for (const key in obj) {\n            if (!checkCircular(obj[key])) {\n              return false;\n            }\n          }\n        }\n        return true;\n      };\n\n      return checkCircular(data);\n    } catch (error) {\n      return false;\n    }\n  }\n\n  /**\n   * Get localStorage availability status\n   */\n  isStorageAvailable() {\n    return this.isAvailable;\n  }\n\n  /**\n   * Test localStorage performance\n   */\n  async performanceTest() {\n    if (!this.isAvailable) {\n      return null;\n    }\n\n    const testData = { test: 'performance', data: new Array(1000).fill('test') };\n    const iterations = 100;\n    \n    try {\n      // Test write performance\n      const writeStart = performance.now();\n      for (let i = 0; i < iterations; i++) {\n        await this.store(`perf_test_${i}`, testData);\n      }\n      const writeTime = performance.now() - writeStart;\n\n      // Test read performance\n      const readStart = performance.now();\n      for (let i = 0; i < iterations; i++) {\n        await this.retrieve(`perf_test_${i}`);\n      }\n      const readTime = performance.now() - readStart;\n\n      // Cleanup test data\n      for (let i = 0; i < iterations; i++) {\n        await this.remove(`perf_test_${i}`);\n      }\n\n      return {\n        writeTime: writeTime / iterations,\n        readTime: readTime / iterations,\n        totalTime: writeTime + readTime,\n        iterations\n      };\n\n    } catch (error) {\n      console.error('Performance test failed:', error);\n      return null;\n    }\n  }\n}\n","/**\n * IndexedDB Service\n * Manages IndexedDB operations for complex data storage with versioning and transactions\n */\n\nimport { CompressionUtils } from '../utils/CompressionUtils';\n\nexport class IndexedDBService {\n  constructor() {\n    this.dbName = 'FinanceAnalystPro';\n    this.dbVersion = 1;\n    this.db = null;\n    this.isAvailable = false;\n    this.compressionUtils = new CompressionUtils();\n    \n    // Define object stores\n    this.stores = {\n      watchlists: {\n        keyPath: 'id',\n        autoIncrement: true,\n        indexes: [\n          { name: 'name', keyPath: 'name', unique: true },\n          { name: 'created', keyPath: 'created' },\n          { name: 'lastUpdated', keyPath: 'lastUpdated' }\n        ]\n      },\n      analysis_history: {\n        keyPath: 'id',\n        autoIncrement: true,\n        indexes: [\n          { name: 'ticker', keyPath: 'ticker' },\n          { name: 'analysisType', keyPath: 'analysisType' },\n          { name: 'timestamp', keyPath: 'timestamp' }\n        ]\n      },\n      command_history: {\n        keyPath: 'id',\n        autoIncrement: true,\n        indexes: [\n          { name: 'command', keyPath: 'command' },\n          { name: 'timestamp', keyPath: 'timestamp' },\n          { name: 'success', keyPath: 'success' }\n        ]\n      },\n      alerts: {\n        keyPath: 'id',\n        autoIncrement: true,\n        indexes: [\n          { name: 'ticker', keyPath: 'ticker' },\n          { name: 'condition', keyPath: 'condition' },\n          { name: 'created', keyPath: 'created' },\n          { name: 'triggered', keyPath: 'triggered' }\n        ]\n      },\n      cached_data: {\n        keyPath: 'key',\n        indexes: [\n          { name: 'timestamp', keyPath: 'timestamp' },\n          { name: 'expiry', keyPath: 'expiry' },\n          { name: 'dataType', keyPath: 'dataType' }\n        ]\n      },\n      user_models: {\n        keyPath: 'id',\n        autoIncrement: true,\n        indexes: [\n          { name: 'name', keyPath: 'name' },\n          { name: 'type', keyPath: 'type' },\n          { name: 'created', keyPath: 'created' }\n        ]\n      },\n      export_data: {\n        keyPath: 'id',\n        autoIncrement: true,\n        indexes: [\n          { name: 'timestamp', keyPath: 'timestamp' },\n          { name: 'type', keyPath: 'type' }\n        ]\n      }\n    };\n  }\n\n  /**\n   * Initialize IndexedDB service\n   */\n  async initialize() {\n    if (!window.indexedDB) {\n      console.warn('⚠️ IndexedDB not available');\n      this.isAvailable = false;\n      return { success: false, available: false };\n    }\n\n    try {\n      this.db = await this.openDatabase();\n      this.isAvailable = true;\n      console.log('✅ IndexedDB service initialized');\n      \n      // Cleanup expired data\n      await this.cleanupExpiredData();\n      \n      return { success: true, available: true, version: this.dbVersion };\n    } catch (error) {\n      console.error('❌ Failed to initialize IndexedDB:', error);\n      this.isAvailable = false;\n      return { success: false, available: false, error: error.message };\n    }\n  }\n\n  /**\n   * Open IndexedDB database\n   */\n  async openDatabase() {\n    return new Promise((resolve, reject) => {\n      const request = indexedDB.open(this.dbName, this.dbVersion);\n\n      request.onerror = () => {\n        reject(new Error(`Failed to open database: ${request.error}`));\n      };\n\n      request.onsuccess = () => {\n        resolve(request.result);\n      };\n\n      request.onupgradeneeded = (event) => {\n        const db = event.target.result;\n        this.createObjectStores(db);\n      };\n    });\n  }\n\n  /**\n   * Create object stores during database upgrade\n   */\n  createObjectStores(db) {\n    // Remove existing stores if they exist\n    for (const storeName of Object.keys(this.stores)) {\n      if (db.objectStoreNames.contains(storeName)) {\n        db.deleteObjectStore(storeName);\n      }\n    }\n\n    // Create new stores\n    for (const [storeName, config] of Object.entries(this.stores)) {\n      const store = db.createObjectStore(storeName, {\n        keyPath: config.keyPath,\n        autoIncrement: config.autoIncrement\n      });\n\n      // Create indexes\n      if (config.indexes) {\n        config.indexes.forEach(index => {\n          store.createIndex(index.name, index.keyPath, { unique: index.unique || false });\n        });\n      }\n    }\n\n    console.log('✅ IndexedDB object stores created');\n  }\n\n  /**\n   * Store data in IndexedDB\n   */\n  async store(key, data, options = {}) {\n    if (!this.isAvailable) {\n      throw new Error('IndexedDB is not available');\n    }\n\n    const {\n      storeName = 'cached_data',\n      metadata = {},\n      compress = false\n    } = options;\n\n    try {\n      // Prepare data object\n      const dataObject = {\n        key,\n        data,\n        timestamp: Date.now(),\n        metadata: {\n          ...metadata,\n          compressed: compress,\n          originalSize: JSON.stringify(data).length\n        }\n      };\n\n      // Compress if requested\n      if (compress) {\n        const compressed = await this.compressionUtils.compress(JSON.stringify(data));\n        dataObject.data = compressed;\n        dataObject.metadata.compressedSize = compressed.length;\n      }\n\n      // Store in IndexedDB\n      const result = await this.performTransaction(storeName, 'readwrite', (store) => {\n        return store.put(dataObject);\n      });\n\n      return {\n        success: true,\n        key: result,\n        storeName,\n        size: JSON.stringify(dataObject).length,\n        metadata: dataObject.metadata\n      };\n\n    } catch (error) {\n      console.error(`Failed to store data in IndexedDB for key \"${key}\":`, error);\n      throw error;\n    }\n  }\n\n  /**\n   * Retrieve data from IndexedDB\n   */\n  async retrieve(key, options = {}) {\n    if (!this.isAvailable) {\n      return null;\n    }\n\n    const { storeName = 'cached_data' } = options;\n\n    try {\n      const result = await this.performTransaction(storeName, 'readonly', (store) => {\n        return store.get(key);\n      });\n\n      if (!result) {\n        return null;\n      }\n\n      // Check expiry if applicable\n      if (result.metadata && result.metadata.expiry && Date.now() > result.metadata.expiry) {\n        await this.remove(key, { storeName });\n        return null;\n      }\n\n      // Decompress if needed\n      let data = result.data;\n      if (result.metadata && result.metadata.compressed) {\n        data = JSON.parse(await this.compressionUtils.decompress(data));\n      }\n\n      return {\n        data,\n        metadata: result.metadata,\n        timestamp: result.timestamp\n      };\n\n    } catch (error) {\n      console.error(`Failed to retrieve data from IndexedDB for key \"${key}\":`, error);\n      return null;\n    }\n  }\n\n  /**\n   * Remove data from IndexedDB\n   */\n  async remove(key, options = {}) {\n    if (!this.isAvailable) {\n      return false;\n    }\n\n    const { storeName = 'cached_data' } = options;\n\n    try {\n      await this.performTransaction(storeName, 'readwrite', (store) => {\n        return store.delete(key);\n      });\n\n      return true;\n    } catch (error) {\n      console.error(`Failed to remove data from IndexedDB for key \"${key}\":`, error);\n      return false;\n    }\n  }\n\n  /**\n   * Clear all data from a store\n   */\n  async clear(storeName = null) {\n    if (!this.isAvailable) {\n      return false;\n    }\n\n    try {\n      if (storeName) {\n        // Clear specific store\n        await this.performTransaction(storeName, 'readwrite', (store) => {\n          return store.clear();\n        });\n      } else {\n        // Clear all stores\n        for (const store of Object.keys(this.stores)) {\n          await this.performTransaction(store, 'readwrite', (storeObj) => {\n            return storeObj.clear();\n          });\n        }\n      }\n\n      return true;\n    } catch (error) {\n      console.error('Failed to clear IndexedDB:', error);\n      return false;\n    }\n  }\n\n  /**\n   * Get all keys from a store\n   */\n  async getKeys(storeName = 'cached_data') {\n    if (!this.isAvailable) {\n      return [];\n    }\n\n    try {\n      return await this.performTransaction(storeName, 'readonly', (store) => {\n        return store.getAllKeys();\n      });\n    } catch (error) {\n      console.error(`Failed to get keys from IndexedDB store \"${storeName}\":`, error);\n      return [];\n    }\n  }\n\n  /**\n   * Get all data from a store\n   */\n  async getAll(storeName = 'cached_data', options = {}) {\n    if (!this.isAvailable) {\n      return [];\n    }\n\n    const { limit = null, filter = null } = options;\n\n    try {\n      const results = await this.performTransaction(storeName, 'readonly', (store) => {\n        return store.getAll();\n      });\n\n      let filteredResults = results;\n\n      // Apply filter if provided\n      if (filter) {\n        filteredResults = results.filter(filter);\n      }\n\n      // Apply limit if provided\n      if (limit) {\n        filteredResults = filteredResults.slice(0, limit);\n      }\n\n      return filteredResults;\n    } catch (error) {\n      console.error(`Failed to get all data from IndexedDB store \"${storeName}\":`, error);\n      return [];\n    }\n  }\n\n  /**\n   * Query data using an index\n   */\n  async query(storeName, indexName, value, options = {}) {\n    if (!this.isAvailable) {\n      return [];\n    }\n\n    const { limit = null } = options;\n\n    try {\n      return await this.performTransaction(storeName, 'readonly', (store) => {\n        const index = store.index(indexName);\n        const request = limit ? index.getAll(value, limit) : index.getAll(value);\n        return request;\n      });\n    } catch (error) {\n      console.error(`Failed to query IndexedDB store \"${storeName}\" with index \"${indexName}\":`, error);\n      return [];\n    }\n  }\n\n  /**\n   * Get storage statistics\n   */\n  async getStats() {\n    if (!this.isAvailable) {\n      return { available: false, stores: {}, total: { records: 0, size: 0 } };\n    }\n\n    try {\n      const stats = {\n        available: true,\n        stores: {},\n        total: { records: 0, size: 0 }\n      };\n\n      for (const storeName of Object.keys(this.stores)) {\n        const records = await this.getAll(storeName);\n        const recordCount = records.length;\n        const storeSize = records.reduce((size, record) => {\n          return size + JSON.stringify(record).length;\n        }, 0);\n\n        stats.stores[storeName] = {\n          records: recordCount,\n          size: storeSize\n        };\n\n        stats.total.records += recordCount;\n        stats.total.size += storeSize;\n      }\n\n      return stats;\n    } catch (error) {\n      console.error('Failed to get IndexedDB stats:', error);\n      return { available: false, error: error.message };\n    }\n  }\n\n  /**\n   * Export all data from IndexedDB\n   */\n  async exportAll() {\n    if (!this.isAvailable) {\n      return {};\n    }\n\n    try {\n      const exportData = {};\n\n      for (const storeName of Object.keys(this.stores)) {\n        exportData[storeName] = await this.getAll(storeName);\n      }\n\n      return exportData;\n    } catch (error) {\n      console.error('Failed to export IndexedDB data:', error);\n      return {};\n    }\n  }\n\n  /**\n   * Import data into IndexedDB\n   */\n  async importData(importData, options = {}) {\n    if (!this.isAvailable) {\n      throw new Error('IndexedDB is not available');\n    }\n\n    const { overwrite = false } = options;\n\n    try {\n      const results = {\n        imported: 0,\n        skipped: 0,\n        errors: 0\n      };\n\n      for (const [storeName, records] of Object.entries(importData)) {\n        if (!this.stores[storeName]) {\n          console.warn(`Unknown store: ${storeName}`);\n          continue;\n        }\n\n        for (const record of records) {\n          try {\n            if (!overwrite) {\n              // Check if record exists\n              const existing = await this.retrieve(record.key || record.id, { storeName });\n              if (existing) {\n                results.skipped++;\n                continue;\n              }\n            }\n\n            await this.performTransaction(storeName, 'readwrite', (store) => {\n              return store.put(record);\n            });\n\n            results.imported++;\n          } catch (error) {\n            console.error(`Failed to import record to store \"${storeName}\":`, error);\n            results.errors++;\n          }\n        }\n      }\n\n      return results;\n    } catch (error) {\n      console.error('Failed to import IndexedDB data:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Cleanup expired data\n   */\n  async cleanupExpiredData() {\n    if (!this.isAvailable) {\n      return { cleaned: 0 };\n    }\n\n    try {\n      let cleaned = 0;\n      const now = Date.now();\n\n      // Cleanup cached_data store\n      const cachedData = await this.getAll('cached_data');\n      for (const record of cachedData) {\n        if (record.metadata && record.metadata.expiry && now > record.metadata.expiry) {\n          await this.remove(record.key, { storeName: 'cached_data' });\n          cleaned++;\n        }\n      }\n\n      return { cleaned };\n    } catch (error) {\n      console.error('Failed to cleanup expired data:', error);\n      return { cleaned: 0, error: error.message };\n    }\n  }\n\n  /**\n   * Perform IndexedDB transaction\n   */\n  async performTransaction(storeName, mode, operation) {\n    return new Promise((resolve, reject) => {\n      const transaction = this.db.transaction([storeName], mode);\n      const store = transaction.objectStore(storeName);\n\n      transaction.onerror = () => {\n        reject(new Error(`Transaction failed: ${transaction.error}`));\n      };\n\n      transaction.oncomplete = () => {\n        // Transaction completed successfully\n      };\n\n      const request = operation(store);\n\n      request.onsuccess = () => {\n        resolve(request.result);\n      };\n\n      request.onerror = () => {\n        reject(new Error(`Operation failed: ${request.error}`));\n      };\n    });\n  }\n\n  /**\n   * Check if IndexedDB is available\n   */\n  isStorageAvailable() {\n    return this.isAvailable;\n  }\n\n  /**\n   * Get database info\n   */\n  getInfo() {\n    return {\n      dbName: this.dbName,\n      dbVersion: this.dbVersion,\n      available: this.isAvailable,\n      stores: Object.keys(this.stores),\n      storeCount: Object.keys(this.stores).length\n    };\n  }\n}\n","/**\n * Session Manager\n * Manages user sessions, authentication state, and session persistence\n */\n\nimport { CryptoUtils } from '../utils/CryptoUtils';\n\nexport class SessionManager {\n  constructor() {\n    this.sessionKey = 'financeanalyst_session';\n    this.userKey = 'financeanalyst_user';\n    this.preferencesKey = 'financeanalyst_preferences';\n    this.cryptoUtils = new CryptoUtils();\n    \n    this.currentSession = null;\n    this.currentUser = null;\n    this.sessionTimeout = 24 * 60 * 60 * 1000; // 24 hours\n    this.listeners = new Set();\n    \n    // Default user preferences\n    this.defaultPreferences = {\n      currency: 'USD',\n      precision: 2,\n      dateFormat: 'YYYY-MM-DD',\n      theme: 'dark',\n      notifications: true,\n      autoSave: true,\n      commandHistory: true,\n      dataRetention: 30, // days\n      privacy: {\n        analytics: false,\n        crashReporting: true,\n        dataSharing: false\n      }\n    };\n  }\n\n  /**\n   * Initialize session manager\n   */\n  async initialize() {\n    try {\n      // Load existing session\n      await this.loadSession();\n      \n      // Setup session monitoring\n      this.setupSessionMonitoring();\n      \n      console.log('✅ Session Manager initialized');\n      return { success: true, hasSession: !!this.currentSession };\n    } catch (error) {\n      console.error('❌ Failed to initialize Session Manager:', error);\n      return { success: false, error: error.message };\n    }\n  }\n\n  /**\n   * Create a new session\n   */\n  async createSession(userInfo = {}) {\n    try {\n      const sessionId = this.generateSessionId();\n      const now = Date.now();\n      \n      const session = {\n        id: sessionId,\n        userId: userInfo.id || this.generateUserId(),\n        created: now,\n        lastActivity: now,\n        expires: now + this.sessionTimeout,\n        userAgent: navigator.userAgent,\n        platform: navigator.platform,\n        language: navigator.language,\n        timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,\n        version: '1.0'\n      };\n\n      const user = {\n        id: session.userId,\n        name: userInfo.name || 'Anonymous User',\n        email: userInfo.email || null,\n        created: userInfo.created || now,\n        lastLogin: now,\n        loginCount: (userInfo.loginCount || 0) + 1,\n        preferences: { ...this.defaultPreferences, ...userInfo.preferences }\n      };\n\n      // Store session and user data\n      await this.storeSession(session);\n      await this.storeUser(user);\n      \n      this.currentSession = session;\n      this.currentUser = user;\n      \n      // Notify listeners\n      this.notifyListeners('sessionCreated', { session, user });\n      \n      return {\n        success: true,\n        session,\n        user\n      };\n\n    } catch (error) {\n      console.error('Failed to create session:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Load existing session\n   */\n  async loadSession() {\n    try {\n      const sessionData = localStorage.getItem(this.sessionKey);\n      const userData = localStorage.getItem(this.userKey);\n      \n      if (!sessionData || !userData) {\n        return null;\n      }\n\n      const session = JSON.parse(sessionData);\n      const user = JSON.parse(userData);\n      \n      // Check if session is expired\n      if (Date.now() > session.expires) {\n        await this.destroySession();\n        return null;\n      }\n\n      // Update last activity\n      session.lastActivity = Date.now();\n      await this.storeSession(session);\n      \n      this.currentSession = session;\n      this.currentUser = user;\n      \n      // Notify listeners\n      this.notifyListeners('sessionLoaded', { session, user });\n      \n      return { session, user };\n\n    } catch (error) {\n      console.error('Failed to load session:', error);\n      // Clear corrupted session data\n      await this.destroySession();\n      return null;\n    }\n  }\n\n  /**\n   * Update session activity\n   */\n  async updateActivity() {\n    if (!this.currentSession) {\n      return false;\n    }\n\n    try {\n      this.currentSession.lastActivity = Date.now();\n      \n      // Extend session if needed\n      const timeUntilExpiry = this.currentSession.expires - Date.now();\n      if (timeUntilExpiry < this.sessionTimeout * 0.1) { // Extend if less than 10% time left\n        this.currentSession.expires = Date.now() + this.sessionTimeout;\n      }\n\n      await this.storeSession(this.currentSession);\n      return true;\n\n    } catch (error) {\n      console.error('Failed to update session activity:', error);\n      return false;\n    }\n  }\n\n  /**\n   * Destroy current session\n   */\n  async destroySession() {\n    try {\n      const session = this.currentSession;\n      const user = this.currentUser;\n      \n      // Clear session data\n      localStorage.removeItem(this.sessionKey);\n      \n      this.currentSession = null;\n      this.currentUser = null;\n      \n      // Notify listeners\n      this.notifyListeners('sessionDestroyed', { session, user });\n      \n      return true;\n\n    } catch (error) {\n      console.error('Failed to destroy session:', error);\n      return false;\n    }\n  }\n\n  /**\n   * Get current session\n   */\n  getSession() {\n    return this.currentSession;\n  }\n\n  /**\n   * Get current user\n   */\n  getUser() {\n    return this.currentUser;\n  }\n\n  /**\n   * Check if user is authenticated\n   */\n  isAuthenticated() {\n    return !!(this.currentSession && Date.now() < this.currentSession.expires);\n  }\n\n  /**\n   * Get user preferences\n   */\n  getPreferences() {\n    return this.currentUser ? this.currentUser.preferences : this.defaultPreferences;\n  }\n\n  /**\n   * Update user preferences\n   */\n  async updatePreferences(newPreferences) {\n    if (!this.currentUser) {\n      throw new Error('No active user session');\n    }\n\n    try {\n      this.currentUser.preferences = {\n        ...this.currentUser.preferences,\n        ...newPreferences\n      };\n\n      await this.storeUser(this.currentUser);\n      \n      // Also store preferences separately for quick access\n      localStorage.setItem(this.preferencesKey, JSON.stringify(this.currentUser.preferences));\n      \n      // Notify listeners\n      this.notifyListeners('preferencesUpdated', { preferences: this.currentUser.preferences });\n      \n      return this.currentUser.preferences;\n\n    } catch (error) {\n      console.error('Failed to update preferences:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Get session statistics\n   */\n  getSessionStats() {\n    if (!this.currentSession || !this.currentUser) {\n      return null;\n    }\n\n    const now = Date.now();\n    const sessionDuration = now - this.currentSession.created;\n    const timeUntilExpiry = this.currentSession.expires - now;\n    const lastActivityAge = now - this.currentSession.lastActivity;\n\n    return {\n      sessionId: this.currentSession.id,\n      userId: this.currentUser.id,\n      userName: this.currentUser.name,\n      sessionDuration,\n      timeUntilExpiry,\n      lastActivityAge,\n      loginCount: this.currentUser.loginCount,\n      userCreated: this.currentUser.created,\n      isExpired: timeUntilExpiry <= 0,\n      isActive: lastActivityAge < 5 * 60 * 1000 // Active if activity within 5 minutes\n    };\n  }\n\n  /**\n   * Export session data\n   */\n  async exportSessionData() {\n    if (!this.currentSession || !this.currentUser) {\n      return null;\n    }\n\n    return {\n      session: { ...this.currentSession },\n      user: { ...this.currentUser },\n      preferences: { ...this.currentUser.preferences },\n      exportTimestamp: Date.now()\n    };\n  }\n\n  /**\n   * Import session data\n   */\n  async importSessionData(sessionData) {\n    try {\n      if (!sessionData || !sessionData.session || !sessionData.user) {\n        throw new Error('Invalid session data format');\n      }\n\n      // Validate session data\n      const session = sessionData.session;\n      const user = sessionData.user;\n\n      // Update timestamps\n      session.lastActivity = Date.now();\n      session.expires = Date.now() + this.sessionTimeout;\n      user.lastLogin = Date.now();\n\n      // Store imported data\n      await this.storeSession(session);\n      await this.storeUser(user);\n\n      this.currentSession = session;\n      this.currentUser = user;\n\n      // Notify listeners\n      this.notifyListeners('sessionImported', { session, user });\n\n      return { success: true, session, user };\n\n    } catch (error) {\n      console.error('Failed to import session data:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Add session event listener\n   */\n  addEventListener(callback) {\n    this.listeners.add(callback);\n  }\n\n  /**\n   * Remove session event listener\n   */\n  removeEventListener(callback) {\n    this.listeners.delete(callback);\n  }\n\n  // Private methods\n\n  /**\n   * Store session data\n   */\n  async storeSession(session) {\n    try {\n      localStorage.setItem(this.sessionKey, JSON.stringify(session));\n    } catch (error) {\n      console.error('Failed to store session:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Store user data\n   */\n  async storeUser(user) {\n    try {\n      localStorage.setItem(this.userKey, JSON.stringify(user));\n    } catch (error) {\n      console.error('Failed to store user:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Generate unique session ID\n   */\n  generateSessionId() {\n    return 'sess_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);\n  }\n\n  /**\n   * Generate unique user ID\n   */\n  generateUserId() {\n    return 'user_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);\n  }\n\n  /**\n   * Setup session monitoring\n   */\n  setupSessionMonitoring() {\n    // Update activity on user interaction\n    const events = ['click', 'keypress', 'scroll', 'mousemove'];\n    let lastActivity = Date.now();\n\n    const throttledUpdate = this.throttle(() => {\n      const now = Date.now();\n      if (now - lastActivity > 60000) { // Update every minute\n        this.updateActivity();\n        lastActivity = now;\n      }\n    }, 1000);\n\n    events.forEach(event => {\n      document.addEventListener(event, throttledUpdate, { passive: true });\n    });\n\n    // Check session expiry periodically\n    setInterval(() => {\n      if (this.currentSession && Date.now() > this.currentSession.expires) {\n        this.destroySession();\n      }\n    }, 60000); // Check every minute\n\n    // Handle page visibility changes\n    document.addEventListener('visibilitychange', () => {\n      if (!document.hidden) {\n        this.updateActivity();\n      }\n    });\n\n    // Handle page unload\n    window.addEventListener('beforeunload', () => {\n      this.updateActivity();\n    });\n  }\n\n  /**\n   * Throttle function calls\n   */\n  throttle(func, limit) {\n    let inThrottle;\n    return function() {\n      const args = arguments;\n      const context = this;\n      if (!inThrottle) {\n        func.apply(context, args);\n        inThrottle = true;\n        setTimeout(() => inThrottle = false, limit);\n      }\n    };\n  }\n\n  /**\n   * Notify event listeners\n   */\n  notifyListeners(event, data) {\n    this.listeners.forEach(callback => {\n      try {\n        callback(event, data);\n      } catch (error) {\n        console.error('Error in session event listener:', error);\n      }\n    });\n  }\n}\n","/**\n * Data Migration Service\n * Handles data migrations between different versions and storage formats\n */\n\nexport class DataMigrationService {\n  constructor() {\n    this.currentVersion = '1.0.0';\n    this.migrationKey = 'financeanalyst_migration_version';\n    this.backupKey = 'financeanalyst_migration_backup';\n    \n    // Define migration paths\n    this.migrations = {\n      '0.0.0': {\n        to: '1.0.0',\n        description: 'Initial migration to structured persistence layer',\n        migrate: this.migrateToV1_0_0.bind(this)\n      }\n      // Future migrations will be added here\n    };\n  }\n\n  /**\n   * Check if migration is needed and perform it\n   */\n  async checkAndMigrate() {\n    try {\n      const currentStoredVersion = localStorage.getItem(this.migrationKey);\n      \n      if (!currentStoredVersion) {\n        // First time setup - check for legacy data\n        await this.performInitialMigration();\n      } else if (currentStoredVersion !== this.currentVersion) {\n        // Version mismatch - perform migration\n        await this.performVersionMigration(currentStoredVersion, this.currentVersion);\n      }\n\n      // Update stored version\n      localStorage.setItem(this.migrationKey, this.currentVersion);\n      \n      console.log(`✅ Data migration complete - version ${this.currentVersion}`);\n      return { success: true, version: this.currentVersion };\n\n    } catch (error) {\n      console.error('❌ Data migration failed:', error);\n      return { success: false, error: error.message };\n    }\n  }\n\n  /**\n   * Perform initial migration from legacy data\n   */\n  async performInitialMigration() {\n    console.log('🔄 Performing initial data migration...');\n    \n    try {\n      // Check for legacy data patterns\n      const legacyData = await this.detectLegacyData();\n      \n      if (Object.keys(legacyData).length > 0) {\n        // Create backup before migration\n        await this.createMigrationBackup(legacyData);\n        \n        // Migrate legacy data to new format\n        await this.migrateToV1_0_0(legacyData);\n        \n        console.log('✅ Legacy data migrated successfully');\n      } else {\n        console.log('ℹ️ No legacy data found - clean installation');\n      }\n\n    } catch (error) {\n      console.error('Failed to perform initial migration:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Perform version-to-version migration\n   */\n  async performVersionMigration(fromVersion, toVersion) {\n    console.log(`🔄 Migrating data from ${fromVersion} to ${toVersion}...`);\n    \n    try {\n      // Find migration path\n      const migrationPath = this.findMigrationPath(fromVersion, toVersion);\n      \n      if (!migrationPath.length) {\n        throw new Error(`No migration path found from ${fromVersion} to ${toVersion}`);\n      }\n\n      // Create backup before migration\n      const currentData = await this.exportCurrentData();\n      await this.createMigrationBackup(currentData, fromVersion);\n\n      // Execute migrations in sequence\n      for (const migration of migrationPath) {\n        console.log(`🔄 Applying migration: ${migration.description}`);\n        await migration.migrate();\n      }\n\n      console.log('✅ Version migration completed successfully');\n\n    } catch (error) {\n      console.error('Failed to perform version migration:', error);\n      \n      // Attempt to restore from backup\n      await this.restoreFromBackup();\n      throw error;\n    }\n  }\n\n  /**\n   * Detect legacy data in localStorage\n   */\n  async detectLegacyData() {\n    const legacyData = {};\n    \n    try {\n      // Check for old command processor data\n      const oldVariables = localStorage.getItem('commandProcessor_variables');\n      if (oldVariables) {\n        legacyData.variables = JSON.parse(oldVariables);\n      }\n\n      // Check for old settings\n      const oldSettings = localStorage.getItem('commandProcessor_settings');\n      if (oldSettings) {\n        legacyData.settings = JSON.parse(oldSettings);\n      }\n\n      // Check for old watchlists (if stored differently)\n      const oldWatchlists = localStorage.getItem('watchlists');\n      if (oldWatchlists) {\n        legacyData.watchlists = JSON.parse(oldWatchlists);\n      }\n\n      // Check for old alerts\n      const oldAlerts = localStorage.getItem('alerts');\n      if (oldAlerts) {\n        legacyData.alerts = JSON.parse(oldAlerts);\n      }\n\n      // Check for any other financeanalyst_ prefixed items\n      Object.keys(localStorage).forEach(key => {\n        if (key.startsWith('financeanalyst_') && \n            !key.includes('migration') && \n            !key.includes('session') && \n            !key.includes('user') &&\n            !key.includes('crypto_key')) {\n          try {\n            legacyData[key] = JSON.parse(localStorage.getItem(key));\n          } catch (e) {\n            legacyData[key] = localStorage.getItem(key);\n          }\n        }\n      });\n\n      return legacyData;\n\n    } catch (error) {\n      console.error('Failed to detect legacy data:', error);\n      return {};\n    }\n  }\n\n  /**\n   * Migration to version 1.0.0\n   */\n  async migrateToV1_0_0(legacyData = null) {\n    try {\n      const dataToMigrate = legacyData || await this.detectLegacyData();\n      \n      // Migrate watchlists to new format\n      if (dataToMigrate.watchlists) {\n        const migratedWatchlists = this.migrateWatchlistsFormat(dataToMigrate.watchlists);\n        localStorage.setItem('financeanalyst_watchlists', JSON.stringify(migratedWatchlists));\n      }\n\n      // Migrate alerts to new format\n      if (dataToMigrate.alerts) {\n        const migratedAlerts = this.migrateAlertsFormat(dataToMigrate.alerts);\n        localStorage.setItem('financeanalyst_alerts', JSON.stringify(migratedAlerts));\n      }\n\n      // Migrate user preferences\n      if (dataToMigrate.settings) {\n        const migratedPreferences = this.migratePreferencesFormat(dataToMigrate.settings);\n        localStorage.setItem('financeanalyst_preferences', JSON.stringify(migratedPreferences));\n      }\n\n      // Migrate variables to new storage\n      if (dataToMigrate.variables) {\n        const migratedVariables = this.migrateVariablesFormat(dataToMigrate.variables);\n        localStorage.setItem('financeanalyst_user_variables', JSON.stringify(migratedVariables));\n      }\n\n      // Clean up old data\n      await this.cleanupLegacyData(dataToMigrate);\n\n      console.log('✅ Migration to v1.0.0 completed');\n\n    } catch (error) {\n      console.error('Failed to migrate to v1.0.0:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Migrate watchlists to new format\n   */\n  migrateWatchlistsFormat(oldWatchlists) {\n    const migrated = {};\n    \n    if (Array.isArray(oldWatchlists)) {\n      // Old format was array, convert to object\n      oldWatchlists.forEach((watchlist, index) => {\n        const name = watchlist.name || `Watchlist ${index + 1}`;\n        migrated[name] = {\n          tickers: watchlist.tickers || watchlist.stocks || [],\n          created: watchlist.created || new Date().toISOString().split('T')[0],\n          lastUpdated: watchlist.lastUpdated || null\n        };\n      });\n    } else if (typeof oldWatchlists === 'object') {\n      // Already in object format, just ensure structure\n      Object.entries(oldWatchlists).forEach(([name, data]) => {\n        migrated[name] = {\n          tickers: data.tickers || data.stocks || [],\n          created: data.created || new Date().toISOString().split('T')[0],\n          lastUpdated: data.lastUpdated || null\n        };\n      });\n    }\n\n    return migrated;\n  }\n\n  /**\n   * Migrate alerts to new format\n   */\n  migrateAlertsFormat(oldAlerts) {\n    if (!Array.isArray(oldAlerts)) {\n      return [];\n    }\n\n    return oldAlerts.map(alert => ({\n      id: alert.id || Date.now() + Math.random(),\n      ticker: alert.ticker,\n      condition: alert.condition,\n      value: alert.value,\n      created: alert.created || new Date().toISOString().split('T')[0],\n      triggered: alert.triggered || false\n    }));\n  }\n\n  /**\n   * Migrate preferences to new format\n   */\n  migratePreferencesFormat(oldSettings) {\n    return {\n      currency: oldSettings.currency || 'USD',\n      precision: oldSettings.precision || 2,\n      dateFormat: oldSettings.dateFormat || 'YYYY-MM-DD',\n      theme: oldSettings.theme || 'dark',\n      notifications: oldSettings.notifications !== false,\n      autoSave: oldSettings.autoSave !== false,\n      commandHistory: oldSettings.commandHistory !== false,\n      dataRetention: oldSettings.dataRetention || 30,\n      privacy: {\n        analytics: oldSettings.analytics || false,\n        crashReporting: oldSettings.crashReporting !== false,\n        dataSharing: oldSettings.dataSharing || false\n      }\n    };\n  }\n\n  /**\n   * Migrate variables to new format\n   */\n  migrateVariablesFormat(oldVariables) {\n    // Variables format should remain mostly the same\n    return { ...oldVariables };\n  }\n\n  /**\n   * Clean up legacy data after migration\n   */\n  async cleanupLegacyData(legacyData) {\n    try {\n      // Remove old localStorage keys\n      const keysToRemove = [\n        'commandProcessor_variables',\n        'commandProcessor_settings',\n        'watchlists',\n        'alerts'\n      ];\n\n      keysToRemove.forEach(key => {\n        if (localStorage.getItem(key)) {\n          localStorage.removeItem(key);\n        }\n      });\n\n      // Remove other legacy keys found in detection\n      Object.keys(legacyData).forEach(key => {\n        if (key.startsWith('financeanalyst_') && \n            !key.includes('migration') && \n            !key.includes('session') && \n            !key.includes('user') &&\n            !key.includes('crypto_key')) {\n          localStorage.removeItem(key);\n        }\n      });\n\n      console.log('✅ Legacy data cleanup completed');\n\n    } catch (error) {\n      console.error('Failed to cleanup legacy data:', error);\n      // Don't throw - cleanup failure shouldn't break migration\n    }\n  }\n\n  /**\n   * Create backup before migration\n   */\n  async createMigrationBackup(data, version = 'legacy') {\n    try {\n      const backup = {\n        version,\n        timestamp: new Date().toISOString(),\n        data\n      };\n\n      localStorage.setItem(this.backupKey, JSON.stringify(backup));\n      console.log(`✅ Migration backup created for version ${version}`);\n\n    } catch (error) {\n      console.error('Failed to create migration backup:', error);\n      // Don't throw - backup failure shouldn't prevent migration\n    }\n  }\n\n  /**\n   * Restore from migration backup\n   */\n  async restoreFromBackup() {\n    try {\n      const backupData = localStorage.getItem(this.backupKey);\n      if (!backupData) {\n        throw new Error('No migration backup found');\n      }\n\n      const backup = JSON.parse(backupData);\n      \n      // Restore data based on backup version\n      if (backup.version === 'legacy') {\n        // Restore legacy format\n        Object.entries(backup.data).forEach(([key, value]) => {\n          localStorage.setItem(key, typeof value === 'string' ? value : JSON.stringify(value));\n        });\n      }\n\n      console.log('✅ Data restored from migration backup');\n      return true;\n\n    } catch (error) {\n      console.error('Failed to restore from backup:', error);\n      return false;\n    }\n  }\n\n  /**\n   * Export current data for backup\n   */\n  async exportCurrentData() {\n    const data = {};\n    \n    Object.keys(localStorage).forEach(key => {\n      if (key.startsWith('financeanalyst_')) {\n        try {\n          data[key] = JSON.parse(localStorage.getItem(key));\n        } catch (e) {\n          data[key] = localStorage.getItem(key);\n        }\n      }\n    });\n\n    return data;\n  }\n\n  /**\n   * Find migration path between versions\n   */\n  findMigrationPath(fromVersion, toVersion) {\n    // For now, simple direct migration\n    // In the future, this could handle complex migration chains\n    const migration = this.migrations[fromVersion];\n    \n    if (migration && migration.to === toVersion) {\n      return [migration];\n    }\n\n    return [];\n  }\n\n  /**\n   * Get migration status\n   */\n  getMigrationStatus() {\n    const storedVersion = localStorage.getItem(this.migrationKey);\n    const hasBackup = !!localStorage.getItem(this.backupKey);\n    \n    return {\n      currentVersion: this.currentVersion,\n      storedVersion,\n      needsMigration: storedVersion !== this.currentVersion,\n      hasBackup,\n      availableMigrations: Object.keys(this.migrations)\n    };\n  }\n\n  /**\n   * Clear migration backup\n   */\n  clearBackup() {\n    localStorage.removeItem(this.backupKey);\n    console.log('✅ Migration backup cleared');\n  }\n}\n","/**\n * Persistence Manager - Central data persistence orchestrator\n * Manages multiple storage layers and provides unified API for data persistence\n */\n\nimport { LocalStorageService } from './LocalStorageService';\nimport { IndexedDBService } from './IndexedDBService';\nimport { SessionManager } from './SessionManager';\nimport { DataMigrationService } from './DataMigrationService';\n\nexport class PersistenceManager {\n  constructor() {\n    this.localStorage = new LocalStorageService();\n    this.indexedDB = new IndexedDBService();\n    this.sessionManager = new SessionManager();\n    this.migrationService = new DataMigrationService();\n    \n    this.isInitialized = false;\n    this.storageQuota = null;\n    this.listeners = new Map();\n    \n    // Storage strategy configuration\n    this.storageStrategy = {\n      // Small, frequently accessed data -> localStorage\n      localStorage: [\n        'user_preferences',\n        'session_data',\n        'ui_state',\n        'recent_commands',\n        'quick_settings'\n      ],\n      // Large, complex data -> IndexedDB\n      indexedDB: [\n        'watchlists',\n        'analysis_history',\n        'command_history',\n        'alerts',\n        'cached_data',\n        'user_models',\n        'export_data'\n      ]\n    };\n  }\n\n  /**\n   * Initialize the persistence manager\n   */\n  async initialize() {\n    if (this.isInitialized) return;\n\n    try {\n      // Check storage availability\n      await this.checkStorageAvailability();\n      \n      // Initialize storage services\n      await Promise.all([\n        this.localStorage.initialize(),\n        this.indexedDB.initialize(),\n        this.sessionManager.initialize()\n      ]);\n\n      // Check for data migrations\n      await this.migrationService.checkAndMigrate();\n\n      // Estimate storage quota\n      await this.estimateStorageQuota();\n\n      this.isInitialized = true;\n      console.log('✅ Persistence Manager initialized successfully');\n      \n      return {\n        success: true,\n        storageQuota: this.storageQuota,\n        availableStorage: await this.getAvailableStorage()\n      };\n\n    } catch (error) {\n      console.error('❌ Failed to initialize Persistence Manager:', error);\n      throw new Error(`Persistence initialization failed: ${error.message}`);\n    }\n  }\n\n  /**\n   * Store data using appropriate storage layer\n   */\n  async store(key, data, options = {}) {\n    await this.ensureInitialized();\n\n    const {\n      storage = this.determineStorageLayer(key),\n      encrypt = false,\n      compress = false,\n      ttl = null\n    } = options;\n\n    try {\n      const metadata = {\n        timestamp: Date.now(),\n        version: '1.0',\n        encrypted: encrypt,\n        compressed: compress,\n        ttl,\n        size: JSON.stringify(data).length\n      };\n\n      let result;\n      \n      if (storage === 'localStorage') {\n        result = await this.localStorage.store(key, data, { encrypt, ttl });\n      } else if (storage === 'indexedDB') {\n        result = await this.indexedDB.store(key, data, { metadata, compress });\n      } else {\n        throw new Error(`Unknown storage layer: ${storage}`);\n      }\n\n      // Notify listeners\n      this.notifyListeners('store', { key, storage, metadata });\n\n      return result;\n\n    } catch (error) {\n      console.error(`Failed to store data for key \"${key}\":`, error);\n      throw error;\n    }\n  }\n\n  /**\n   * Retrieve data from appropriate storage layer\n   */\n  async retrieve(key, options = {}) {\n    await this.ensureInitialized();\n\n    const {\n      storage = this.determineStorageLayer(key),\n      decrypt = false\n    } = options;\n\n    try {\n      let result;\n\n      if (storage === 'localStorage') {\n        result = await this.localStorage.retrieve(key, { decrypt });\n      } else if (storage === 'indexedDB') {\n        result = await this.indexedDB.retrieve(key);\n      } else {\n        // Try both storage layers\n        result = await this.localStorage.retrieve(key, { decrypt }) ||\n                 await this.indexedDB.retrieve(key);\n      }\n\n      // Check TTL if applicable\n      if (result && result.metadata && result.metadata.ttl) {\n        const now = Date.now();\n        const expiry = result.metadata.timestamp + result.metadata.ttl;\n        \n        if (now > expiry) {\n          await this.remove(key, { storage });\n          return null;\n        }\n      }\n\n      return result ? result.data || result : null;\n\n    } catch (error) {\n      console.error(`Failed to retrieve data for key \"${key}\":`, error);\n      return null;\n    }\n  }\n\n  /**\n   * Remove data from storage\n   */\n  async remove(key, options = {}) {\n    await this.ensureInitialized();\n\n    const { storage = 'both' } = options;\n\n    try {\n      const promises = [];\n\n      if (storage === 'localStorage' || storage === 'both') {\n        promises.push(this.localStorage.remove(key));\n      }\n\n      if (storage === 'indexedDB' || storage === 'both') {\n        promises.push(this.indexedDB.remove(key));\n      }\n\n      await Promise.all(promises);\n\n      // Notify listeners\n      this.notifyListeners('remove', { key, storage });\n\n      return true;\n\n    } catch (error) {\n      console.error(`Failed to remove data for key \"${key}\":`, error);\n      throw error;\n    }\n  }\n\n  /**\n   * Clear all data from storage\n   */\n  async clear(options = {}) {\n    await this.ensureInitialized();\n\n    const { storage = 'both', confirm = false } = options;\n\n    if (!confirm) {\n      throw new Error('Clear operation requires explicit confirmation');\n    }\n\n    try {\n      const promises = [];\n\n      if (storage === 'localStorage' || storage === 'both') {\n        promises.push(this.localStorage.clear());\n      }\n\n      if (storage === 'indexedDB' || storage === 'both') {\n        promises.push(this.indexedDB.clear());\n      }\n\n      await Promise.all(promises);\n\n      // Notify listeners\n      this.notifyListeners('clear', { storage });\n\n      return true;\n\n    } catch (error) {\n      console.error('Failed to clear storage:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Get storage statistics\n   */\n  async getStorageStats() {\n    await this.ensureInitialized();\n\n    try {\n      const [localStorageStats, indexedDBStats] = await Promise.all([\n        this.localStorage.getStats(),\n        this.indexedDB.getStats()\n      ]);\n\n      const totalUsed = localStorageStats.used + indexedDBStats.used;\n      const totalAvailable = await this.getAvailableStorage();\n\n      return {\n        localStorage: localStorageStats,\n        indexedDB: indexedDBStats,\n        total: {\n          used: totalUsed,\n          available: totalAvailable,\n          quota: this.storageQuota,\n          usagePercentage: this.storageQuota ? (totalUsed / this.storageQuota) * 100 : 0\n        }\n      };\n\n    } catch (error) {\n      console.error('Failed to get storage stats:', error);\n      return null;\n    }\n  }\n\n  /**\n   * Export all user data\n   */\n  async exportData(options = {}) {\n    await this.ensureInitialized();\n\n    const {\n      format = 'json',\n      includeMetadata = true,\n      compress = false\n    } = options;\n\n    try {\n      const [localStorageData, indexedDBData] = await Promise.all([\n        this.localStorage.exportAll(),\n        this.indexedDB.exportAll()\n      ]);\n\n      const exportData = {\n        version: '1.0',\n        timestamp: new Date().toISOString(),\n        localStorage: localStorageData,\n        indexedDB: indexedDBData\n      };\n\n      if (includeMetadata) {\n        exportData.metadata = {\n          userAgent: navigator.userAgent,\n          storageStats: await this.getStorageStats(),\n          exportOptions: options\n        };\n      }\n\n      return {\n        data: exportData,\n        size: JSON.stringify(exportData).length,\n        format\n      };\n\n    } catch (error) {\n      console.error('Failed to export data:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Import user data\n   */\n  async importData(importData, options = {}) {\n    await this.ensureInitialized();\n\n    const {\n      overwrite = false,\n      validate = true,\n      backup = true\n    } = options;\n\n    try {\n      // Validate import data\n      if (validate && !this.validateImportData(importData)) {\n        throw new Error('Invalid import data format');\n      }\n\n      // Create backup if requested\n      if (backup) {\n        const backupData = await this.exportData();\n        await this.store('backup_before_import', backupData, {\n          storage: 'indexedDB',\n          ttl: 7 * 24 * 60 * 60 * 1000 // 7 days\n        });\n      }\n\n      // Import localStorage data\n      if (importData.localStorage) {\n        await this.localStorage.importData(importData.localStorage, { overwrite });\n      }\n\n      // Import IndexedDB data\n      if (importData.indexedDB) {\n        await this.indexedDB.importData(importData.indexedDB, { overwrite });\n      }\n\n      // Notify listeners\n      this.notifyListeners('import', { size: JSON.stringify(importData).length });\n\n      return {\n        success: true,\n        imported: {\n          localStorage: Object.keys(importData.localStorage || {}).length,\n          indexedDB: Object.keys(importData.indexedDB || {}).length\n        }\n      };\n\n    } catch (error) {\n      console.error('Failed to import data:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Add event listener for storage events\n   */\n  addEventListener(event, callback) {\n    if (!this.listeners.has(event)) {\n      this.listeners.set(event, new Set());\n    }\n    this.listeners.get(event).add(callback);\n  }\n\n  /**\n   * Remove event listener\n   */\n  removeEventListener(event, callback) {\n    if (this.listeners.has(event)) {\n      this.listeners.get(event).delete(callback);\n    }\n  }\n\n  // Private methods\n\n  async ensureInitialized() {\n    if (!this.isInitialized) {\n      await this.initialize();\n    }\n  }\n\n  determineStorageLayer(key) {\n    if (this.storageStrategy.localStorage.includes(key)) {\n      return 'localStorage';\n    }\n    if (this.storageStrategy.indexedDB.includes(key)) {\n      return 'indexedDB';\n    }\n    // Default to localStorage for small data\n    return 'localStorage';\n  }\n\n  async checkStorageAvailability() {\n    // Check localStorage\n    if (!window.localStorage) {\n      throw new Error('localStorage is not available');\n    }\n\n    // Check IndexedDB\n    if (!window.indexedDB) {\n      throw new Error('IndexedDB is not available');\n    }\n\n    return true;\n  }\n\n  async estimateStorageQuota() {\n    if ('storage' in navigator && 'estimate' in navigator.storage) {\n      const estimate = await navigator.storage.estimate();\n      this.storageQuota = estimate.quota;\n      return estimate;\n    }\n    return null;\n  }\n\n  async getAvailableStorage() {\n    if ('storage' in navigator && 'estimate' in navigator.storage) {\n      const estimate = await navigator.storage.estimate();\n      return estimate.quota - estimate.usage;\n    }\n    return null;\n  }\n\n  validateImportData(data) {\n    return data && \n           typeof data === 'object' && \n           data.version && \n           (data.localStorage || data.indexedDB);\n  }\n\n  notifyListeners(event, data) {\n    if (this.listeners.has(event)) {\n      this.listeners.get(event).forEach(callback => {\n        try {\n          callback(data);\n        } catch (error) {\n          console.error('Error in storage event listener:', error);\n        }\n      });\n    }\n  }\n}\n\n// Export singleton instance\nexport const persistenceManager = new PersistenceManager();\n","/**\n * Backup Service\n * Handles data backup, restore, and synchronization operations\n */\n\nimport { persistenceManager } from './PersistenceManager';\nimport { CryptoUtils } from '../utils/CryptoUtils';\nimport { CompressionUtils } from '../utils/CompressionUtils';\n\nexport class BackupService {\n  constructor() {\n    this.cryptoUtils = new CryptoUtils();\n    this.compressionUtils = new CompressionUtils();\n    this.backupVersion = '1.0.0';\n    this.maxBackupSize = 50 * 1024 * 1024; // 50MB\n    this.maxBackups = 10; // Keep last 10 backups\n  }\n\n  /**\n   * Create a complete backup of all user data\n   */\n  async createBackup(options = {}) {\n    const {\n      includeSettings = true,\n      includeWatchlists = true,\n      includeAlerts = true,\n      includeHistory = true,\n      includeCachedData = false,\n      encrypt = false,\n      compress = true,\n      description = ''\n    } = options;\n\n    try {\n      await persistenceManager.ensureInitialized();\n\n      // Collect data to backup\n      const backupData = {\n        version: this.backupVersion,\n        timestamp: new Date().toISOString(),\n        description,\n        metadata: {\n          userAgent: navigator.userAgent,\n          platform: navigator.platform,\n          language: navigator.language,\n          timezone: Intl.DateTimeFormat().resolvedOptions().timeZone\n        },\n        data: {}\n      };\n\n      // Include user settings and preferences\n      if (includeSettings) {\n        backupData.data.settings = await persistenceManager.retrieve('user_preferences') || {};\n        backupData.data.session = await persistenceManager.retrieve('session_data') || {};\n      }\n\n      // Include watchlists\n      if (includeWatchlists) {\n        backupData.data.watchlists = await persistenceManager.retrieve('watchlists') || {};\n      }\n\n      // Include alerts\n      if (includeAlerts) {\n        backupData.data.alerts = await persistenceManager.retrieve('alerts') || [];\n      }\n\n      // Include command and analysis history\n      if (includeHistory) {\n        backupData.data.commandHistory = await persistenceManager.retrieve('command_history') || [];\n        backupData.data.analysisHistory = await persistenceManager.retrieve('analysis_history') || [];\n      }\n\n      // Include cached data (optional, can be large)\n      if (includeCachedData) {\n        backupData.data.cachedData = await persistenceManager.retrieve('cached_data') || {};\n      }\n\n      // Calculate backup size\n      let backupString = JSON.stringify(backupData);\n      const originalSize = backupString.length;\n\n      if (originalSize > this.maxBackupSize) {\n        throw new Error(`Backup too large: ${originalSize} bytes exceeds ${this.maxBackupSize} bytes`);\n      }\n\n      // Compress if requested\n      if (compress) {\n        backupString = await this.compressionUtils.compress(backupString);\n        backupData.metadata.compressed = true;\n        backupData.metadata.compressionRatio = backupString.length / originalSize;\n      }\n\n      // Encrypt if requested\n      if (encrypt) {\n        backupString = await this.cryptoUtils.encrypt(backupString);\n        backupData.metadata.encrypted = true;\n      }\n\n      // Generate backup ID\n      const backupId = this.generateBackupId();\n      \n      // Store backup\n      await this.storeBackup(backupId, backupString, backupData.metadata);\n\n      // Cleanup old backups\n      await this.cleanupOldBackups();\n\n      return {\n        success: true,\n        backupId,\n        size: backupString.length,\n        originalSize,\n        metadata: backupData.metadata,\n        timestamp: backupData.timestamp\n      };\n\n    } catch (error) {\n      console.error('Failed to create backup:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Restore data from backup\n   */\n  async restoreBackup(backupId, options = {}) {\n    const {\n      overwrite = false,\n      selectiveRestore = null, // Array of data types to restore\n      createBackupBeforeRestore = true\n    } = options;\n\n    try {\n      await persistenceManager.ensureInitialized();\n\n      // Create backup before restore if requested\n      if (createBackupBeforeRestore) {\n        await this.createBackup({\n          description: `Auto-backup before restore from ${backupId}`,\n          compress: true\n        });\n      }\n\n      // Retrieve backup data\n      const backup = await this.retrieveBackup(backupId);\n      if (!backup) {\n        throw new Error(`Backup ${backupId} not found`);\n      }\n\n      let backupString = backup.data;\n      const metadata = backup.metadata;\n\n      // Decrypt if needed\n      if (metadata.encrypted) {\n        backupString = await this.cryptoUtils.decrypt(backupString);\n      }\n\n      // Decompress if needed\n      if (metadata.compressed) {\n        backupString = await this.compressionUtils.decompress(backupString);\n      }\n\n      // Parse backup data\n      const backupData = JSON.parse(backupString);\n\n      // Validate backup version compatibility\n      if (!this.isVersionCompatible(backupData.version)) {\n        throw new Error(`Backup version ${backupData.version} is not compatible with current version ${this.backupVersion}`);\n      }\n\n      // Restore data selectively or completely\n      const dataToRestore = selectiveRestore ? \n        this.filterBackupData(backupData.data, selectiveRestore) : \n        backupData.data;\n\n      const restoreResults = {\n        restored: 0,\n        skipped: 0,\n        errors: 0,\n        details: {}\n      };\n\n      // Restore each data type\n      for (const [dataType, data] of Object.entries(dataToRestore)) {\n        try {\n          // Check if data exists and overwrite setting\n          const existing = await persistenceManager.retrieve(dataType);\n          if (existing && !overwrite) {\n            restoreResults.skipped++;\n            restoreResults.details[dataType] = 'skipped (exists)';\n            continue;\n          }\n\n          // Restore the data\n          await persistenceManager.store(dataType, data, {\n            storage: this.determineStorageType(dataType)\n          });\n\n          restoreResults.restored++;\n          restoreResults.details[dataType] = 'restored';\n\n        } catch (error) {\n          console.error(`Failed to restore ${dataType}:`, error);\n          restoreResults.errors++;\n          restoreResults.details[dataType] = `error: ${error.message}`;\n        }\n      }\n\n      return {\n        success: true,\n        backupId,\n        backupTimestamp: backupData.timestamp,\n        restoreTimestamp: new Date().toISOString(),\n        results: restoreResults\n      };\n\n    } catch (error) {\n      console.error('Failed to restore backup:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * List available backups\n   */\n  async listBackups() {\n    try {\n      const backupKeys = await persistenceManager.indexedDB.getKeys('export_data');\n      const backups = [];\n\n      for (const key of backupKeys) {\n        if (key.startsWith('backup_')) {\n          const backup = await persistenceManager.indexedDB.retrieve(key, { storeName: 'export_data' });\n          if (backup) {\n            backups.push({\n              id: key,\n              timestamp: backup.metadata.timestamp,\n              description: backup.metadata.description || '',\n              size: backup.metadata.size || 0,\n              compressed: backup.metadata.compressed || false,\n              encrypted: backup.metadata.encrypted || false\n            });\n          }\n        }\n      }\n\n      // Sort by timestamp (newest first)\n      backups.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));\n\n      return backups;\n\n    } catch (error) {\n      console.error('Failed to list backups:', error);\n      return [];\n    }\n  }\n\n  /**\n   * Delete a backup\n   */\n  async deleteBackup(backupId) {\n    try {\n      await persistenceManager.indexedDB.remove(backupId, { storeName: 'export_data' });\n      return true;\n    } catch (error) {\n      console.error(`Failed to delete backup ${backupId}:`, error);\n      return false;\n    }\n  }\n\n  /**\n   * Export backup to file\n   */\n  async exportBackupToFile(backupId, filename = null) {\n    try {\n      const backup = await this.retrieveBackup(backupId);\n      if (!backup) {\n        throw new Error(`Backup ${backupId} not found`);\n      }\n\n      const exportData = {\n        backupId,\n        ...backup\n      };\n\n      const dataString = JSON.stringify(exportData, null, 2);\n      const blob = new Blob([dataString], { type: 'application/json' });\n      \n      const suggestedFilename = filename || \n        `financeanalyst_backup_${backupId}_${new Date().toISOString().split('T')[0]}.json`;\n\n      return {\n        blob,\n        filename: suggestedFilename,\n        size: blob.size,\n        type: 'application/json'\n      };\n\n    } catch (error) {\n      console.error('Failed to export backup to file:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Import backup from file\n   */\n  async importBackupFromFile(fileContent) {\n    try {\n      const backupData = JSON.parse(fileContent);\n      \n      // Validate backup format\n      if (!backupData.backupId || !backupData.data || !backupData.metadata) {\n        throw new Error('Invalid backup file format');\n      }\n\n      // Store imported backup\n      await this.storeBackup(backupData.backupId, backupData.data, backupData.metadata);\n\n      return {\n        success: true,\n        backupId: backupData.backupId,\n        timestamp: backupData.metadata.timestamp\n      };\n\n    } catch (error) {\n      console.error('Failed to import backup from file:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Get backup statistics\n   */\n  async getBackupStats() {\n    try {\n      const backups = await this.listBackups();\n      \n      const stats = {\n        totalBackups: backups.length,\n        totalSize: backups.reduce((sum, backup) => sum + (backup.size || 0), 0),\n        oldestBackup: backups.length > 0 ? backups[backups.length - 1].timestamp : null,\n        newestBackup: backups.length > 0 ? backups[0].timestamp : null,\n        encryptedBackups: backups.filter(b => b.encrypted).length,\n        compressedBackups: backups.filter(b => b.compressed).length\n      };\n\n      return stats;\n\n    } catch (error) {\n      console.error('Failed to get backup stats:', error);\n      return null;\n    }\n  }\n\n  // Private methods\n\n  /**\n   * Store backup in IndexedDB\n   */\n  async storeBackup(backupId, data, metadata) {\n    const backupRecord = {\n      id: backupId,\n      data,\n      metadata: {\n        ...metadata,\n        timestamp: new Date().toISOString(),\n        size: data.length\n      },\n      timestamp: Date.now(),\n      type: 'backup'\n    };\n\n    await persistenceManager.indexedDB.store(backupId, backupRecord, {\n      storeName: 'export_data',\n      metadata: backupRecord.metadata\n    });\n  }\n\n  /**\n   * Retrieve backup from IndexedDB\n   */\n  async retrieveBackup(backupId) {\n    return await persistenceManager.indexedDB.retrieve(backupId, { storeName: 'export_data' });\n  }\n\n  /**\n   * Generate unique backup ID\n   */\n  generateBackupId() {\n    const timestamp = Date.now();\n    const random = Math.random().toString(36).substr(2, 9);\n    return `backup_${timestamp}_${random}`;\n  }\n\n  /**\n   * Cleanup old backups\n   */\n  async cleanupOldBackups() {\n    try {\n      const backups = await this.listBackups();\n      \n      if (backups.length > this.maxBackups) {\n        const backupsToDelete = backups.slice(this.maxBackups);\n        \n        for (const backup of backupsToDelete) {\n          await this.deleteBackup(backup.id);\n        }\n\n        console.log(`✅ Cleaned up ${backupsToDelete.length} old backups`);\n      }\n\n    } catch (error) {\n      console.error('Failed to cleanup old backups:', error);\n    }\n  }\n\n  /**\n   * Check if backup version is compatible\n   */\n  isVersionCompatible(backupVersion) {\n    // For now, only exact version match\n    // In the future, this could handle version compatibility matrix\n    return backupVersion === this.backupVersion;\n  }\n\n  /**\n   * Filter backup data for selective restore\n   */\n  filterBackupData(backupData, dataTypes) {\n    const filtered = {};\n    \n    dataTypes.forEach(dataType => {\n      if (backupData[dataType]) {\n        filtered[dataType] = backupData[dataType];\n      }\n    });\n\n    return filtered;\n  }\n\n  /**\n   * Determine appropriate storage type for data\n   */\n  determineStorageType(dataType) {\n    const localStorageTypes = ['settings', 'session', 'user_preferences'];\n    return localStorageTypes.includes(dataType) ? 'localStorage' : 'indexedDB';\n  }\n}\n\n// Export singleton instance\nexport const backupService = new BackupService();\n","/**\n * Privacy Service\n * Handles data privacy controls, retention policies, and user data rights\n */\n\nimport { persistenceManager } from './PersistenceManager';\nimport { backupService } from './BackupService';\n\nexport class PrivacyService {\n  constructor() {\n    this.retentionPolicies = {\n      command_history: 30, // days\n      analysis_history: 90,\n      cached_data: 7,\n      export_data: 30,\n      session_data: 1\n    };\n    \n    this.privacySettings = {\n      dataRetention: true,\n      analytics: false,\n      crashReporting: true,\n      dataSharing: false,\n      cookieConsent: false,\n      trackingConsent: false\n    };\n\n    this.dataCategories = {\n      essential: ['user_preferences', 'session_data', 'watchlists', 'alerts'],\n      functional: ['command_history', 'user_variables'],\n      analytics: ['usage_stats', 'performance_metrics'],\n      marketing: [], // None currently\n      external: ['cached_data'] // Data from external APIs\n    };\n  }\n\n  /**\n   * Initialize privacy service\n   */\n  async initialize() {\n    try {\n      // Load privacy settings\n      const settings = await persistenceManager.retrieve('privacy_settings');\n      if (settings) {\n        this.privacySettings = { ...this.privacySettings, ...settings };\n      }\n\n      // Load custom retention policies\n      const policies = await persistenceManager.retrieve('retention_policies');\n      if (policies) {\n        this.retentionPolicies = { ...this.retentionPolicies, ...policies };\n      }\n\n      // Schedule cleanup\n      this.scheduleCleanup();\n\n      console.log('✅ Privacy service initialized');\n      return { success: true, settings: this.privacySettings };\n\n    } catch (error) {\n      console.error('❌ Failed to initialize privacy service:', error);\n      return { success: false, error: error.message };\n    }\n  }\n\n  /**\n   * Update privacy settings\n   */\n  async updatePrivacySettings(newSettings) {\n    try {\n      const oldSettings = { ...this.privacySettings };\n      this.privacySettings = { ...this.privacySettings, ...newSettings };\n\n      // Save updated settings\n      await persistenceManager.store('privacy_settings', this.privacySettings, {\n        storage: 'localStorage'\n      });\n\n      // Handle setting changes\n      await this.handlePrivacySettingChanges(oldSettings, this.privacySettings);\n\n      return { success: true, settings: this.privacySettings };\n\n    } catch (error) {\n      console.error('Failed to update privacy settings:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Handle privacy setting changes\n   */\n  async handlePrivacySettingChanges(oldSettings, newSettings) {\n    // If data retention was disabled, clean up non-essential data\n    if (oldSettings.dataRetention && !newSettings.dataRetention) {\n      await this.cleanupNonEssentialData();\n    }\n\n    // If analytics was disabled, clean up analytics data\n    if (oldSettings.analytics && !newSettings.analytics) {\n      await this.cleanupAnalyticsData();\n    }\n\n    // If data sharing was disabled, remove shared data markers\n    if (oldSettings.dataSharing && !newSettings.dataSharing) {\n      await this.removeDataSharingMarkers();\n    }\n  }\n\n  /**\n   * Set data retention policy\n   */\n  async setRetentionPolicy(dataType, days) {\n    try {\n      this.retentionPolicies[dataType] = days;\n\n      // Save updated policies\n      await persistenceManager.store('retention_policies', this.retentionPolicies, {\n        storage: 'localStorage'\n      });\n\n      // Apply new policy immediately\n      await this.cleanupExpiredData(dataType);\n\n      return { success: true, policy: { [dataType]: days } };\n\n    } catch (error) {\n      console.error('Failed to set retention policy:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Clean up expired data based on retention policies\n   */\n  async cleanupExpiredData(specificType = null) {\n    const results = {\n      cleaned: 0,\n      errors: 0,\n      details: {}\n    };\n\n    try {\n      const typesToClean = specificType ? [specificType] : Object.keys(this.retentionPolicies);\n\n      for (const dataType of typesToClean) {\n        const retentionDays = this.retentionPolicies[dataType];\n        if (!retentionDays) continue;\n\n        try {\n          const cleaned = await this.cleanupDataType(dataType, retentionDays);\n          results.cleaned += cleaned;\n          results.details[dataType] = cleaned;\n\n        } catch (error) {\n          console.error(`Failed to cleanup ${dataType}:`, error);\n          results.errors++;\n          results.details[dataType] = `Error: ${error.message}`;\n        }\n      }\n\n      return results;\n\n    } catch (error) {\n      console.error('Failed to cleanup expired data:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Clean up specific data type\n   */\n  async cleanupDataType(dataType, retentionDays) {\n    const cutoffTime = Date.now() - (retentionDays * 24 * 60 * 60 * 1000);\n    let cleaned = 0;\n\n    try {\n      switch (dataType) {\n        case 'command_history':\n          cleaned = await this.cleanupCommandHistory(cutoffTime);\n          break;\n\n        case 'analysis_history':\n          cleaned = await this.cleanupAnalysisHistory(cutoffTime);\n          break;\n\n        case 'cached_data':\n          cleaned = await this.cleanupCachedData(cutoffTime);\n          break;\n\n        case 'export_data':\n          cleaned = await this.cleanupExportData(cutoffTime);\n          break;\n\n        case 'session_data':\n          cleaned = await this.cleanupSessionData(cutoffTime);\n          break;\n\n        default:\n          console.warn(`Unknown data type for cleanup: ${dataType}`);\n      }\n\n      return cleaned;\n\n    } catch (error) {\n      console.error(`Failed to cleanup ${dataType}:`, error);\n      return 0;\n    }\n  }\n\n  /**\n   * Clean up command history\n   */\n  async cleanupCommandHistory(cutoffTime) {\n    const history = await persistenceManager.retrieve('command_history') || [];\n    const filtered = history.filter(entry => \n      new Date(entry.timestamp).getTime() > cutoffTime\n    );\n\n    if (filtered.length < history.length) {\n      await persistenceManager.store('command_history', filtered, {\n        storage: 'indexedDB'\n      });\n      return history.length - filtered.length;\n    }\n\n    return 0;\n  }\n\n  /**\n   * Clean up analysis history\n   */\n  async cleanupAnalysisHistory(cutoffTime) {\n    // Get all analysis history from IndexedDB\n    const allHistory = await persistenceManager.indexedDB.getAll('analysis_history');\n    let cleaned = 0;\n\n    for (const entry of allHistory) {\n      if (entry.timestamp < cutoffTime) {\n        await persistenceManager.indexedDB.remove(entry.id, { storeName: 'analysis_history' });\n        cleaned++;\n      }\n    }\n\n    return cleaned;\n  }\n\n  /**\n   * Clean up cached data\n   */\n  async cleanupCachedData(cutoffTime) {\n    const allCached = await persistenceManager.indexedDB.getAll('cached_data');\n    let cleaned = 0;\n\n    for (const entry of allCached) {\n      if (entry.timestamp < cutoffTime) {\n        await persistenceManager.indexedDB.remove(entry.key, { storeName: 'cached_data' });\n        cleaned++;\n      }\n    }\n\n    return cleaned;\n  }\n\n  /**\n   * Clean up export data\n   */\n  async cleanupExportData(cutoffTime) {\n    const allExports = await persistenceManager.indexedDB.getAll('export_data');\n    let cleaned = 0;\n\n    for (const entry of allExports) {\n      if (entry.timestamp < cutoffTime) {\n        await persistenceManager.indexedDB.remove(entry.id, { storeName: 'export_data' });\n        cleaned++;\n      }\n    }\n\n    return cleaned;\n  }\n\n  /**\n   * Clean up session data\n   */\n  async cleanupSessionData(cutoffTime) {\n    // Session data is typically current, but clean up old session logs if any\n    return 0; // Placeholder\n  }\n\n  /**\n   * Clean up non-essential data\n   */\n  async cleanupNonEssentialData() {\n    const nonEssentialTypes = [\n      ...this.dataCategories.functional,\n      ...this.dataCategories.analytics,\n      ...this.dataCategories.external\n    ];\n\n    let cleaned = 0;\n\n    for (const dataType of nonEssentialTypes) {\n      try {\n        if (dataType === 'command_history') {\n          await persistenceManager.store('command_history', [], { storage: 'indexedDB' });\n          cleaned++;\n        } else if (dataType === 'cached_data') {\n          await persistenceManager.indexedDB.clear('cached_data');\n          cleaned++;\n        }\n        // Add more cleanup logic as needed\n      } catch (error) {\n        console.error(`Failed to cleanup ${dataType}:`, error);\n      }\n    }\n\n    return cleaned;\n  }\n\n  /**\n   * Clean up analytics data\n   */\n  async cleanupAnalyticsData() {\n    const analyticsTypes = this.dataCategories.analytics;\n    \n    for (const dataType of analyticsTypes) {\n      try {\n        await persistenceManager.remove(dataType);\n      } catch (error) {\n        console.error(`Failed to cleanup analytics data ${dataType}:`, error);\n      }\n    }\n  }\n\n  /**\n   * Remove data sharing markers\n   */\n  async removeDataSharingMarkers() {\n    // Remove any markers that indicate data has been shared\n    // This is a placeholder for future implementation\n    console.log('Data sharing markers removed');\n  }\n\n  /**\n   * Export user data (GDPR compliance)\n   */\n  async exportUserData(options = {}) {\n    const {\n      includeEssential = true,\n      includeFunctional = true,\n      includeAnalytics = false,\n      format = 'json'\n    } = options;\n\n    try {\n      const exportData = {\n        exportTimestamp: new Date().toISOString(),\n        privacySettings: this.privacySettings,\n        retentionPolicies: this.retentionPolicies,\n        data: {}\n      };\n\n      // Include data based on categories\n      if (includeEssential) {\n        for (const dataType of this.dataCategories.essential) {\n          const data = await persistenceManager.retrieve(dataType);\n          if (data) {\n            exportData.data[dataType] = data;\n          }\n        }\n      }\n\n      if (includeFunctional) {\n        for (const dataType of this.dataCategories.functional) {\n          const data = await persistenceManager.retrieve(dataType);\n          if (data) {\n            exportData.data[dataType] = data;\n          }\n        }\n      }\n\n      if (includeAnalytics) {\n        for (const dataType of this.dataCategories.analytics) {\n          const data = await persistenceManager.retrieve(dataType);\n          if (data) {\n            exportData.data[dataType] = data;\n          }\n        }\n      }\n\n      return {\n        success: true,\n        data: exportData,\n        size: JSON.stringify(exportData).length,\n        format\n      };\n\n    } catch (error) {\n      console.error('Failed to export user data:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Delete all user data (Right to be forgotten)\n   */\n  async deleteAllUserData(confirmation = false) {\n    if (!confirmation) {\n      throw new Error('Data deletion requires explicit confirmation');\n    }\n\n    try {\n      // Create final backup\n      const backup = await backupService.createBackup({\n        description: 'Final backup before data deletion',\n        compress: true,\n        encrypt: true\n      });\n\n      // Clear all storage\n      await persistenceManager.clear({ storage: 'both', confirm: true });\n\n      // Clear browser storage\n      localStorage.clear();\n      \n      // Clear IndexedDB\n      if (window.indexedDB) {\n        const databases = await indexedDB.databases();\n        for (const db of databases) {\n          if (db.name.includes('FinanceAnalyst')) {\n            indexedDB.deleteDatabase(db.name);\n          }\n        }\n      }\n\n      return {\n        success: true,\n        backup: backup.backupId,\n        timestamp: new Date().toISOString()\n      };\n\n    } catch (error) {\n      console.error('Failed to delete user data:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Get privacy compliance report\n   */\n  async getPrivacyReport() {\n    try {\n      const storageStats = await persistenceManager.getStorageStats();\n      const cleanupResults = await this.cleanupExpiredData();\n\n      return {\n        privacySettings: this.privacySettings,\n        retentionPolicies: this.retentionPolicies,\n        dataCategories: this.dataCategories,\n        storageStats,\n        lastCleanup: cleanupResults,\n        compliance: {\n          gdprCompliant: this.privacySettings.dataRetention,\n          ccpaCompliant: !this.privacySettings.dataSharing,\n          retentionPoliciesActive: Object.keys(this.retentionPolicies).length > 0\n        }\n      };\n\n    } catch (error) {\n      console.error('Failed to generate privacy report:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Schedule automatic cleanup\n   */\n  scheduleCleanup() {\n    // Run cleanup daily\n    setInterval(async () => {\n      try {\n        await this.cleanupExpiredData();\n        console.log('✅ Scheduled privacy cleanup completed');\n      } catch (error) {\n        console.error('❌ Scheduled privacy cleanup failed:', error);\n      }\n    }, 24 * 60 * 60 * 1000); // 24 hours\n\n    // Run cleanup on page load\n    setTimeout(() => {\n      this.cleanupExpiredData().catch(error => {\n        console.error('Initial privacy cleanup failed:', error);\n      });\n    }, 5000); // 5 seconds after initialization\n  }\n\n  /**\n   * Get privacy settings\n   */\n  getPrivacySettings() {\n    return { ...this.privacySettings };\n  }\n\n  /**\n   * Get retention policies\n   */\n  getRetentionPolicies() {\n    return { ...this.retentionPolicies };\n  }\n}\n\n// Export singleton instance\nexport const privacyService = new PrivacyService();\n","/**\n * Sync Service\n * Handles data synchronization for future cloud storage integration\n */\n\nimport { persistenceManager } from './PersistenceManager';\nimport { backupService } from './BackupService';\nimport { CryptoUtils } from '../utils/CryptoUtils';\n\nexport class SyncService {\n  constructor() {\n    this.cryptoUtils = new CryptoUtils();\n    this.syncEndpoint = null; // Future cloud endpoint\n    this.syncInterval = 5 * 60 * 1000; // 5 minutes\n    this.lastSyncTime = null;\n    this.syncInProgress = false;\n    this.conflictResolutionStrategy = 'client_wins'; // client_wins, server_wins, merge\n    this.listeners = new Set();\n    \n    // Sync queue for offline operations\n    this.syncQueue = [];\n    this.maxQueueSize = 100;\n  }\n\n  /**\n   * Initialize sync service\n   */\n  async initialize(config = {}) {\n    try {\n      this.syncEndpoint = config.endpoint || null;\n      this.syncInterval = config.interval || this.syncInterval;\n      this.conflictResolutionStrategy = config.conflictResolution || this.conflictResolutionStrategy;\n\n      // Load last sync time\n      this.lastSyncTime = await persistenceManager.retrieve('last_sync_time');\n      \n      // Load sync queue\n      const queue = await persistenceManager.retrieve('sync_queue');\n      if (queue && Array.isArray(queue)) {\n        this.syncQueue = queue;\n      }\n\n      // Setup periodic sync if endpoint is configured\n      if (this.syncEndpoint) {\n        this.setupPeriodicSync();\n      }\n\n      console.log('✅ Sync service initialized');\n      return { success: true, endpoint: this.syncEndpoint };\n\n    } catch (error) {\n      console.error('❌ Failed to initialize sync service:', error);\n      return { success: false, error: error.message };\n    }\n  }\n\n  /**\n   * Queue a sync operation\n   */\n  async queueSyncOperation(operation) {\n    try {\n      const syncOperation = {\n        id: this.generateOperationId(),\n        type: operation.type, // 'create', 'update', 'delete'\n        dataType: operation.dataType,\n        key: operation.key,\n        data: operation.data,\n        timestamp: Date.now(),\n        retries: 0\n      };\n\n      this.syncQueue.push(syncOperation);\n\n      // Trim queue if too large\n      if (this.syncQueue.length > this.maxQueueSize) {\n        this.syncQueue = this.syncQueue.slice(-this.maxQueueSize);\n      }\n\n      // Save queue\n      await persistenceManager.store('sync_queue', this.syncQueue, {\n        storage: 'localStorage'\n      });\n\n      // Attempt immediate sync if online\n      if (navigator.onLine && this.syncEndpoint) {\n        this.processSyncQueue().catch(error => {\n          console.error('Failed to process sync queue:', error);\n        });\n      }\n\n      return syncOperation.id;\n\n    } catch (error) {\n      console.error('Failed to queue sync operation:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Process sync queue\n   */\n  async processSyncQueue() {\n    if (this.syncInProgress || !this.syncEndpoint || !navigator.onLine) {\n      return { processed: 0, failed: 0 };\n    }\n\n    this.syncInProgress = true;\n    let processed = 0;\n    let failed = 0;\n\n    try {\n      // Process operations in order\n      const operations = [...this.syncQueue];\n      \n      for (const operation of operations) {\n        try {\n          await this.syncOperation(operation);\n          \n          // Remove from queue on success\n          this.syncQueue = this.syncQueue.filter(op => op.id !== operation.id);\n          processed++;\n\n        } catch (error) {\n          console.error(`Failed to sync operation ${operation.id}:`, error);\n          \n          // Increment retry count\n          operation.retries++;\n          \n          // Remove if too many retries\n          if (operation.retries > 3) {\n            this.syncQueue = this.syncQueue.filter(op => op.id !== operation.id);\n            failed++;\n          }\n        }\n      }\n\n      // Save updated queue\n      await persistenceManager.store('sync_queue', this.syncQueue, {\n        storage: 'localStorage'\n      });\n\n      // Update last sync time\n      this.lastSyncTime = Date.now();\n      await persistenceManager.store('last_sync_time', this.lastSyncTime, {\n        storage: 'localStorage'\n      });\n\n      // Notify listeners\n      this.notifyListeners('syncCompleted', { processed, failed });\n\n      return { processed, failed };\n\n    } finally {\n      this.syncInProgress = false;\n    }\n  }\n\n  /**\n   * Sync a single operation (placeholder for future implementation)\n   */\n  async syncOperation(operation) {\n    // This is a placeholder for future cloud sync implementation\n    // For now, we'll simulate the operation\n    \n    if (!this.syncEndpoint) {\n      throw new Error('No sync endpoint configured');\n    }\n\n    // Simulate network delay\n    await new Promise(resolve => setTimeout(resolve, 100));\n\n    // In a real implementation, this would:\n    // 1. Send the operation to the cloud endpoint\n    // 2. Handle authentication\n    // 3. Manage conflicts\n    // 4. Return success/failure\n\n    console.log(`Simulated sync operation: ${operation.type} ${operation.dataType}:${operation.key}`);\n    \n    return { success: true, operation: operation.id };\n  }\n\n  /**\n   * Perform full sync with cloud\n   */\n  async performFullSync() {\n    if (this.syncInProgress || !this.syncEndpoint) {\n      return { success: false, reason: 'Sync in progress or no endpoint' };\n    }\n\n    this.syncInProgress = true;\n\n    try {\n      // Create backup before sync\n      const backup = await backupService.createBackup({\n        description: 'Pre-sync backup',\n        compress: true\n      });\n\n      // Get local data\n      const localData = await this.getLocalSyncData();\n      \n      // Get remote data (placeholder)\n      const remoteData = await this.getRemoteData();\n\n      // Resolve conflicts\n      const mergedData = await this.resolveConflicts(localData, remoteData);\n\n      // Apply merged data locally\n      await this.applyMergedData(mergedData);\n\n      // Update last sync time\n      this.lastSyncTime = Date.now();\n      await persistenceManager.store('last_sync_time', this.lastSyncTime, {\n        storage: 'localStorage'\n      });\n\n      // Clear sync queue\n      this.syncQueue = [];\n      await persistenceManager.store('sync_queue', this.syncQueue, {\n        storage: 'localStorage'\n      });\n\n      // Notify listeners\n      this.notifyListeners('fullSyncCompleted', { backup: backup.backupId });\n\n      return { \n        success: true, \n        timestamp: this.lastSyncTime,\n        backup: backup.backupId \n      };\n\n    } catch (error) {\n      console.error('Full sync failed:', error);\n      \n      // Notify listeners\n      this.notifyListeners('syncFailed', { error: error.message });\n      \n      throw error;\n\n    } finally {\n      this.syncInProgress = false;\n    }\n  }\n\n  /**\n   * Get local data for sync\n   */\n  async getLocalSyncData() {\n    const data = {};\n    \n    // Get all syncable data types\n    const syncableTypes = [\n      'watchlists',\n      'alerts', \n      'user_preferences',\n      'user_variables'\n    ];\n\n    for (const type of syncableTypes) {\n      const typeData = await persistenceManager.retrieve(type);\n      if (typeData) {\n        data[type] = {\n          data: typeData,\n          lastModified: Date.now(), // In real implementation, track actual modification times\n          checksum: await this.calculateChecksum(typeData)\n        };\n      }\n    }\n\n    return data;\n  }\n\n  /**\n   * Get remote data (placeholder)\n   */\n  async getRemoteData() {\n    // Placeholder for future cloud implementation\n    // This would fetch data from the cloud endpoint\n    return {};\n  }\n\n  /**\n   * Resolve conflicts between local and remote data\n   */\n  async resolveConflicts(localData, remoteData) {\n    const merged = {};\n\n    // Get all data types from both sources\n    const allTypes = new Set([\n      ...Object.keys(localData),\n      ...Object.keys(remoteData)\n    ]);\n\n    for (const type of allTypes) {\n      const local = localData[type];\n      const remote = remoteData[type];\n\n      if (!local && remote) {\n        // Only remote data exists\n        merged[type] = remote;\n      } else if (local && !remote) {\n        // Only local data exists\n        merged[type] = local;\n      } else if (local && remote) {\n        // Both exist - resolve conflict\n        merged[type] = await this.resolveDataConflict(type, local, remote);\n      }\n    }\n\n    return merged;\n  }\n\n  /**\n   * Resolve conflict for a specific data type\n   */\n  async resolveDataConflict(type, local, remote) {\n    switch (this.conflictResolutionStrategy) {\n      case 'client_wins':\n        return local;\n      \n      case 'server_wins':\n        return remote;\n      \n      case 'merge':\n        return await this.mergeData(type, local, remote);\n      \n      case 'latest_wins':\n        return local.lastModified > remote.lastModified ? local : remote;\n      \n      default:\n        return local;\n    }\n  }\n\n  /**\n   * Merge data intelligently\n   */\n  async mergeData(type, local, remote) {\n    // Intelligent merging based on data type\n    switch (type) {\n      case 'watchlists':\n        return this.mergeWatchlists(local.data, remote.data);\n      \n      case 'alerts':\n        return this.mergeAlerts(local.data, remote.data);\n      \n      case 'user_preferences':\n        return { ...remote.data, ...local.data }; // Local preferences win\n      \n      default:\n        return local; // Default to local data\n    }\n  }\n\n  /**\n   * Merge watchlists\n   */\n  mergeWatchlists(local, remote) {\n    const merged = { ...remote };\n    \n    // Add local watchlists, keeping newer versions\n    Object.entries(local).forEach(([name, watchlist]) => {\n      if (!merged[name] || \n          new Date(watchlist.lastUpdated) > new Date(merged[name].lastUpdated)) {\n        merged[name] = watchlist;\n      }\n    });\n\n    return merged;\n  }\n\n  /**\n   * Merge alerts\n   */\n  mergeAlerts(local, remote) {\n    const merged = [...remote];\n    const remoteIds = new Set(remote.map(alert => alert.id));\n    \n    // Add local alerts that don't exist remotely\n    local.forEach(alert => {\n      if (!remoteIds.has(alert.id)) {\n        merged.push(alert);\n      }\n    });\n\n    return merged;\n  }\n\n  /**\n   * Apply merged data locally\n   */\n  async applyMergedData(mergedData) {\n    for (const [type, data] of Object.entries(mergedData)) {\n      await persistenceManager.store(type, data.data, {\n        storage: this.determineStorageType(type)\n      });\n    }\n  }\n\n  /**\n   * Calculate checksum for data integrity\n   */\n  async calculateChecksum(data) {\n    const dataString = JSON.stringify(data);\n    return await this.cryptoUtils.hash(dataString);\n  }\n\n  /**\n   * Setup periodic sync\n   */\n  setupPeriodicSync() {\n    setInterval(() => {\n      if (navigator.onLine && !this.syncInProgress) {\n        this.processSyncQueue().catch(error => {\n          console.error('Periodic sync failed:', error);\n        });\n      }\n    }, this.syncInterval);\n\n    // Sync when coming online\n    window.addEventListener('online', () => {\n      this.processSyncQueue().catch(error => {\n        console.error('Online sync failed:', error);\n      });\n    });\n  }\n\n  /**\n   * Get sync status\n   */\n  getSyncStatus() {\n    return {\n      lastSyncTime: this.lastSyncTime,\n      syncInProgress: this.syncInProgress,\n      queueSize: this.syncQueue.length,\n      isOnline: navigator.onLine,\n      hasEndpoint: !!this.syncEndpoint,\n      strategy: this.conflictResolutionStrategy\n    };\n  }\n\n  /**\n   * Add event listener\n   */\n  addEventListener(callback) {\n    this.listeners.add(callback);\n  }\n\n  /**\n   * Remove event listener\n   */\n  removeEventListener(callback) {\n    this.listeners.delete(callback);\n  }\n\n  // Private methods\n\n  generateOperationId() {\n    return 'sync_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);\n  }\n\n  determineStorageType(dataType) {\n    const localStorageTypes = ['user_preferences', 'user_variables'];\n    return localStorageTypes.includes(dataType) ? 'localStorage' : 'indexedDB';\n  }\n\n  notifyListeners(event, data) {\n    this.listeners.forEach(callback => {\n      try {\n        callback(event, data);\n      } catch (error) {\n        console.error('Error in sync event listener:', error);\n      }\n    });\n  }\n}\n\n// Export singleton instance\nexport const syncService = new SyncService();\n","/**\n * Persistence Test Suite\n * Browser-based integration tests for the persistence layer\n */\n\nimport { persistenceManager } from './PersistenceManager';\nimport { backupService } from './BackupService';\nimport { privacyService } from './PrivacyService';\nimport { syncService } from './SyncService';\n\nexport class PersistenceTestSuite {\n  constructor() {\n    this.testResults = [];\n    this.isRunning = false;\n  }\n\n  /**\n   * Run all persistence tests\n   */\n  async runAllTests() {\n    if (this.isRunning) {\n      console.warn('Tests are already running');\n      return this.testResults;\n    }\n\n    this.isRunning = true;\n    this.testResults = [];\n    \n    console.log('🧪 Starting Persistence Layer Test Suite...');\n\n    try {\n      // Core persistence tests\n      await this.testPersistenceManagerInitialization();\n      await this.testDataStorageAndRetrieval();\n      await this.testDataRemoval();\n      await this.testStorageStatistics();\n      \n      // Backup service tests\n      await this.testBackupCreation();\n      await this.testBackupListing();\n      await this.testBackupRestore();\n      \n      // Privacy service tests\n      await this.testPrivacySettings();\n      await this.testDataCleanup();\n      \n      // Sync service tests\n      await this.testSyncStatus();\n      \n      // Integration tests\n      await this.testDataLifecycle();\n      await this.testErrorHandling();\n\n      const passed = this.testResults.filter(r => r.passed).length;\n      const total = this.testResults.length;\n      \n      console.log(`✅ Test Suite Complete: ${passed}/${total} tests passed`);\n      \n      return {\n        passed,\n        total,\n        success: passed === total,\n        results: this.testResults\n      };\n\n    } catch (error) {\n      console.error('❌ Test suite failed:', error);\n      return {\n        passed: 0,\n        total: this.testResults.length,\n        success: false,\n        error: error.message,\n        results: this.testResults\n      };\n    } finally {\n      this.isRunning = false;\n    }\n  }\n\n  /**\n   * Test persistence manager initialization\n   */\n  async testPersistenceManagerInitialization() {\n    const testName = 'Persistence Manager Initialization';\n    \n    try {\n      const result = await persistenceManager.initialize();\n      \n      this.assert(\n        result.success === true,\n        testName,\n        'Should initialize successfully',\n        result\n      );\n      \n      this.assert(\n        persistenceManager.isInitialized === true,\n        testName,\n        'Should set initialized flag',\n        { isInitialized: persistenceManager.isInitialized }\n      );\n\n    } catch (error) {\n      this.recordFailure(testName, error.message);\n    }\n  }\n\n  /**\n   * Test data storage and retrieval\n   */\n  async testDataStorageAndRetrieval() {\n    const testName = 'Data Storage and Retrieval';\n    \n    try {\n      const testData = {\n        test: true,\n        timestamp: Date.now(),\n        data: ['item1', 'item2', 'item3']\n      };\n\n      // Test localStorage storage\n      const storeResult = await persistenceManager.store('test_data', testData, {\n        storage: 'localStorage'\n      });\n      \n      this.assert(\n        storeResult.success === true,\n        testName,\n        'Should store data successfully',\n        storeResult\n      );\n\n      // Test data retrieval\n      const retrievedData = await persistenceManager.retrieve('test_data');\n      \n      this.assert(\n        JSON.stringify(retrievedData) === JSON.stringify(testData),\n        testName,\n        'Should retrieve stored data correctly',\n        { stored: testData, retrieved: retrievedData }\n      );\n\n      // Test IndexedDB storage\n      const indexedStoreResult = await persistenceManager.store('test_indexed_data', testData, {\n        storage: 'indexedDB'\n      });\n      \n      this.assert(\n        indexedStoreResult.success === true,\n        testName,\n        'Should store data in IndexedDB',\n        indexedStoreResult\n      );\n\n    } catch (error) {\n      this.recordFailure(testName, error.message);\n    }\n  }\n\n  /**\n   * Test data removal\n   */\n  async testDataRemoval() {\n    const testName = 'Data Removal';\n    \n    try {\n      // Store test data first\n      await persistenceManager.store('test_removal', { data: 'to_be_removed' });\n      \n      // Remove the data\n      const removeResult = await persistenceManager.remove('test_removal');\n      \n      this.assert(\n        removeResult === true,\n        testName,\n        'Should remove data successfully',\n        { removeResult }\n      );\n\n      // Verify data is gone\n      const retrievedData = await persistenceManager.retrieve('test_removal');\n      \n      this.assert(\n        retrievedData === null,\n        testName,\n        'Should return null for removed data',\n        { retrievedData }\n      );\n\n    } catch (error) {\n      this.recordFailure(testName, error.message);\n    }\n  }\n\n  /**\n   * Test storage statistics\n   */\n  async testStorageStatistics() {\n    const testName = 'Storage Statistics';\n    \n    try {\n      const stats = await persistenceManager.getStorageStats();\n      \n      this.assert(\n        stats !== null && typeof stats === 'object',\n        testName,\n        'Should return storage statistics',\n        stats\n      );\n\n      this.assert(\n        typeof stats.total.used === 'number',\n        testName,\n        'Should include total usage',\n        { totalUsed: stats.total.used }\n      );\n\n    } catch (error) {\n      this.recordFailure(testName, error.message);\n    }\n  }\n\n  /**\n   * Test backup creation\n   */\n  async testBackupCreation() {\n    const testName = 'Backup Creation';\n    \n    try {\n      // Store some test data first\n      await persistenceManager.store('backup_test_data', { \n        test: 'backup_data',\n        timestamp: Date.now()\n      });\n\n      const backup = await backupService.createBackup({\n        description: 'Test backup',\n        compress: true\n      });\n      \n      this.assert(\n        backup.success === true,\n        testName,\n        'Should create backup successfully',\n        backup\n      );\n\n      this.assert(\n        typeof backup.backupId === 'string',\n        testName,\n        'Should return backup ID',\n        { backupId: backup.backupId }\n      );\n\n    } catch (error) {\n      this.recordFailure(testName, error.message);\n    }\n  }\n\n  /**\n   * Test backup listing\n   */\n  async testBackupListing() {\n    const testName = 'Backup Listing';\n    \n    try {\n      const backups = await backupService.listBackups();\n      \n      this.assert(\n        Array.isArray(backups),\n        testName,\n        'Should return array of backups',\n        { backupsCount: backups.length }\n      );\n\n    } catch (error) {\n      this.recordFailure(testName, error.message);\n    }\n  }\n\n  /**\n   * Test backup restore\n   */\n  async testBackupRestore() {\n    const testName = 'Backup Restore';\n    \n    try {\n      // Get available backups\n      const backups = await backupService.listBackups();\n      \n      if (backups.length > 0) {\n        const backupId = backups[0].id;\n        \n        const restoreResult = await backupService.restoreBackup(backupId, {\n          overwrite: false\n        });\n        \n        this.assert(\n          restoreResult.success === true,\n          testName,\n          'Should restore backup successfully',\n          restoreResult\n        );\n      } else {\n        this.recordSkip(testName, 'No backups available for restore test');\n      }\n\n    } catch (error) {\n      this.recordFailure(testName, error.message);\n    }\n  }\n\n  /**\n   * Test privacy settings\n   */\n  async testPrivacySettings() {\n    const testName = 'Privacy Settings';\n    \n    try {\n      const settings = privacyService.getPrivacySettings();\n      \n      this.assert(\n        typeof settings === 'object',\n        testName,\n        'Should return privacy settings',\n        settings\n      );\n\n      // Test updating a setting\n      await privacyService.updatePrivacySettings({ analytics: false });\n      \n      const updatedSettings = privacyService.getPrivacySettings();\n      \n      this.assert(\n        updatedSettings.analytics === false,\n        testName,\n        'Should update privacy settings',\n        { analytics: updatedSettings.analytics }\n      );\n\n    } catch (error) {\n      this.recordFailure(testName, error.message);\n    }\n  }\n\n  /**\n   * Test data cleanup\n   */\n  async testDataCleanup() {\n    const testName = 'Data Cleanup';\n    \n    try {\n      const cleanupResult = await privacyService.cleanupExpiredData();\n      \n      this.assert(\n        typeof cleanupResult.cleaned === 'number',\n        testName,\n        'Should return cleanup results',\n        cleanupResult\n      );\n\n    } catch (error) {\n      this.recordFailure(testName, error.message);\n    }\n  }\n\n  /**\n   * Test sync status\n   */\n  async testSyncStatus() {\n    const testName = 'Sync Status';\n    \n    try {\n      const status = syncService.getSyncStatus();\n      \n      this.assert(\n        typeof status === 'object',\n        testName,\n        'Should return sync status',\n        status\n      );\n\n      this.assert(\n        typeof status.isOnline === 'boolean',\n        testName,\n        'Should include online status',\n        { isOnline: status.isOnline }\n      );\n\n    } catch (error) {\n      this.recordFailure(testName, error.message);\n    }\n  }\n\n  /**\n   * Test complete data lifecycle\n   */\n  async testDataLifecycle() {\n    const testName = 'Data Lifecycle';\n    \n    try {\n      const testKey = 'lifecycle_test';\n      const testData = { lifecycle: true, step: 1 };\n\n      // Store\n      await persistenceManager.store(testKey, testData);\n      \n      // Retrieve\n      const retrieved = await persistenceManager.retrieve(testKey);\n      \n      // Update\n      const updatedData = { ...testData, step: 2 };\n      await persistenceManager.store(testKey, updatedData);\n      \n      // Retrieve updated\n      const retrievedUpdated = await persistenceManager.retrieve(testKey);\n      \n      // Remove\n      await persistenceManager.remove(testKey);\n      \n      // Verify removal\n      const retrievedAfterRemoval = await persistenceManager.retrieve(testKey);\n      \n      this.assert(\n        retrieved.step === 1 && \n        retrievedUpdated.step === 2 && \n        retrievedAfterRemoval === null,\n        testName,\n        'Should handle complete data lifecycle',\n        { \n          initial: retrieved?.step, \n          updated: retrievedUpdated?.step, \n          afterRemoval: retrievedAfterRemoval \n        }\n      );\n\n    } catch (error) {\n      this.recordFailure(testName, error.message);\n    }\n  }\n\n  /**\n   * Test error handling\n   */\n  async testErrorHandling() {\n    const testName = 'Error Handling';\n    \n    try {\n      // Test invalid data retrieval\n      const invalidResult = await persistenceManager.retrieve('non_existent_key_12345');\n      \n      this.assert(\n        invalidResult === null,\n        testName,\n        'Should handle non-existent keys gracefully',\n        { invalidResult }\n      );\n\n      // Test invalid backup restore\n      try {\n        await backupService.restoreBackup('invalid_backup_id');\n        this.recordFailure(testName, 'Should have thrown error for invalid backup ID');\n      } catch (error) {\n        this.assert(\n          true,\n          testName,\n          'Should throw error for invalid backup ID',\n          { error: error.message }\n        );\n      }\n\n    } catch (error) {\n      this.recordFailure(testName, error.message);\n    }\n  }\n\n  // Helper methods\n\n  assert(condition, testName, description, data = null) {\n    const result = {\n      testName,\n      description,\n      passed: !!condition,\n      data,\n      timestamp: new Date().toISOString()\n    };\n\n    this.testResults.push(result);\n\n    if (condition) {\n      console.log(`✅ ${testName}: ${description}`);\n    } else {\n      console.error(`❌ ${testName}: ${description}`, data);\n    }\n  }\n\n  recordFailure(testName, error) {\n    const result = {\n      testName,\n      description: 'Test failed with error',\n      passed: false,\n      error,\n      timestamp: new Date().toISOString()\n    };\n\n    this.testResults.push(result);\n    console.error(`❌ ${testName}: ${error}`);\n  }\n\n  recordSkip(testName, reason) {\n    const result = {\n      testName,\n      description: 'Test skipped',\n      passed: true,\n      skipped: true,\n      reason,\n      timestamp: new Date().toISOString()\n    };\n\n    this.testResults.push(result);\n    console.log(`⏭️ ${testName}: Skipped - ${reason}`);\n  }\n\n  /**\n   * Get test results summary\n   */\n  getTestSummary() {\n    const total = this.testResults.length;\n    const passed = this.testResults.filter(r => r.passed).length;\n    const failed = this.testResults.filter(r => !r.passed).length;\n    const skipped = this.testResults.filter(r => r.skipped).length;\n\n    return {\n      total,\n      passed,\n      failed,\n      skipped,\n      successRate: total > 0 ? (passed / total) * 100 : 0,\n      results: this.testResults\n    };\n  }\n}\n\n// Export singleton instance\nexport const persistenceTestSuite = new PersistenceTestSuite();\n\n// Global test function for browser console\nwindow.testPersistence = () => persistenceTestSuite.runAllTests();\n"],"names":["CryptoUtils","constructor","this","algorithm","keyLength","ivLength","tagLength","textEncoder","TextEncoder","textDecoder","TextDecoder","initializeKey","storedKey","localStorage","getItem","keyData","base64ToArrayBuffer","cryptoKey","crypto","subtle","importKey","name","generateKey","length","exportedKey","exportKey","keyString","arrayBufferToBase64","setItem","error","encrypt","data","dataBuffer","encode","iv","getRandomValues","Uint8Array","encryptedBuffer","combined","byteLength","set","buffer","Error","message","decrypt","encryptedData","slice","decryptedBuffer","decode","hash","hashBuffer","digest","verifyIntegrity","expectedHash","generateRandomString","array","substring","deriveKeyFromPassword","password","salt","passwordBuffer","saltBuffer","keyMaterial","deriveKey","iterations","isAvailable","window","getInfo","available","keyInitialized","bytes","binary","i","String","fromCharCode","btoa","base64","atob","charCodeAt","clearSensitiveData","ArrayBuffer","view","performanceTest","testData","JSON","stringify","test","Array","fill","timestamp","Date","now","encryptStart","performance","encrypted","encryptTime","decryptStart","decryptTime","totalTime","dataSize","encryptedSize","compressionRatio","CompressionUtils","compressionFormat","compress","compressWithStream","compressWithLZString","decompress","compressedData","isNativeCompressed","decompressWithStream","decompressWithLZString","stream","CompressionStream","writer","writable","getWriter","reader","readable","getReader","write","close","chunks","done","value","readerDone","read","push","totalLength","reduce","sum","chunk","offset","replace","compressedBuffer","DecompressionStream","dictionary","Map","result","dictSize","current","char","has","get","compressed","Uint16Array","previous","code","startsWith","isLZStringCompressed","isCompressed","getCompressionRatio","originalData","originalSize","Blob","size","estimateCompressionBenefit","compressedSize","ratio","savings","savingsPercentage","worthCompressing","nativeCompressionAvailable","fallbackAvailable","defaultFormat","repeat","numbers","map","_","compressStart","compressTime","decompressStart","decompressTime","method","LocalStorageService","prefix","maxSize","cryptoUtils","compressionUtils","initialize","testKey","removeItem","success","store","key","options","ttl","validate","validateData","storageObject","metadata","version","serializedData","storageKey","retrieve","validateTTL","parse","parseError","decompressed","decompressError","remove","clear","Object","keys","filter","forEach","getKeys","getStats","used","totalSize","itemCount","itemSizes","usagePercentage","largestItem","entries","max","exportAll","exportData","importData","overwrite","results","imported","skipped","errors","hasSpace","cleanup","cleaned","seen","WeakSet","checkCircular","obj","add","isStorageAvailable","writeStart","writeTime","readStart","readTime","IndexedDBService","dbName","dbVersion","db","stores","watchlists","keyPath","autoIncrement","indexes","unique","analysis_history","command_history","alerts","cached_data","user_models","export_data","indexedDB","openDatabase","cleanupExpiredData","Promise","resolve","reject","request","open","onerror","onsuccess","onupgradeneeded","event","target","createObjectStores","storeName","objectStoreNames","contains","deleteObjectStore","config","createObjectStore","index","createIndex","dataObject","performTransaction","put","expiry","delete","storeObj","getAllKeys","getAll","limit","filteredResults","query","indexName","total","records","stats","recordCount","storeSize","record","id","cachedData","mode","operation","transaction","objectStore","oncomplete","storeCount","SessionManager","sessionKey","userKey","preferencesKey","currentSession","currentUser","sessionTimeout","listeners","Set","defaultPreferences","currency","precision","dateFormat","theme","notifications","autoSave","commandHistory","dataRetention","privacy","analytics","crashReporting","dataSharing","loadSession","setupSessionMonitoring","hasSession","createSession","userInfo","sessionId","generateSessionId","session","userId","generateUserId","created","lastActivity","expires","userAgent","navigator","platform","language","timezone","Intl","DateTimeFormat","resolvedOptions","timeZone","user","email","lastLogin","loginCount","preferences","storeSession","storeUser","notifyListeners","sessionData","userData","destroySession","updateActivity","getSession","getUser","isAuthenticated","getPreferences","updatePreferences","newPreferences","getSessionStats","sessionDuration","timeUntilExpiry","lastActivityAge","userName","userCreated","isExpired","isActive","exportSessionData","exportTimestamp","importSessionData","addEventListener","callback","removeEventListener","Math","random","toString","substr","throttledUpdate","throttle","document","passive","setInterval","hidden","func","inThrottle","args","arguments","apply","setTimeout","DataMigrationService","currentVersion","migrationKey","backupKey","migrations","to","description","migrate","migrateToV1_0_0","bind","checkAndMigrate","currentStoredVersion","performVersionMigration","performInitialMigration","legacyData","detectLegacyData","createMigrationBackup","fromVersion","toVersion","migrationPath","findMigrationPath","currentData","exportCurrentData","migration","restoreFromBackup","oldVariables","variables","oldSettings","settings","oldWatchlists","oldAlerts","includes","e","dataToMigrate","migratedWatchlists","migrateWatchlistsFormat","migratedAlerts","migrateAlertsFormat","migratedPreferences","migratePreferencesFormat","migratedVariables","migrateVariablesFormat","cleanupLegacyData","migrated","isArray","watchlist","tickers","stocks","toISOString","split","lastUpdated","alert","ticker","condition","triggered","backup","backupData","getMigrationStatus","storedVersion","hasBackup","needsMigration","availableMigrations","clearBackup","persistenceManager","sessionManager","migrationService","isInitialized","storageQuota","storageStrategy","checkStorageAvailability","all","estimateStorageQuota","availableStorage","getAvailableStorage","ensureInitialized","storage","determineStorageLayer","promises","confirm","getStorageStats","localStorageStats","indexedDBStats","totalUsed","quota","format","includeMetadata","localStorageData","indexedDBData","storageStats","exportOptions","validateImportData","estimate","usage","backupService","backupVersion","maxBackupSize","maxBackups","createBackup","includeSettings","includeWatchlists","includeAlerts","includeHistory","includeCachedData","analysisHistory","backupString","backupId","generateBackupId","storeBackup","cleanupOldBackups","restoreBackup","selectiveRestore","createBackupBeforeRestore","retrieveBackup","isVersionCompatible","dataToRestore","filterBackupData","restoreResults","restored","details","dataType","determineStorageType","backupTimestamp","restoreTimestamp","listBackups","backupKeys","backups","sort","a","b","deleteBackup","exportBackupToFile","filename","dataString","blob","type","importBackupFromFile","fileContent","getBackupStats","totalBackups","oldestBackup","newestBackup","encryptedBackups","compressedBackups","backupRecord","backupsToDelete","dataTypes","filtered","privacyService","retentionPolicies","session_data","privacySettings","cookieConsent","trackingConsent","dataCategories","essential","functional","marketing","external","policies","scheduleCleanup","updatePrivacySettings","newSettings","handlePrivacySettingChanges","cleanupNonEssentialData","cleanupAnalyticsData","removeDataSharingMarkers","setRetentionPolicy","days","policy","specificType","typesToClean","retentionDays","cleanupDataType","cutoffTime","cleanupCommandHistory","cleanupAnalysisHistory","cleanupCachedData","cleanupExportData","cleanupSessionData","history","entry","getTime","allHistory","allCached","allExports","nonEssentialTypes","analyticsTypes","exportUserData","includeEssential","includeFunctional","includeAnalytics","deleteAllUserData","confirmation","databases","deleteDatabase","getPrivacyReport","cleanupResults","lastCleanup","compliance","gdprCompliant","ccpaCompliant","retentionPoliciesActive","async","catch","getPrivacySettings","getRetentionPolicies","syncService","syncEndpoint","syncInterval","lastSyncTime","syncInProgress","conflictResolutionStrategy","syncQueue","maxQueueSize","endpoint","interval","conflictResolution","queue","setupPeriodicSync","queueSyncOperation","syncOperation","generateOperationId","retries","onLine","processSyncQueue","processed","failed","operations","op","performFullSync","reason","localData","getLocalSyncData","remoteData","getRemoteData","mergedData","resolveConflicts","applyMergedData","syncableTypes","typeData","lastModified","checksum","calculateChecksum","merged","allTypes","local","remote","resolveDataConflict","mergeData","mergeWatchlists","mergeAlerts","remoteIds","getSyncStatus","queueSize","isOnline","hasEndpoint","strategy","persistenceTestSuite","testResults","isRunning","runAllTests","testPersistenceManagerInitialization","testDataStorageAndRetrieval","testDataRemoval","testStorageStatistics","testBackupCreation","testBackupListing","testBackupRestore","testPrivacySettings","testDataCleanup","testSyncStatus","testDataLifecycle","testErrorHandling","passed","r","testName","assert","recordFailure","storeResult","retrievedData","stored","retrieved","indexedStoreResult","removeResult","backupsCount","restoreResult","recordSkip","updatedSettings","cleanupResult","status","lifecycle","step","updatedData","retrievedUpdated","retrievedAfterRemoval","initial","updated","afterRemoval","invalidResult","getTestSummary","successRate","testPersistence"],"mappings":"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"}