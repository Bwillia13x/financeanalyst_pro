{"version":3,"file":"persistence-DNoCNU4C.js","sources":["../../src/services/persistence/DataMigrationService.js","../../src/services/utils/CompressionUtils.js","../../src/services/persistence/IndexedDBService.js","../../src/services/utils/CryptoUtils.js","../../src/services/persistence/LocalStorageService.js","../../src/services/persistence/SessionManager.js","../../src/services/persistence/PersistenceManager.js"],"sourcesContent":["/**\n * Data Migration Service\n * Handles data migrations between different versions and storage formats\n */\n\nexport class DataMigrationService {\n  constructor() {\n    this.currentVersion = '1.0.0';\n    this.migrationKey = 'financeanalyst_migration_version';\n    this.backupKey = 'financeanalyst_migration_backup';\n\n    // Define migration paths\n    this.migrations = {\n      '0.0.0': {\n        to: '1.0.0',\n        description: 'Initial migration to structured persistence layer',\n        migrate: this.migrateToV1_0_0.bind(this)\n      }\n      // Future migrations will be added here\n    };\n  }\n\n  /**\n   * Check if migration is needed and perform it\n   */\n  async checkAndMigrate() {\n    try {\n      const currentStoredVersion = localStorage.getItem(this.migrationKey);\n\n      if (!currentStoredVersion) {\n        // First time setup - check for legacy data\n        await this.performInitialMigration();\n      } else if (currentStoredVersion !== this.currentVersion) {\n        // Version mismatch - perform migration\n        await this.performVersionMigration(currentStoredVersion, this.currentVersion);\n      }\n\n      // Update stored version\n      localStorage.setItem(this.migrationKey, this.currentVersion);\n\n      console.log(`‚úÖ Data migration complete - version ${this.currentVersion}`);\n      return { success: true, version: this.currentVersion };\n\n    } catch (error) {\n      console.error('‚ùå Data migration failed:', error);\n      return { success: false, error: error.message };\n    }\n  }\n\n  /**\n   * Perform initial migration from legacy data\n   */\n  async performInitialMigration() {\n    console.log('üîÑ Performing initial data migration...');\n\n    try {\n      // Check for legacy data patterns\n      const legacyData = await this.detectLegacyData();\n\n      if (Object.keys(legacyData).length > 0) {\n        // Create backup before migration\n        await this.createMigrationBackup(legacyData);\n\n        // Migrate legacy data to new format\n        await this.migrateToV1_0_0(legacyData);\n\n        console.log('‚úÖ Legacy data migrated successfully');\n      } else {\n        console.log('‚ÑπÔ∏è No legacy data found - clean installation');\n      }\n\n    } catch (error) {\n      console.error('Failed to perform initial migration:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Perform version-to-version migration\n   */\n  async performVersionMigration(fromVersion, toVersion) {\n    console.log(`üîÑ Migrating data from ${fromVersion} to ${toVersion}...`);\n\n    try {\n      // Find migration path\n      const migrationPath = this.findMigrationPath(fromVersion, toVersion);\n\n      if (!migrationPath.length) {\n        throw new Error(`No migration path found from ${fromVersion} to ${toVersion}`);\n      }\n\n      // Create backup before migration\n      const currentData = await this.exportCurrentData();\n      await this.createMigrationBackup(currentData, fromVersion);\n\n      // Execute migrations in sequence\n      for (const migration of migrationPath) {\n        console.log(`üîÑ Applying migration: ${migration.description}`);\n        await migration.migrate();\n      }\n\n      console.log('‚úÖ Version migration completed successfully');\n\n    } catch (error) {\n      console.error('Failed to perform version migration:', error);\n\n      // Attempt to restore from backup\n      await this.restoreFromBackup();\n      throw error;\n    }\n  }\n\n  /**\n   * Detect legacy data in localStorage\n   */\n  async detectLegacyData() {\n    const legacyData = {};\n\n    try {\n      // Check for old command processor data\n      const oldVariables = localStorage.getItem('commandProcessor_variables');\n      if (oldVariables) {\n        legacyData.variables = JSON.parse(oldVariables);\n      }\n\n      // Check for old settings\n      const oldSettings = localStorage.getItem('commandProcessor_settings');\n      if (oldSettings) {\n        legacyData.settings = JSON.parse(oldSettings);\n      }\n\n      // Check for old watchlists (if stored differently)\n      const oldWatchlists = localStorage.getItem('watchlists');\n      if (oldWatchlists) {\n        legacyData.watchlists = JSON.parse(oldWatchlists);\n      }\n\n      // Check for old alerts\n      const oldAlerts = localStorage.getItem('alerts');\n      if (oldAlerts) {\n        legacyData.alerts = JSON.parse(oldAlerts);\n      }\n\n      // Check for any other financeanalyst_ prefixed items\n      Object.keys(localStorage).forEach(key => {\n        if (key.startsWith('financeanalyst_') &&\n            !key.includes('migration') &&\n            !key.includes('session') &&\n            !key.includes('user') &&\n            !key.includes('crypto_key')) {\n          try {\n            legacyData[key] = JSON.parse(localStorage.getItem(key));\n          } catch (e) {\n            legacyData[key] = localStorage.getItem(key);\n          }\n        }\n      });\n\n      return legacyData;\n\n    } catch (error) {\n      console.error('Failed to detect legacy data:', error);\n      return {};\n    }\n  }\n\n  /**\n   * Migration to version 1.0.0\n   */\n  async migrateToV1_0_0(legacyData = null) {\n    try {\n      const dataToMigrate = legacyData || await this.detectLegacyData();\n\n      // Migrate watchlists to new format\n      if (dataToMigrate.watchlists) {\n        const migratedWatchlists = this.migrateWatchlistsFormat(dataToMigrate.watchlists);\n        localStorage.setItem('financeanalyst_watchlists', JSON.stringify(migratedWatchlists));\n      }\n\n      // Migrate alerts to new format\n      if (dataToMigrate.alerts) {\n        const migratedAlerts = this.migrateAlertsFormat(dataToMigrate.alerts);\n        localStorage.setItem('financeanalyst_alerts', JSON.stringify(migratedAlerts));\n      }\n\n      // Migrate user preferences\n      if (dataToMigrate.settings) {\n        const migratedPreferences = this.migratePreferencesFormat(dataToMigrate.settings);\n        localStorage.setItem('financeanalyst_preferences', JSON.stringify(migratedPreferences));\n      }\n\n      // Migrate variables to new storage\n      if (dataToMigrate.variables) {\n        const migratedVariables = this.migrateVariablesFormat(dataToMigrate.variables);\n        localStorage.setItem('financeanalyst_user_variables', JSON.stringify(migratedVariables));\n      }\n\n      // Clean up old data\n      await this.cleanupLegacyData(dataToMigrate);\n\n      console.log('‚úÖ Migration to v1.0.0 completed');\n\n    } catch (error) {\n      console.error('Failed to migrate to v1.0.0:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Migrate watchlists to new format\n   */\n  migrateWatchlistsFormat(oldWatchlists) {\n    const migrated = {};\n\n    if (Array.isArray(oldWatchlists)) {\n      // Old format was array, convert to object\n      oldWatchlists.forEach((watchlist, index) => {\n        const name = watchlist.name || `Watchlist ${index + 1}`;\n        migrated[name] = {\n          tickers: watchlist.tickers || watchlist.stocks || [],\n          created: watchlist.created || new Date().toISOString().split('T')[0],\n          lastUpdated: watchlist.lastUpdated || null\n        };\n      });\n    } else if (typeof oldWatchlists === 'object') {\n      // Already in object format, just ensure structure\n      Object.entries(oldWatchlists).forEach(([name, data]) => {\n        migrated[name] = {\n          tickers: data.tickers || data.stocks || [],\n          created: data.created || new Date().toISOString().split('T')[0],\n          lastUpdated: data.lastUpdated || null\n        };\n      });\n    }\n\n    return migrated;\n  }\n\n  /**\n   * Migrate alerts to new format\n   */\n  migrateAlertsFormat(oldAlerts) {\n    if (!Array.isArray(oldAlerts)) {\n      return [];\n    }\n\n    return oldAlerts.map(alert => ({\n      id: alert.id || Date.now() + Math.random(),\n      ticker: alert.ticker,\n      condition: alert.condition,\n      value: alert.value,\n      created: alert.created || new Date().toISOString().split('T')[0],\n      triggered: alert.triggered || false\n    }));\n  }\n\n  /**\n   * Migrate preferences to new format\n   */\n  migratePreferencesFormat(oldSettings) {\n    return {\n      currency: oldSettings.currency || 'USD',\n      precision: oldSettings.precision || 2,\n      dateFormat: oldSettings.dateFormat || 'YYYY-MM-DD',\n      theme: oldSettings.theme || 'dark',\n      notifications: oldSettings.notifications !== false,\n      autoSave: oldSettings.autoSave !== false,\n      commandHistory: oldSettings.commandHistory !== false,\n      dataRetention: oldSettings.dataRetention || 30,\n      privacy: {\n        analytics: oldSettings.analytics || false,\n        crashReporting: oldSettings.crashReporting !== false,\n        dataSharing: oldSettings.dataSharing || false\n      }\n    };\n  }\n\n  /**\n   * Migrate variables to new format\n   */\n  migrateVariablesFormat(oldVariables) {\n    // Variables format should remain mostly the same\n    return { ...oldVariables };\n  }\n\n  /**\n   * Clean up legacy data after migration\n   */\n  async cleanupLegacyData(legacyData) {\n    try {\n      // Remove old localStorage keys\n      const keysToRemove = [\n        'commandProcessor_variables',\n        'commandProcessor_settings',\n        'watchlists',\n        'alerts'\n      ];\n\n      keysToRemove.forEach(key => {\n        if (localStorage.getItem(key)) {\n          localStorage.removeItem(key);\n        }\n      });\n\n      // Remove other legacy keys found in detection\n      Object.keys(legacyData).forEach(key => {\n        if (key.startsWith('financeanalyst_') &&\n            !key.includes('migration') &&\n            !key.includes('session') &&\n            !key.includes('user') &&\n            !key.includes('crypto_key')) {\n          localStorage.removeItem(key);\n        }\n      });\n\n      console.log('‚úÖ Legacy data cleanup completed');\n\n    } catch (error) {\n      console.error('Failed to cleanup legacy data:', error);\n      // Don't throw - cleanup failure shouldn't break migration\n    }\n  }\n\n  /**\n   * Create backup before migration\n   */\n  async createMigrationBackup(data, version = 'legacy') {\n    try {\n      const backup = {\n        version,\n        timestamp: new Date().toISOString(),\n        data\n      };\n\n      localStorage.setItem(this.backupKey, JSON.stringify(backup));\n      console.log(`‚úÖ Migration backup created for version ${version}`);\n\n    } catch (error) {\n      console.error('Failed to create migration backup:', error);\n      // Don't throw - backup failure shouldn't prevent migration\n    }\n  }\n\n  /**\n   * Restore from migration backup\n   */\n  async restoreFromBackup() {\n    try {\n      const backupData = localStorage.getItem(this.backupKey);\n      if (!backupData) {\n        throw new Error('No migration backup found');\n      }\n\n      const backup = JSON.parse(backupData);\n\n      // Restore data based on backup version\n      if (backup.version === 'legacy') {\n        // Restore legacy format\n        Object.entries(backup.data).forEach(([key, value]) => {\n          localStorage.setItem(key, typeof value === 'string' ? value : JSON.stringify(value));\n        });\n      }\n\n      console.log('‚úÖ Data restored from migration backup');\n      return true;\n\n    } catch (error) {\n      console.error('Failed to restore from backup:', error);\n      return false;\n    }\n  }\n\n  /**\n   * Export current data for backup\n   */\n  async exportCurrentData() {\n    const data = {};\n\n    Object.keys(localStorage).forEach(key => {\n      if (key.startsWith('financeanalyst_')) {\n        try {\n          data[key] = JSON.parse(localStorage.getItem(key));\n        } catch (e) {\n          data[key] = localStorage.getItem(key);\n        }\n      }\n    });\n\n    return data;\n  }\n\n  /**\n   * Find migration path between versions\n   */\n  findMigrationPath(fromVersion, toVersion) {\n    // For now, simple direct migration\n    // In the future, this could handle complex migration chains\n    const migration = this.migrations[fromVersion];\n\n    if (migration && migration.to === toVersion) {\n      return [migration];\n    }\n\n    return [];\n  }\n\n  /**\n   * Get migration status\n   */\n  getMigrationStatus() {\n    const storedVersion = localStorage.getItem(this.migrationKey);\n    const hasBackup = !!localStorage.getItem(this.backupKey);\n\n    return {\n      currentVersion: this.currentVersion,\n      storedVersion,\n      needsMigration: storedVersion !== this.currentVersion,\n      hasBackup,\n      availableMigrations: Object.keys(this.migrations)\n    };\n  }\n\n  /**\n   * Clear migration backup\n   */\n  clearBackup() {\n    localStorage.removeItem(this.backupKey);\n    console.log('‚úÖ Migration backup cleared');\n  }\n}\n","/**\n * Compression Utils\n * Provides data compression utilities for efficient storage\n */\n\nexport class CompressionUtils {\n  constructor() {\n    this.compressionFormat = 'gzip';\n    this.textEncoder = new TextEncoder();\n    this.textDecoder = new TextDecoder();\n  }\n\n  /**\n   * Compress data using browser's native compression\n   */\n  async compress(data) {\n    try {\n      // Check if CompressionStream is available (modern browsers)\n      if ('CompressionStream' in window) {\n        return await this.compressWithStream(data);\n      } else {\n        // Fallback to LZ-string compression\n        return await this.compressWithLZString(data);\n      }\n    } catch (error) {\n      console.error('Compression failed:', error);\n      // Return original data if compression fails\n      return data;\n    }\n  }\n\n  /**\n   * Decompress data\n   */\n  async decompress(compressedData) {\n    try {\n      // Try native decompression first\n      if ('DecompressionStream' in window && this.isNativeCompressed(compressedData)) {\n        return await this.decompressWithStream(compressedData);\n      } else {\n        // Try LZ-string decompression\n        return await this.decompressWithLZString(compressedData);\n      }\n    } catch (error) {\n      console.error('Decompression failed:', error);\n      // Return original data if decompression fails\n      return compressedData;\n    }\n  }\n\n  /**\n   * Compress using native CompressionStream\n   */\n  async compressWithStream(data) {\n    const stream = new CompressionStream(this.compressionFormat);\n    const writer = stream.writable.getWriter();\n    const reader = stream.readable.getReader();\n\n    // Write data to compression stream\n    const dataBuffer = this.textEncoder.encode(data);\n    writer.write(dataBuffer);\n    writer.close();\n\n    // Read compressed data\n    const chunks = [];\n    let done = false;\n\n    while (!done) {\n      const { value, done: readerDone } = await reader.read();\n      done = readerDone;\n      if (value) {\n        chunks.push(value);\n      }\n    }\n\n    // Combine chunks and convert to base64\n    const totalLength = chunks.reduce((sum, chunk) => sum + chunk.length, 0);\n    const combined = new Uint8Array(totalLength);\n    let offset = 0;\n\n    for (const chunk of chunks) {\n      combined.set(chunk, offset);\n      offset += chunk.length;\n    }\n\n    // Add marker to identify native compression\n    return 'NATIVE_GZIP:' + this.arrayBufferToBase64(combined.buffer);\n  }\n\n  /**\n   * Decompress using native DecompressionStream\n   */\n  async decompressWithStream(compressedData) {\n    // Remove marker\n    const data = compressedData.replace('NATIVE_GZIP:', '');\n    const compressedBuffer = this.base64ToArrayBuffer(data);\n\n    const stream = new DecompressionStream(this.compressionFormat);\n    const writer = stream.writable.getWriter();\n    const reader = stream.readable.getReader();\n\n    // Write compressed data to decompression stream\n    writer.write(new Uint8Array(compressedBuffer));\n    writer.close();\n\n    // Read decompressed data\n    const chunks = [];\n    let done = false;\n\n    while (!done) {\n      const { value, done: readerDone } = await reader.read();\n      done = readerDone;\n      if (value) {\n        chunks.push(value);\n      }\n    }\n\n    // Combine chunks and convert to string\n    const totalLength = chunks.reduce((sum, chunk) => sum + chunk.length, 0);\n    const combined = new Uint8Array(totalLength);\n    let offset = 0;\n\n    for (const chunk of chunks) {\n      combined.set(chunk, offset);\n      offset += chunk.length;\n    }\n\n    return this.textDecoder.decode(combined);\n  }\n\n  /**\n   * Compress using LZ-string algorithm (fallback)\n   */\n  async compressWithLZString(data) {\n    // Simple LZ77-style compression implementation\n    const dictionary = new Map();\n    const result = [];\n    let dictSize = 256;\n\n    // Initialize dictionary with single characters\n    for (let i = 0; i < 256; i++) {\n      dictionary.set(String.fromCharCode(i), i);\n    }\n\n    let current = '';\n    for (let i = 0; i < data.length; i++) {\n      const char = data[i];\n      const combined = current + char;\n\n      if (dictionary.has(combined)) {\n        current = combined;\n      } else {\n        result.push(dictionary.get(current));\n        dictionary.set(combined, dictSize++);\n        current = char;\n      }\n    }\n\n    if (current) {\n      result.push(dictionary.get(current));\n    }\n\n    // Convert to base64\n    const compressed = new Uint16Array(result);\n    return 'LZ_STRING:' + this.arrayBufferToBase64(compressed.buffer);\n  }\n\n  /**\n   * Decompress LZ-string compressed data\n   */\n  async decompressWithLZString(compressedData) {\n    // Remove marker\n    const data = compressedData.replace('LZ_STRING:', '');\n    const buffer = this.base64ToArrayBuffer(data);\n    const compressed = new Uint16Array(buffer);\n\n    const dictionary = new Map();\n    let dictSize = 256;\n\n    // Initialize dictionary\n    for (let i = 0; i < 256; i++) {\n      dictionary.set(i, String.fromCharCode(i));\n    }\n\n    let result = '';\n    let previous = String.fromCharCode(compressed[0]);\n    result += previous;\n\n    for (let i = 1; i < compressed.length; i++) {\n      const code = compressed[i];\n      let current;\n\n      if (dictionary.has(code)) {\n        current = dictionary.get(code);\n      } else if (code === dictSize) {\n        current = previous + previous[0];\n      } else {\n        throw new Error('Invalid compressed data');\n      }\n\n      result += current;\n      dictionary.set(dictSize++, previous + current[0]);\n      previous = current;\n    }\n\n    return result;\n  }\n\n  /**\n   * Check if data is compressed with native compression\n   */\n  isNativeCompressed(data) {\n    return typeof data === 'string' && data.startsWith('NATIVE_GZIP:');\n  }\n\n  /**\n   * Check if data is compressed with LZ-string\n   */\n  isLZStringCompressed(data) {\n    return typeof data === 'string' && data.startsWith('LZ_STRING:');\n  }\n\n  /**\n   * Check if data appears to be compressed\n   */\n  isCompressed(data) {\n    return this.isNativeCompressed(data) || this.isLZStringCompressed(data);\n  }\n\n  /**\n   * Get compression ratio\n   */\n  getCompressionRatio(originalData, compressedData) {\n    const originalSize = new Blob([originalData]).size;\n    const compressedSize = new Blob([compressedData]).size;\n    return compressedSize / originalSize;\n  }\n\n  /**\n   * Estimate compression benefit\n   */\n  async estimateCompressionBenefit(data) {\n    try {\n      const originalSize = new Blob([data]).size;\n      const compressed = await this.compress(data);\n      const compressedSize = new Blob([compressed]).size;\n\n      return {\n        originalSize,\n        compressedSize,\n        ratio: compressedSize / originalSize,\n        savings: originalSize - compressedSize,\n        savingsPercentage: ((originalSize - compressedSize) / originalSize) * 100,\n        worthCompressing: compressedSize < originalSize * 0.9 // 10% savings threshold\n      };\n    } catch (error) {\n      return {\n        originalSize: new Blob([data]).size,\n        compressedSize: new Blob([data]).size,\n        ratio: 1,\n        savings: 0,\n        savingsPercentage: 0,\n        worthCompressing: false,\n        error: error.message\n      };\n    }\n  }\n\n  /**\n   * Check if compression is available\n   */\n  isAvailable() {\n    return 'CompressionStream' in window || true; // LZ-string fallback always available\n  }\n\n  /**\n   * Get compression info\n   */\n  getInfo() {\n    return {\n      nativeCompressionAvailable: 'CompressionStream' in window,\n      fallbackAvailable: true,\n      defaultFormat: this.compressionFormat,\n      available: this.isAvailable()\n    };\n  }\n\n  /**\n   * Test compression performance\n   */\n  async performanceTest() {\n    const testData = JSON.stringify({\n      test: 'compression performance',\n      data: new Array(1000).fill('This is test data for compression performance testing. '.repeat(10)),\n      numbers: new Array(100).fill(0).map((_, i) => i),\n      timestamp: Date.now()\n    });\n\n    const iterations = 20;\n\n    try {\n      // Test compression performance\n      const compressStart = performance.now();\n      let compressed;\n      for (let i = 0; i < iterations; i++) {\n        compressed = await this.compress(testData);\n      }\n      const compressTime = performance.now() - compressStart;\n\n      // Test decompression performance\n      const decompressStart = performance.now();\n      for (let i = 0; i < iterations; i++) {\n        await this.decompress(compressed);\n      }\n      const decompressTime = performance.now() - decompressStart;\n\n      const compressionRatio = this.getCompressionRatio(testData, compressed);\n\n      return {\n        compressTime: compressTime / iterations,\n        decompressTime: decompressTime / iterations,\n        totalTime: compressTime + decompressTime,\n        originalSize: testData.length,\n        compressedSize: compressed.length,\n        compressionRatio,\n        savingsPercentage: (1 - compressionRatio) * 100,\n        iterations,\n        method: this.isNativeCompressed(compressed) ? 'native' : 'lz-string'\n      };\n\n    } catch (error) {\n      console.error('Compression performance test failed:', error);\n      return null;\n    }\n  }\n\n  // Utility methods\n\n  /**\n   * Convert ArrayBuffer to base64 string\n   */\n  arrayBufferToBase64(buffer) {\n    const bytes = new Uint8Array(buffer);\n    let binary = '';\n    for (let i = 0; i < bytes.byteLength; i++) {\n      binary += String.fromCharCode(bytes[i]);\n    }\n    return btoa(binary);\n  }\n\n  /**\n   * Convert base64 string to ArrayBuffer\n   */\n  base64ToArrayBuffer(base64) {\n    const binary = atob(base64);\n    const bytes = new Uint8Array(binary.length);\n    for (let i = 0; i < binary.length; i++) {\n      bytes[i] = binary.charCodeAt(i);\n    }\n    return bytes.buffer;\n  }\n}\n","/**\n * IndexedDB Service\n * Manages IndexedDB operations for complex data storage with versioning and transactions\n */\n\nimport { CompressionUtils } from '../utils/CompressionUtils';\n\nexport class IndexedDBService {\n  constructor() {\n    this.dbName = 'FinanceAnalystPro';\n    this.dbVersion = 1;\n    this.db = null;\n    this.isAvailable = false;\n    this.compressionUtils = new CompressionUtils();\n\n    // Define object stores\n    this.stores = {\n      watchlists: {\n        keyPath: 'id',\n        autoIncrement: true,\n        indexes: [\n          { name: 'name', keyPath: 'name', unique: true },\n          { name: 'created', keyPath: 'created' },\n          { name: 'lastUpdated', keyPath: 'lastUpdated' }\n        ]\n      },\n      analysis_history: {\n        keyPath: 'id',\n        autoIncrement: true,\n        indexes: [\n          { name: 'ticker', keyPath: 'ticker' },\n          { name: 'analysisType', keyPath: 'analysisType' },\n          { name: 'timestamp', keyPath: 'timestamp' }\n        ]\n      },\n      command_history: {\n        keyPath: 'id',\n        autoIncrement: true,\n        indexes: [\n          { name: 'command', keyPath: 'command' },\n          { name: 'timestamp', keyPath: 'timestamp' },\n          { name: 'success', keyPath: 'success' }\n        ]\n      },\n      alerts: {\n        keyPath: 'id',\n        autoIncrement: true,\n        indexes: [\n          { name: 'ticker', keyPath: 'ticker' },\n          { name: 'condition', keyPath: 'condition' },\n          { name: 'created', keyPath: 'created' },\n          { name: 'triggered', keyPath: 'triggered' }\n        ]\n      },\n      cached_data: {\n        keyPath: 'key',\n        indexes: [\n          { name: 'timestamp', keyPath: 'timestamp' },\n          { name: 'expiry', keyPath: 'expiry' },\n          { name: 'dataType', keyPath: 'dataType' }\n        ]\n      },\n      user_models: {\n        keyPath: 'id',\n        autoIncrement: true,\n        indexes: [\n          { name: 'name', keyPath: 'name' },\n          { name: 'type', keyPath: 'type' },\n          { name: 'created', keyPath: 'created' }\n        ]\n      },\n      export_data: {\n        keyPath: 'id',\n        autoIncrement: true,\n        indexes: [\n          { name: 'timestamp', keyPath: 'timestamp' },\n          { name: 'type', keyPath: 'type' }\n        ]\n      }\n    };\n  }\n\n  /**\n   * Initialize IndexedDB service\n   */\n  async initialize() {\n    if (!window.indexedDB) {\n      console.warn('‚ö†Ô∏è IndexedDB not available');\n      this.isAvailable = false;\n      return { success: false, available: false };\n    }\n\n    try {\n      this.db = await this.openDatabase();\n      this.isAvailable = true;\n      console.log('‚úÖ IndexedDB service initialized');\n\n      // Cleanup expired data\n      await this.cleanupExpiredData();\n\n      return { success: true, available: true, version: this.dbVersion };\n    } catch (error) {\n      console.error('‚ùå Failed to initialize IndexedDB:', error);\n      this.isAvailable = false;\n      return { success: false, available: false, error: error.message };\n    }\n  }\n\n  /**\n   * Open IndexedDB database\n   */\n  async openDatabase() {\n    return new Promise((resolve, reject) => {\n      const request = indexedDB.open(this.dbName, this.dbVersion);\n\n      request.onerror = () => {\n        reject(new Error(`Failed to open database: ${request.error}`));\n      };\n\n      request.onsuccess = () => {\n        resolve(request.result);\n      };\n\n      request.onupgradeneeded = (event) => {\n        const db = event.target.result;\n        this.createObjectStores(db);\n      };\n    });\n  }\n\n  /**\n   * Create object stores during database upgrade\n   */\n  createObjectStores(db) {\n    // Remove existing stores if they exist\n    for (const storeName of Object.keys(this.stores)) {\n      if (db.objectStoreNames.contains(storeName)) {\n        db.deleteObjectStore(storeName);\n      }\n    }\n\n    // Create new stores\n    for (const [storeName, config] of Object.entries(this.stores)) {\n      const store = db.createObjectStore(storeName, {\n        keyPath: config.keyPath,\n        autoIncrement: config.autoIncrement\n      });\n\n      // Create indexes\n      if (config.indexes) {\n        config.indexes.forEach(index => {\n          store.createIndex(index.name, index.keyPath, { unique: index.unique || false });\n        });\n      }\n    }\n\n    console.log('‚úÖ IndexedDB object stores created');\n  }\n\n  /**\n   * Store data in IndexedDB\n   */\n  async store(key, data, options = {}) {\n    if (!this.isAvailable) {\n      throw new Error('IndexedDB is not available');\n    }\n\n    const {\n      storeName = 'cached_data',\n      metadata = {},\n      compress = false\n    } = options;\n\n    try {\n      // Prepare data object\n      const dataObject = {\n        key,\n        data,\n        timestamp: Date.now(),\n        metadata: {\n          ...metadata,\n          compressed: compress,\n          originalSize: JSON.stringify(data).length\n        }\n      };\n\n      // Compress if requested\n      if (compress) {\n        const compressed = await this.compressionUtils.compress(JSON.stringify(data));\n        dataObject.data = compressed;\n        dataObject.metadata.compressedSize = compressed.length;\n      }\n\n      // Store in IndexedDB\n      const result = await this.performTransaction(storeName, 'readwrite', (store) => {\n        return store.put(dataObject);\n      });\n\n      return {\n        success: true,\n        key: result,\n        storeName,\n        size: JSON.stringify(dataObject).length,\n        metadata: dataObject.metadata\n      };\n\n    } catch (error) {\n      console.error(`Failed to store data in IndexedDB for key \"${key}\":`, error);\n      throw error;\n    }\n  }\n\n  /**\n   * Retrieve data from IndexedDB\n   */\n  async retrieve(key, options = {}) {\n    if (!this.isAvailable) {\n      return null;\n    }\n\n    const { storeName = 'cached_data' } = options;\n\n    try {\n      const result = await this.performTransaction(storeName, 'readonly', (store) => {\n        return store.get(key);\n      });\n\n      if (!result) {\n        return null;\n      }\n\n      // Check expiry if applicable\n      if (result.metadata && result.metadata.expiry && Date.now() > result.metadata.expiry) {\n        await this.remove(key, { storeName });\n        return null;\n      }\n\n      // Decompress if needed\n      let data = result.data;\n      if (result.metadata && result.metadata.compressed) {\n        data = JSON.parse(await this.compressionUtils.decompress(data));\n      }\n\n      return {\n        data,\n        metadata: result.metadata,\n        timestamp: result.timestamp\n      };\n\n    } catch (error) {\n      console.error(`Failed to retrieve data from IndexedDB for key \"${key}\":`, error);\n      return null;\n    }\n  }\n\n  /**\n   * Remove data from IndexedDB\n   */\n  async remove(key, options = {}) {\n    if (!this.isAvailable) {\n      return false;\n    }\n\n    const { storeName = 'cached_data' } = options;\n\n    try {\n      await this.performTransaction(storeName, 'readwrite', (store) => {\n        return store.delete(key);\n      });\n\n      return true;\n    } catch (error) {\n      console.error(`Failed to remove data from IndexedDB for key \"${key}\":`, error);\n      return false;\n    }\n  }\n\n  /**\n   * Clear all data from a store\n   */\n  async clear(storeName = null) {\n    if (!this.isAvailable) {\n      return false;\n    }\n\n    try {\n      if (storeName) {\n        // Clear specific store\n        await this.performTransaction(storeName, 'readwrite', (store) => {\n          return store.clear();\n        });\n      } else {\n        // Clear all stores\n        for (const store of Object.keys(this.stores)) {\n          await this.performTransaction(store, 'readwrite', (storeObj) => {\n            return storeObj.clear();\n          });\n        }\n      }\n\n      return true;\n    } catch (error) {\n      console.error('Failed to clear IndexedDB:', error);\n      return false;\n    }\n  }\n\n  /**\n   * Get all keys from a store\n   */\n  async getKeys(storeName = 'cached_data') {\n    if (!this.isAvailable) {\n      return [];\n    }\n\n    try {\n      return await this.performTransaction(storeName, 'readonly', (store) => {\n        return store.getAllKeys();\n      });\n    } catch (error) {\n      console.error(`Failed to get keys from IndexedDB store \"${storeName}\":`, error);\n      return [];\n    }\n  }\n\n  /**\n   * Get all data from a store\n   */\n  async getAll(storeName = 'cached_data', options = {}) {\n    if (!this.isAvailable) {\n      return [];\n    }\n\n    const { limit = null, filter = null } = options;\n\n    try {\n      const results = await this.performTransaction(storeName, 'readonly', (store) => {\n        return store.getAll();\n      });\n\n      let filteredResults = results;\n\n      // Apply filter if provided\n      if (filter) {\n        filteredResults = results.filter(filter);\n      }\n\n      // Apply limit if provided\n      if (limit) {\n        filteredResults = filteredResults.slice(0, limit);\n      }\n\n      return filteredResults;\n    } catch (error) {\n      console.error(`Failed to get all data from IndexedDB store \"${storeName}\":`, error);\n      return [];\n    }\n  }\n\n  /**\n   * Query data using an index\n   */\n  async query(storeName, indexName, value, options = {}) {\n    if (!this.isAvailable) {\n      return [];\n    }\n\n    const { limit = null } = options;\n\n    try {\n      return await this.performTransaction(storeName, 'readonly', (store) => {\n        const index = store.index(indexName);\n        const request = limit ? index.getAll(value, limit) : index.getAll(value);\n        return request;\n      });\n    } catch (error) {\n      console.error(`Failed to query IndexedDB store \"${storeName}\" with index \"${indexName}\":`, error);\n      return [];\n    }\n  }\n\n  /**\n   * Get storage statistics\n   */\n  async getStats() {\n    if (!this.isAvailable) {\n      return { available: false, stores: {}, total: { records: 0, size: 0 } };\n    }\n\n    try {\n      const stats = {\n        available: true,\n        stores: {},\n        total: { records: 0, size: 0 }\n      };\n\n      for (const storeName of Object.keys(this.stores)) {\n        const records = await this.getAll(storeName);\n        const recordCount = records.length;\n        const storeSize = records.reduce((size, record) => {\n          return size + JSON.stringify(record).length;\n        }, 0);\n\n        stats.stores[storeName] = {\n          records: recordCount,\n          size: storeSize\n        };\n\n        stats.total.records += recordCount;\n        stats.total.size += storeSize;\n      }\n\n      return stats;\n    } catch (error) {\n      console.error('Failed to get IndexedDB stats:', error);\n      return { available: false, error: error.message };\n    }\n  }\n\n  /**\n   * Export all data from IndexedDB\n   */\n  async exportAll() {\n    if (!this.isAvailable) {\n      return {};\n    }\n\n    try {\n      const exportData = {};\n\n      for (const storeName of Object.keys(this.stores)) {\n        exportData[storeName] = await this.getAll(storeName);\n      }\n\n      return exportData;\n    } catch (error) {\n      console.error('Failed to export IndexedDB data:', error);\n      return {};\n    }\n  }\n\n  /**\n   * Import data into IndexedDB\n   */\n  async importData(importData, options = {}) {\n    if (!this.isAvailable) {\n      throw new Error('IndexedDB is not available');\n    }\n\n    const { overwrite = false } = options;\n\n    try {\n      const results = {\n        imported: 0,\n        skipped: 0,\n        errors: 0\n      };\n\n      for (const [storeName, records] of Object.entries(importData)) {\n        if (!this.stores[storeName]) {\n          console.warn(`Unknown store: ${storeName}`);\n          continue;\n        }\n\n        for (const record of records) {\n          try {\n            if (!overwrite) {\n              // Check if record exists\n              const existing = await this.retrieve(record.key || record.id, { storeName });\n              if (existing) {\n                results.skipped++;\n                continue;\n              }\n            }\n\n            await this.performTransaction(storeName, 'readwrite', (store) => {\n              return store.put(record);\n            });\n\n            results.imported++;\n          } catch (error) {\n            console.error(`Failed to import record to store \"${storeName}\":`, error);\n            results.errors++;\n          }\n        }\n      }\n\n      return results;\n    } catch (error) {\n      console.error('Failed to import IndexedDB data:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Cleanup expired data\n   */\n  async cleanupExpiredData() {\n    if (!this.isAvailable) {\n      return { cleaned: 0 };\n    }\n\n    try {\n      let cleaned = 0;\n      const now = Date.now();\n\n      // Cleanup cached_data store\n      const cachedData = await this.getAll('cached_data');\n      for (const record of cachedData) {\n        if (record.metadata && record.metadata.expiry && now > record.metadata.expiry) {\n          await this.remove(record.key, { storeName: 'cached_data' });\n          cleaned++;\n        }\n      }\n\n      return { cleaned };\n    } catch (error) {\n      console.error('Failed to cleanup expired data:', error);\n      return { cleaned: 0, error: error.message };\n    }\n  }\n\n  /**\n   * Perform IndexedDB transaction\n   */\n  async performTransaction(storeName, mode, operation) {\n    return new Promise((resolve, reject) => {\n      const transaction = this.db.transaction([storeName], mode);\n      const store = transaction.objectStore(storeName);\n\n      transaction.onerror = () => {\n        reject(new Error(`Transaction failed: ${transaction.error}`));\n      };\n\n      transaction.oncomplete = () => {\n        // Transaction completed successfully\n      };\n\n      const request = operation(store);\n\n      request.onsuccess = () => {\n        resolve(request.result);\n      };\n\n      request.onerror = () => {\n        reject(new Error(`Operation failed: ${request.error}`));\n      };\n    });\n  }\n\n  /**\n   * Check if IndexedDB is available\n   */\n  isStorageAvailable() {\n    return this.isAvailable;\n  }\n\n  /**\n   * Get database info\n   */\n  getInfo() {\n    return {\n      dbName: this.dbName,\n      dbVersion: this.dbVersion,\n      available: this.isAvailable,\n      stores: Object.keys(this.stores),\n      storeCount: Object.keys(this.stores).length\n    };\n  }\n}\n","/**\n * Crypto Utils\n * Provides encryption and decryption utilities for data persistence\n */\n\nexport class CryptoUtils {\n  constructor() {\n    this.algorithm = 'AES-GCM';\n    this.keyLength = 256;\n    this.ivLength = 12; // 96 bits for GCM\n    this.tagLength = 16; // 128 bits for GCM\n    this.textEncoder = new TextEncoder();\n    this.textDecoder = new TextDecoder();\n\n    // Generate or retrieve encryption key\n    this.initializeKey();\n  }\n\n  /**\n   * Initialize encryption key\n   */\n  async initializeKey() {\n    try {\n      // Try to get existing key from localStorage\n      const storedKey = localStorage.getItem('financeanalyst_crypto_key');\n\n      if (storedKey) {\n        // Import existing key\n        const keyData = this.base64ToArrayBuffer(storedKey);\n        this.cryptoKey = await crypto.subtle.importKey(\n          'raw',\n          keyData,\n          { name: this.algorithm },\n          false,\n          ['encrypt', 'decrypt']\n        );\n      } else {\n        // Generate new key\n        this.cryptoKey = await crypto.subtle.generateKey(\n          {\n            name: this.algorithm,\n            length: this.keyLength\n          },\n          true,\n          ['encrypt', 'decrypt']\n        );\n\n        // Store key for future use\n        const exportedKey = await crypto.subtle.exportKey('raw', this.cryptoKey);\n        const keyString = this.arrayBufferToBase64(exportedKey);\n        localStorage.setItem('financeanalyst_crypto_key', keyString);\n      }\n\n      console.log('‚úÖ Crypto key initialized');\n    } catch (error) {\n      console.error('‚ùå Failed to initialize crypto key:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Encrypt data\n   */\n  async encrypt(data) {\n    if (!this.cryptoKey) {\n      await this.initializeKey();\n    }\n\n    try {\n      // Convert string to ArrayBuffer\n      const dataBuffer = this.textEncoder.encode(data);\n\n      // Generate random IV\n      const iv = crypto.getRandomValues(new Uint8Array(this.ivLength));\n\n      // Encrypt data\n      const encryptedBuffer = await crypto.subtle.encrypt(\n        {\n          name: this.algorithm,\n          iv\n        },\n        this.cryptoKey,\n        dataBuffer\n      );\n\n      // Combine IV and encrypted data\n      const combined = new Uint8Array(iv.length + encryptedBuffer.byteLength);\n      combined.set(iv, 0);\n      combined.set(new Uint8Array(encryptedBuffer), iv.length);\n\n      // Convert to base64 for storage\n      return this.arrayBufferToBase64(combined.buffer);\n\n    } catch (error) {\n      console.error('Encryption failed:', error);\n      throw new Error(`Encryption failed: ${error.message}`);\n    }\n  }\n\n  /**\n   * Decrypt data\n   */\n  async decrypt(encryptedData) {\n    if (!this.cryptoKey) {\n      await this.initializeKey();\n    }\n\n    try {\n      // Convert base64 to ArrayBuffer\n      const combined = this.base64ToArrayBuffer(encryptedData);\n\n      // Extract IV and encrypted data\n      const iv = combined.slice(0, this.ivLength);\n      const encryptedBuffer = combined.slice(this.ivLength);\n\n      // Decrypt data\n      const decryptedBuffer = await crypto.subtle.decrypt(\n        {\n          name: this.algorithm,\n          iv\n        },\n        this.cryptoKey,\n        encryptedBuffer\n      );\n\n      // Convert back to string\n      return this.textDecoder.decode(decryptedBuffer);\n\n    } catch (error) {\n      console.error('Decryption failed:', error);\n      throw new Error(`Decryption failed: ${error.message}`);\n    }\n  }\n\n  /**\n   * Generate hash of data\n   */\n  async hash(data) {\n    try {\n      const dataBuffer = this.textEncoder.encode(data);\n      const hashBuffer = await crypto.subtle.digest('SHA-256', dataBuffer);\n      return this.arrayBufferToBase64(hashBuffer);\n    } catch (error) {\n      console.error('Hashing failed:', error);\n      throw new Error(`Hashing failed: ${error.message}`);\n    }\n  }\n\n  /**\n   * Verify data integrity\n   */\n  async verifyIntegrity(data, expectedHash) {\n    try {\n      const actualHash = await this.hash(data);\n      return actualHash === expectedHash;\n    } catch (error) {\n      console.error('Integrity verification failed:', error);\n      return false;\n    }\n  }\n\n  /**\n   * Generate secure random string\n   */\n  generateRandomString(length = 32) {\n    const array = new Uint8Array(length);\n    crypto.getRandomValues(array);\n    return this.arrayBufferToBase64(array.buffer).substring(0, length);\n  }\n\n  /**\n   * Derive key from password (for future use)\n   */\n  async deriveKeyFromPassword(password, salt) {\n    try {\n      const passwordBuffer = this.textEncoder.encode(password);\n      const saltBuffer = this.textEncoder.encode(salt);\n\n      // Import password as key material\n      const keyMaterial = await crypto.subtle.importKey(\n        'raw',\n        passwordBuffer,\n        { name: 'PBKDF2' },\n        false,\n        ['deriveKey']\n      );\n\n      // Derive key using PBKDF2\n      const derivedKey = await crypto.subtle.deriveKey(\n        {\n          name: 'PBKDF2',\n          salt: saltBuffer,\n          iterations: 100000,\n          hash: 'SHA-256'\n        },\n        keyMaterial,\n        {\n          name: this.algorithm,\n          length: this.keyLength\n        },\n        false,\n        ['encrypt', 'decrypt']\n      );\n\n      return derivedKey;\n\n    } catch (error) {\n      console.error('Key derivation failed:', error);\n      throw new Error(`Key derivation failed: ${error.message}`);\n    }\n  }\n\n  /**\n   * Check if Web Crypto API is available\n   */\n  isAvailable() {\n    return !!(window.crypto && window.crypto.subtle);\n  }\n\n  /**\n   * Get encryption info\n   */\n  getInfo() {\n    return {\n      algorithm: this.algorithm,\n      keyLength: this.keyLength,\n      ivLength: this.ivLength,\n      available: this.isAvailable(),\n      keyInitialized: !!this.cryptoKey\n    };\n  }\n\n  // Utility methods\n\n  /**\n   * Convert ArrayBuffer to base64 string\n   */\n  arrayBufferToBase64(buffer) {\n    const bytes = new Uint8Array(buffer);\n    let binary = '';\n    for (let i = 0; i < bytes.byteLength; i++) {\n      binary += String.fromCharCode(bytes[i]);\n    }\n    return btoa(binary);\n  }\n\n  /**\n   * Convert base64 string to ArrayBuffer\n   */\n  base64ToArrayBuffer(base64) {\n    const binary = atob(base64);\n    const bytes = new Uint8Array(binary.length);\n    for (let i = 0; i < binary.length; i++) {\n      bytes[i] = binary.charCodeAt(i);\n    }\n    return bytes.buffer;\n  }\n\n  /**\n   * Securely clear sensitive data from memory\n   */\n  clearSensitiveData(data) {\n    if (data instanceof ArrayBuffer) {\n      const view = new Uint8Array(data);\n      crypto.getRandomValues(view);\n    } else if (typeof data === 'string') {\n      // For strings, we can't directly clear memory in JavaScript\n      // but we can at least overwrite the reference\n      data = null;\n    }\n  }\n\n  /**\n   * Test encryption/decryption performance\n   */\n  async performanceTest() {\n    if (!this.isAvailable()) {\n      return null;\n    }\n\n    const testData = JSON.stringify({\n      test: 'performance',\n      data: new Array(1000).fill('test data for performance testing'),\n      timestamp: Date.now()\n    });\n\n    const iterations = 50;\n\n    try {\n      // Test encryption performance\n      const encryptStart = performance.now();\n      let encrypted;\n      for (let i = 0; i < iterations; i++) {\n        encrypted = await this.encrypt(testData);\n      }\n      const encryptTime = performance.now() - encryptStart;\n\n      // Test decryption performance\n      const decryptStart = performance.now();\n      for (let i = 0; i < iterations; i++) {\n        await this.decrypt(encrypted);\n      }\n      const decryptTime = performance.now() - decryptStart;\n\n      return {\n        encryptTime: encryptTime / iterations,\n        decryptTime: decryptTime / iterations,\n        totalTime: encryptTime + decryptTime,\n        dataSize: testData.length,\n        encryptedSize: encrypted.length,\n        compressionRatio: encrypted.length / testData.length,\n        iterations\n      };\n\n    } catch (error) {\n      console.error('Crypto performance test failed:', error);\n      return null;\n    }\n  }\n}\n","/**\n * Local Storage Service\n * Manages localStorage operations with encryption, compression, and data validation\n */\n\nimport { CompressionUtils } from '../utils/CompressionUtils';\nimport { CryptoUtils } from '../utils/CryptoUtils';\n\nexport class LocalStorageService {\n  constructor() {\n    this.prefix = 'financeanalyst_';\n    this.isAvailable = false;\n    this.maxSize = 5 * 1024 * 1024; // 5MB typical localStorage limit\n    this.cryptoUtils = new CryptoUtils();\n    this.compressionUtils = new CompressionUtils();\n  }\n\n  /**\n   * Initialize the localStorage service\n   */\n  async initialize() {\n    try {\n      // Test localStorage availability\n      const testKey = this.prefix + 'test';\n      localStorage.setItem(testKey, 'test');\n      localStorage.removeItem(testKey);\n\n      this.isAvailable = true;\n      console.log('‚úÖ LocalStorage service initialized');\n\n      return { success: true, available: true };\n    } catch (error) {\n      console.warn('‚ö†Ô∏è LocalStorage not available:', error);\n      this.isAvailable = false;\n      return { success: false, available: false, error: error.message };\n    }\n  }\n\n  /**\n   * Store data in localStorage\n   */\n  async store(key, data, options = {}) {\n    if (!this.isAvailable) {\n      throw new Error('localStorage is not available');\n    }\n\n    const {\n      encrypt = false,\n      compress = false,\n      ttl = null,\n      validate = true\n    } = options;\n\n    try {\n      // Validate data if requested\n      if (validate && !this.validateData(data)) {\n        throw new Error('Invalid data format');\n      }\n\n      // Prepare storage object\n      const storageObject = {\n        data,\n        metadata: {\n          timestamp: Date.now(),\n          version: '1.0',\n          encrypted: encrypt,\n          compressed: compress,\n          ttl,\n          originalSize: JSON.stringify(data).length\n        }\n      };\n\n      let serializedData = JSON.stringify(storageObject);\n\n      // Compress if requested\n      if (compress) {\n        serializedData = await this.compressionUtils.compress(serializedData);\n        storageObject.metadata.compressedSize = serializedData.length;\n      }\n\n      // Encrypt if requested\n      if (encrypt) {\n        serializedData = await this.cryptoUtils.encrypt(serializedData);\n      }\n\n      // Check size limits\n      if (serializedData.length > this.maxSize) {\n        throw new Error(`Data too large: ${serializedData.length} bytes exceeds ${this.maxSize} bytes`);\n      }\n\n      // Store in localStorage\n      const storageKey = this.prefix + key;\n      localStorage.setItem(storageKey, serializedData);\n\n      return {\n        success: true,\n        key: storageKey,\n        size: serializedData.length,\n        metadata: storageObject.metadata\n      };\n\n    } catch (error) {\n      console.error(`Failed to store data in localStorage for key \"${key}\":`, error);\n      throw error;\n    }\n  }\n\n  /**\n   * Retrieve data from localStorage\n   */\n  async retrieve(key, options = {}) {\n    if (!this.isAvailable) {\n      return null;\n    }\n\n    const { decrypt = false, validateTTL = true } = options;\n\n    try {\n      const storageKey = this.prefix + key;\n      let serializedData = localStorage.getItem(storageKey);\n\n      if (!serializedData) {\n        return null;\n      }\n\n      // Decrypt if needed\n      if (decrypt) {\n        serializedData = await this.cryptoUtils.decrypt(serializedData);\n      }\n\n      // Decompress if needed\n      let storageObject;\n      try {\n        storageObject = JSON.parse(serializedData);\n      } catch (parseError) {\n        // Try decompression first\n        try {\n          const decompressed = await this.compressionUtils.decompress(serializedData);\n          storageObject = JSON.parse(decompressed);\n        } catch (decompressError) {\n          throw new Error('Failed to parse stored data');\n        }\n      }\n\n      // Validate TTL\n      if (validateTTL && storageObject.metadata && storageObject.metadata.ttl) {\n        const now = Date.now();\n        const expiry = storageObject.metadata.timestamp + storageObject.metadata.ttl;\n\n        if (now > expiry) {\n          await this.remove(key);\n          return null;\n        }\n      }\n\n      return {\n        data: storageObject.data,\n        metadata: storageObject.metadata\n      };\n\n    } catch (error) {\n      console.error(`Failed to retrieve data from localStorage for key \"${key}\":`, error);\n      return null;\n    }\n  }\n\n  /**\n   * Remove data from localStorage\n   */\n  async remove(key) {\n    if (!this.isAvailable) {\n      return false;\n    }\n\n    try {\n      const storageKey = this.prefix + key;\n      localStorage.removeItem(storageKey);\n      return true;\n    } catch (error) {\n      console.error(`Failed to remove data from localStorage for key \"${key}\":`, error);\n      return false;\n    }\n  }\n\n  /**\n   * Clear all application data from localStorage\n   */\n  async clear() {\n    if (!this.isAvailable) {\n      return false;\n    }\n\n    try {\n      const keys = Object.keys(localStorage);\n      const appKeys = keys.filter(key => key.startsWith(this.prefix));\n\n      appKeys.forEach(key => {\n        localStorage.removeItem(key);\n      });\n\n      return true;\n    } catch (error) {\n      console.error('Failed to clear localStorage:', error);\n      return false;\n    }\n  }\n\n  /**\n   * Get all keys for this application\n   */\n  async getKeys() {\n    if (!this.isAvailable) {\n      return [];\n    }\n\n    try {\n      const keys = Object.keys(localStorage);\n      return keys\n        .filter(key => key.startsWith(this.prefix))\n        .map(key => key.substring(this.prefix.length));\n    } catch (error) {\n      console.error('Failed to get localStorage keys:', error);\n      return [];\n    }\n  }\n\n  /**\n   * Get storage statistics\n   */\n  async getStats() {\n    if (!this.isAvailable) {\n      return { available: false, used: 0, keys: 0 };\n    }\n\n    try {\n      const keys = await this.getKeys();\n      let totalSize = 0;\n      let itemCount = 0;\n      const itemSizes = {};\n\n      for (const key of keys) {\n        const storageKey = this.prefix + key;\n        const data = localStorage.getItem(storageKey);\n        if (data) {\n          const size = data.length;\n          totalSize += size;\n          itemCount++;\n          itemSizes[key] = size;\n        }\n      }\n\n      return {\n        available: true,\n        used: totalSize,\n        keys: itemCount,\n        maxSize: this.maxSize,\n        usagePercentage: (totalSize / this.maxSize) * 100,\n        itemSizes,\n        largestItem: Object.entries(itemSizes).reduce((max, [key, size]) =>\n          size > max.size ? { key, size } : max, { key: null, size: 0 })\n      };\n\n    } catch (error) {\n      console.error('Failed to get localStorage stats:', error);\n      return { available: false, used: 0, keys: 0, error: error.message };\n    }\n  }\n\n  /**\n   * Export all application data\n   */\n  async exportAll() {\n    if (!this.isAvailable) {\n      return {};\n    }\n\n    try {\n      const keys = await this.getKeys();\n      const exportData = {};\n\n      for (const key of keys) {\n        const data = await this.retrieve(key, { validateTTL: false });\n        if (data) {\n          exportData[key] = data;\n        }\n      }\n\n      return exportData;\n    } catch (error) {\n      console.error('Failed to export localStorage data:', error);\n      return {};\n    }\n  }\n\n  /**\n   * Import data into localStorage\n   */\n  async importData(importData, options = {}) {\n    if (!this.isAvailable) {\n      throw new Error('localStorage is not available');\n    }\n\n    const { overwrite = false } = options;\n\n    try {\n      const results = {\n        imported: 0,\n        skipped: 0,\n        errors: 0\n      };\n\n      for (const [key, data] of Object.entries(importData)) {\n        try {\n          // Check if key exists and overwrite setting\n          const existing = await this.retrieve(key, { validateTTL: false });\n          if (existing && !overwrite) {\n            results.skipped++;\n            continue;\n          }\n\n          // Import the data\n          await this.store(key, data.data, {\n            encrypt: data.metadata?.encrypted || false,\n            compress: data.metadata?.compressed || false,\n            ttl: data.metadata?.ttl || null\n          });\n\n          results.imported++;\n        } catch (error) {\n          console.error(`Failed to import key \"${key}\":`, error);\n          results.errors++;\n        }\n      }\n\n      return results;\n    } catch (error) {\n      console.error('Failed to import localStorage data:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Check if localStorage has enough space for data\n   */\n  async hasSpace(dataSize) {\n    if (!this.isAvailable) {\n      return false;\n    }\n\n    try {\n      const stats = await this.getStats();\n      return (stats.used + dataSize) <= this.maxSize;\n    } catch (error) {\n      return false;\n    }\n  }\n\n  /**\n   * Cleanup expired items\n   */\n  async cleanup() {\n    if (!this.isAvailable) {\n      return { cleaned: 0 };\n    }\n\n    try {\n      const keys = await this.getKeys();\n      let cleaned = 0;\n\n      for (const key of keys) {\n        const data = await this.retrieve(key, { validateTTL: true });\n        if (!data) {\n          cleaned++; // Item was expired and removed\n        }\n      }\n\n      return { cleaned };\n    } catch (error) {\n      console.error('Failed to cleanup localStorage:', error);\n      return { cleaned: 0, error: error.message };\n    }\n  }\n\n  /**\n   * Validate data before storage\n   */\n  validateData(data) {\n    try {\n      // Check if data is serializable\n      JSON.stringify(data);\n\n      // Check for circular references\n      const seen = new WeakSet();\n      const checkCircular = (obj) => {\n        if (obj !== null && typeof obj === 'object') {\n          if (seen.has(obj)) {\n            return false;\n          }\n          seen.add(obj);\n          for (const key in obj) {\n            if (!checkCircular(obj[key])) {\n              return false;\n            }\n          }\n        }\n        return true;\n      };\n\n      return checkCircular(data);\n    } catch (error) {\n      return false;\n    }\n  }\n\n  /**\n   * Get localStorage availability status\n   */\n  isStorageAvailable() {\n    return this.isAvailable;\n  }\n\n  /**\n   * Test localStorage performance\n   */\n  async performanceTest() {\n    if (!this.isAvailable) {\n      return null;\n    }\n\n    const testData = { test: 'performance', data: new Array(1000).fill('test') };\n    const iterations = 100;\n\n    try {\n      // Test write performance\n      const writeStart = performance.now();\n      for (let i = 0; i < iterations; i++) {\n        await this.store(`perf_test_${i}`, testData);\n      }\n      const writeTime = performance.now() - writeStart;\n\n      // Test read performance\n      const readStart = performance.now();\n      for (let i = 0; i < iterations; i++) {\n        await this.retrieve(`perf_test_${i}`);\n      }\n      const readTime = performance.now() - readStart;\n\n      // Cleanup test data\n      for (let i = 0; i < iterations; i++) {\n        await this.remove(`perf_test_${i}`);\n      }\n\n      return {\n        writeTime: writeTime / iterations,\n        readTime: readTime / iterations,\n        totalTime: writeTime + readTime,\n        iterations\n      };\n\n    } catch (error) {\n      console.error('Performance test failed:', error);\n      return null;\n    }\n  }\n}\n","/**\n * Session Manager\n * Manages user sessions, authentication state, and session persistence\n */\n\nimport { CryptoUtils } from '../utils/CryptoUtils';\n\nexport class SessionManager {\n  constructor() {\n    this.sessionKey = 'financeanalyst_session';\n    this.userKey = 'financeanalyst_user';\n    this.preferencesKey = 'financeanalyst_preferences';\n    this.cryptoUtils = new CryptoUtils();\n\n    this.currentSession = null;\n    this.currentUser = null;\n    this.sessionTimeout = 24 * 60 * 60 * 1000; // 24 hours\n    this.listeners = new Set();\n\n    // Default user preferences\n    this.defaultPreferences = {\n      currency: 'USD',\n      precision: 2,\n      dateFormat: 'YYYY-MM-DD',\n      theme: 'dark',\n      notifications: true,\n      autoSave: true,\n      commandHistory: true,\n      dataRetention: 30, // days\n      privacy: {\n        analytics: false,\n        crashReporting: true,\n        dataSharing: false\n      }\n    };\n  }\n\n  /**\n   * Initialize session manager\n   */\n  async initialize() {\n    try {\n      // Load existing session\n      await this.loadSession();\n\n      // Setup session monitoring\n      this.setupSessionMonitoring();\n\n      console.log('‚úÖ Session Manager initialized');\n      return { success: true, hasSession: !!this.currentSession };\n    } catch (error) {\n      console.error('‚ùå Failed to initialize Session Manager:', error);\n      return { success: false, error: error.message };\n    }\n  }\n\n  /**\n   * Create a new session\n   */\n  async createSession(userInfo = {}) {\n    try {\n      const sessionId = this.generateSessionId();\n      const now = Date.now();\n\n      const session = {\n        id: sessionId,\n        userId: userInfo.id || this.generateUserId(),\n        created: now,\n        lastActivity: now,\n        expires: now + this.sessionTimeout,\n        userAgent: navigator.userAgent,\n        platform: navigator.platform,\n        language: navigator.language,\n        timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,\n        version: '1.0'\n      };\n\n      const user = {\n        id: session.userId,\n        name: userInfo.name || 'Anonymous User',\n        email: userInfo.email || null,\n        created: userInfo.created || now,\n        lastLogin: now,\n        loginCount: (userInfo.loginCount || 0) + 1,\n        preferences: { ...this.defaultPreferences, ...userInfo.preferences }\n      };\n\n      // Store session and user data\n      await this.storeSession(session);\n      await this.storeUser(user);\n\n      this.currentSession = session;\n      this.currentUser = user;\n\n      // Notify listeners\n      this.notifyListeners('sessionCreated', { session, user });\n\n      return {\n        success: true,\n        session,\n        user\n      };\n\n    } catch (error) {\n      console.error('Failed to create session:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Load existing session\n   */\n  async loadSession() {\n    try {\n      const sessionData = localStorage.getItem(this.sessionKey);\n      const userData = localStorage.getItem(this.userKey);\n\n      if (!sessionData || !userData) {\n        return null;\n      }\n\n      const session = JSON.parse(sessionData);\n      const user = JSON.parse(userData);\n\n      // Check if session is expired\n      if (Date.now() > session.expires) {\n        await this.destroySession();\n        return null;\n      }\n\n      // Update last activity\n      session.lastActivity = Date.now();\n      await this.storeSession(session);\n\n      this.currentSession = session;\n      this.currentUser = user;\n\n      // Notify listeners\n      this.notifyListeners('sessionLoaded', { session, user });\n\n      return { session, user };\n\n    } catch (error) {\n      console.error('Failed to load session:', error);\n      // Clear corrupted session data\n      await this.destroySession();\n      return null;\n    }\n  }\n\n  /**\n   * Update session activity\n   */\n  async updateActivity() {\n    if (!this.currentSession) {\n      return false;\n    }\n\n    try {\n      this.currentSession.lastActivity = Date.now();\n\n      // Extend session if needed\n      const timeUntilExpiry = this.currentSession.expires - Date.now();\n      if (timeUntilExpiry < this.sessionTimeout * 0.1) { // Extend if less than 10% time left\n        this.currentSession.expires = Date.now() + this.sessionTimeout;\n      }\n\n      await this.storeSession(this.currentSession);\n      return true;\n\n    } catch (error) {\n      console.error('Failed to update session activity:', error);\n      return false;\n    }\n  }\n\n  /**\n   * Destroy current session\n   */\n  async destroySession() {\n    try {\n      const session = this.currentSession;\n      const user = this.currentUser;\n\n      // Clear session data\n      localStorage.removeItem(this.sessionKey);\n\n      this.currentSession = null;\n      this.currentUser = null;\n\n      // Notify listeners\n      this.notifyListeners('sessionDestroyed', { session, user });\n\n      return true;\n\n    } catch (error) {\n      console.error('Failed to destroy session:', error);\n      return false;\n    }\n  }\n\n  /**\n   * Get current session\n   */\n  getSession() {\n    return this.currentSession;\n  }\n\n  /**\n   * Get current user\n   */\n  getUser() {\n    return this.currentUser;\n  }\n\n  /**\n   * Check if user is authenticated\n   */\n  isAuthenticated() {\n    return !!(this.currentSession && Date.now() < this.currentSession.expires);\n  }\n\n  /**\n   * Get user preferences\n   */\n  getPreferences() {\n    return this.currentUser ? this.currentUser.preferences : this.defaultPreferences;\n  }\n\n  /**\n   * Update user preferences\n   */\n  async updatePreferences(newPreferences) {\n    if (!this.currentUser) {\n      throw new Error('No active user session');\n    }\n\n    try {\n      this.currentUser.preferences = {\n        ...this.currentUser.preferences,\n        ...newPreferences\n      };\n\n      await this.storeUser(this.currentUser);\n\n      // Also store preferences separately for quick access\n      localStorage.setItem(this.preferencesKey, JSON.stringify(this.currentUser.preferences));\n\n      // Notify listeners\n      this.notifyListeners('preferencesUpdated', { preferences: this.currentUser.preferences });\n\n      return this.currentUser.preferences;\n\n    } catch (error) {\n      console.error('Failed to update preferences:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Get session statistics\n   */\n  getSessionStats() {\n    if (!this.currentSession || !this.currentUser) {\n      return null;\n    }\n\n    const now = Date.now();\n    const sessionDuration = now - this.currentSession.created;\n    const timeUntilExpiry = this.currentSession.expires - now;\n    const lastActivityAge = now - this.currentSession.lastActivity;\n\n    return {\n      sessionId: this.currentSession.id,\n      userId: this.currentUser.id,\n      userName: this.currentUser.name,\n      sessionDuration,\n      timeUntilExpiry,\n      lastActivityAge,\n      loginCount: this.currentUser.loginCount,\n      userCreated: this.currentUser.created,\n      isExpired: timeUntilExpiry <= 0,\n      isActive: lastActivityAge < 5 * 60 * 1000 // Active if activity within 5 minutes\n    };\n  }\n\n  /**\n   * Export session data\n   */\n  async exportSessionData() {\n    if (!this.currentSession || !this.currentUser) {\n      return null;\n    }\n\n    return {\n      session: { ...this.currentSession },\n      user: { ...this.currentUser },\n      preferences: { ...this.currentUser.preferences },\n      exportTimestamp: Date.now()\n    };\n  }\n\n  /**\n   * Import session data\n   */\n  async importSessionData(sessionData) {\n    try {\n      if (!sessionData || !sessionData.session || !sessionData.user) {\n        throw new Error('Invalid session data format');\n      }\n\n      // Validate session data\n      const session = sessionData.session;\n      const user = sessionData.user;\n\n      // Update timestamps\n      session.lastActivity = Date.now();\n      session.expires = Date.now() + this.sessionTimeout;\n      user.lastLogin = Date.now();\n\n      // Store imported data\n      await this.storeSession(session);\n      await this.storeUser(user);\n\n      this.currentSession = session;\n      this.currentUser = user;\n\n      // Notify listeners\n      this.notifyListeners('sessionImported', { session, user });\n\n      return { success: true, session, user };\n\n    } catch (error) {\n      console.error('Failed to import session data:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Add session event listener\n   */\n  addEventListener(callback) {\n    this.listeners.add(callback);\n  }\n\n  /**\n   * Remove session event listener\n   */\n  removeEventListener(callback) {\n    this.listeners.delete(callback);\n  }\n\n  // Private methods\n\n  /**\n   * Store session data\n   */\n  async storeSession(session) {\n    try {\n      localStorage.setItem(this.sessionKey, JSON.stringify(session));\n    } catch (error) {\n      console.error('Failed to store session:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Store user data\n   */\n  async storeUser(user) {\n    try {\n      localStorage.setItem(this.userKey, JSON.stringify(user));\n    } catch (error) {\n      console.error('Failed to store user:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Generate unique session ID\n   */\n  generateSessionId() {\n    return 'sess_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);\n  }\n\n  /**\n   * Generate unique user ID\n   */\n  generateUserId() {\n    return 'user_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);\n  }\n\n  /**\n   * Setup session monitoring\n   */\n  setupSessionMonitoring() {\n    // Update activity on user interaction\n    const events = ['click', 'keypress', 'scroll', 'mousemove'];\n    let lastActivity = Date.now();\n\n    const throttledUpdate = this.throttle(() => {\n      const now = Date.now();\n      if (now - lastActivity > 60000) { // Update every minute\n        this.updateActivity();\n        lastActivity = now;\n      }\n    }, 1000);\n\n    events.forEach(event => {\n      document.addEventListener(event, throttledUpdate, { passive: true });\n    });\n\n    // Check session expiry periodically\n    setInterval(() => {\n      if (this.currentSession && Date.now() > this.currentSession.expires) {\n        this.destroySession();\n      }\n    }, 60000); // Check every minute\n\n    // Handle page visibility changes\n    document.addEventListener('visibilitychange', () => {\n      if (!document.hidden) {\n        this.updateActivity();\n      }\n    });\n\n    // Handle page unload\n    window.addEventListener('beforeunload', () => {\n      this.updateActivity();\n    });\n  }\n\n  /**\n   * Throttle function calls\n   */\n  throttle(func, limit) {\n    let inThrottle;\n    return function() {\n      const args = arguments;\n      const context = this;\n      if (!inThrottle) {\n        func.apply(context, args);\n        inThrottle = true;\n        setTimeout(() => inThrottle = false, limit);\n      }\n    };\n  }\n\n  /**\n   * Notify event listeners\n   */\n  notifyListeners(event, data) {\n    this.listeners.forEach(callback => {\n      try {\n        callback(event, data);\n      } catch (error) {\n        console.error('Error in session event listener:', error);\n      }\n    });\n  }\n}\n","/**\n * Persistence Manager - Central data persistence orchestrator\n * Manages multiple storage layers and provides unified API for data persistence\n */\n\nimport { DataMigrationService } from './DataMigrationService';\nimport { IndexedDBService } from './IndexedDBService';\nimport { LocalStorageService } from './LocalStorageService';\nimport { SessionManager } from './SessionManager';\n\nexport class PersistenceManager {\n  constructor() {\n    this.localStorage = new LocalStorageService();\n    this.indexedDB = new IndexedDBService();\n    this.sessionManager = new SessionManager();\n    this.migrationService = new DataMigrationService();\n\n    this.isInitialized = false;\n    this.storageQuota = null;\n    this.listeners = new Map();\n\n    // Storage strategy configuration\n    this.storageStrategy = {\n      // Small, frequently accessed data -> localStorage\n      localStorage: [\n        'user_preferences',\n        'session_data',\n        'ui_state',\n        'recent_commands',\n        'quick_settings'\n      ],\n      // Large, complex data -> IndexedDB\n      indexedDB: [\n        'watchlists',\n        'analysis_history',\n        'command_history',\n        'alerts',\n        'cached_data',\n        'user_models',\n        'export_data'\n      ]\n    };\n  }\n\n  /**\n   * Initialize the persistence manager\n   */\n  async initialize() {\n    if (this.isInitialized) return;\n\n    try {\n      // Check storage availability\n      await this.checkStorageAvailability();\n\n      // Initialize storage services\n      await Promise.all([\n        this.localStorage.initialize(),\n        this.indexedDB.initialize(),\n        this.sessionManager.initialize()\n      ]);\n\n      // Check for data migrations\n      await this.migrationService.checkAndMigrate();\n\n      // Estimate storage quota\n      await this.estimateStorageQuota();\n\n      this.isInitialized = true;\n      console.log('‚úÖ Persistence Manager initialized successfully');\n\n      return {\n        success: true,\n        storageQuota: this.storageQuota,\n        availableStorage: await this.getAvailableStorage()\n      };\n\n    } catch (error) {\n      console.error('‚ùå Failed to initialize Persistence Manager:', error);\n      throw new Error(`Persistence initialization failed: ${error.message}`);\n    }\n  }\n\n  /**\n   * Store data using appropriate storage layer\n   */\n  async store(key, data, options = {}) {\n    await this.ensureInitialized();\n\n    const {\n      storage = this.determineStorageLayer(key),\n      encrypt = false,\n      compress = false,\n      ttl = null\n    } = options;\n\n    try {\n      const metadata = {\n        timestamp: Date.now(),\n        version: '1.0',\n        encrypted: encrypt,\n        compressed: compress,\n        ttl,\n        size: JSON.stringify(data).length\n      };\n\n      let result;\n\n      if (storage === 'localStorage') {\n        result = await this.localStorage.store(key, data, { encrypt, ttl });\n      } else if (storage === 'indexedDB') {\n        result = await this.indexedDB.store(key, data, { metadata, compress });\n      } else {\n        throw new Error(`Unknown storage layer: ${storage}`);\n      }\n\n      // Notify listeners\n      this.notifyListeners('store', { key, storage, metadata });\n\n      return result;\n\n    } catch (error) {\n      console.error(`Failed to store data for key \"${key}\":`, error);\n      throw error;\n    }\n  }\n\n  /**\n   * Retrieve data from appropriate storage layer\n   */\n  async retrieve(key, options = {}) {\n    await this.ensureInitialized();\n\n    const {\n      storage = this.determineStorageLayer(key),\n      decrypt = false\n    } = options;\n\n    try {\n      let result;\n\n      if (storage === 'localStorage') {\n        result = await this.localStorage.retrieve(key, { decrypt });\n      } else if (storage === 'indexedDB') {\n        result = await this.indexedDB.retrieve(key);\n      } else {\n        // Try both storage layers\n        result = await this.localStorage.retrieve(key, { decrypt }) ||\n                 await this.indexedDB.retrieve(key);\n      }\n\n      // Check TTL if applicable\n      if (result && result.metadata && result.metadata.ttl) {\n        const now = Date.now();\n        const expiry = result.metadata.timestamp + result.metadata.ttl;\n\n        if (now > expiry) {\n          await this.remove(key, { storage });\n          return null;\n        }\n      }\n\n      return result ? result.data || result : null;\n\n    } catch (error) {\n      console.error(`Failed to retrieve data for key \"${key}\":`, error);\n      return null;\n    }\n  }\n\n  /**\n   * Remove data from storage\n   */\n  async remove(key, options = {}) {\n    await this.ensureInitialized();\n\n    const { storage = 'both' } = options;\n\n    try {\n      const promises = [];\n\n      if (storage === 'localStorage' || storage === 'both') {\n        promises.push(this.localStorage.remove(key));\n      }\n\n      if (storage === 'indexedDB' || storage === 'both') {\n        promises.push(this.indexedDB.remove(key));\n      }\n\n      await Promise.all(promises);\n\n      // Notify listeners\n      this.notifyListeners('remove', { key, storage });\n\n      return true;\n\n    } catch (error) {\n      console.error(`Failed to remove data for key \"${key}\":`, error);\n      throw error;\n    }\n  }\n\n  /**\n   * Clear all data from storage\n   */\n  async clear(options = {}) {\n    await this.ensureInitialized();\n\n    const { storage = 'both', confirm = false } = options;\n\n    if (!confirm) {\n      throw new Error('Clear operation requires explicit confirmation');\n    }\n\n    try {\n      const promises = [];\n\n      if (storage === 'localStorage' || storage === 'both') {\n        promises.push(this.localStorage.clear());\n      }\n\n      if (storage === 'indexedDB' || storage === 'both') {\n        promises.push(this.indexedDB.clear());\n      }\n\n      await Promise.all(promises);\n\n      // Notify listeners\n      this.notifyListeners('clear', { storage });\n\n      return true;\n\n    } catch (error) {\n      console.error('Failed to clear storage:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Get storage statistics\n   */\n  async getStorageStats() {\n    await this.ensureInitialized();\n\n    try {\n      const [localStorageStats, indexedDBStats] = await Promise.all([\n        this.localStorage.getStats(),\n        this.indexedDB.getStats()\n      ]);\n\n      const totalUsed = localStorageStats.used + indexedDBStats.used;\n      const totalAvailable = await this.getAvailableStorage();\n\n      return {\n        localStorage: localStorageStats,\n        indexedDB: indexedDBStats,\n        total: {\n          used: totalUsed,\n          available: totalAvailable,\n          quota: this.storageQuota,\n          usagePercentage: this.storageQuota ? (totalUsed / this.storageQuota) * 100 : 0\n        }\n      };\n\n    } catch (error) {\n      console.error('Failed to get storage stats:', error);\n      return null;\n    }\n  }\n\n  /**\n   * Export all user data\n   */\n  async exportData(options = {}) {\n    await this.ensureInitialized();\n\n    const {\n      format = 'json',\n      includeMetadata = true,\n      compress = false\n    } = options;\n\n    try {\n      const [localStorageData, indexedDBData] = await Promise.all([\n        this.localStorage.exportAll(),\n        this.indexedDB.exportAll()\n      ]);\n\n      const exportData = {\n        version: '1.0',\n        timestamp: new Date().toISOString(),\n        localStorage: localStorageData,\n        indexedDB: indexedDBData\n      };\n\n      if (includeMetadata) {\n        exportData.metadata = {\n          userAgent: navigator.userAgent,\n          storageStats: await this.getStorageStats(),\n          exportOptions: options\n        };\n      }\n\n      return {\n        data: exportData,\n        size: JSON.stringify(exportData).length,\n        format\n      };\n\n    } catch (error) {\n      console.error('Failed to export data:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Import user data\n   */\n  async importData(importData, options = {}) {\n    await this.ensureInitialized();\n\n    const {\n      overwrite = false,\n      validate = true,\n      backup = true\n    } = options;\n\n    try {\n      // Validate import data\n      if (validate && !this.validateImportData(importData)) {\n        throw new Error('Invalid import data format');\n      }\n\n      // Create backup if requested\n      if (backup) {\n        const backupData = await this.exportData();\n        await this.store('backup_before_import', backupData, {\n          storage: 'indexedDB',\n          ttl: 7 * 24 * 60 * 60 * 1000 // 7 days\n        });\n      }\n\n      // Import localStorage data\n      if (importData.localStorage) {\n        await this.localStorage.importData(importData.localStorage, { overwrite });\n      }\n\n      // Import IndexedDB data\n      if (importData.indexedDB) {\n        await this.indexedDB.importData(importData.indexedDB, { overwrite });\n      }\n\n      // Notify listeners\n      this.notifyListeners('import', { size: JSON.stringify(importData).length });\n\n      return {\n        success: true,\n        imported: {\n          localStorage: Object.keys(importData.localStorage || {}).length,\n          indexedDB: Object.keys(importData.indexedDB || {}).length\n        }\n      };\n\n    } catch (error) {\n      console.error('Failed to import data:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Add event listener for storage events\n   */\n  addEventListener(event, callback) {\n    if (!this.listeners.has(event)) {\n      this.listeners.set(event, new Set());\n    }\n    this.listeners.get(event).add(callback);\n  }\n\n  /**\n   * Remove event listener\n   */\n  removeEventListener(event, callback) {\n    if (this.listeners.has(event)) {\n      this.listeners.get(event).delete(callback);\n    }\n  }\n\n  // Private methods\n\n  async ensureInitialized() {\n    if (!this.isInitialized) {\n      await this.initialize();\n    }\n  }\n\n  determineStorageLayer(key) {\n    if (this.storageStrategy.localStorage.includes(key)) {\n      return 'localStorage';\n    }\n    if (this.storageStrategy.indexedDB.includes(key)) {\n      return 'indexedDB';\n    }\n    // Default to localStorage for small data\n    return 'localStorage';\n  }\n\n  async checkStorageAvailability() {\n    // Check localStorage\n    if (!window.localStorage) {\n      throw new Error('localStorage is not available');\n    }\n\n    // Check IndexedDB\n    if (!window.indexedDB) {\n      throw new Error('IndexedDB is not available');\n    }\n\n    return true;\n  }\n\n  async estimateStorageQuota() {\n    if ('storage' in navigator && 'estimate' in navigator.storage) {\n      const estimate = await navigator.storage.estimate();\n      this.storageQuota = estimate.quota;\n      return estimate;\n    }\n    return null;\n  }\n\n  async getAvailableStorage() {\n    if ('storage' in navigator && 'estimate' in navigator.storage) {\n      const estimate = await navigator.storage.estimate();\n      return estimate.quota - estimate.usage;\n    }\n    return null;\n  }\n\n  validateImportData(data) {\n    return data &&\n           typeof data === 'object' &&\n           data.version &&\n           (data.localStorage || data.indexedDB);\n  }\n\n  notifyListeners(event, data) {\n    if (this.listeners.has(event)) {\n      this.listeners.get(event).forEach(callback => {\n        try {\n          callback(data);\n        } catch (error) {\n          console.error('Error in storage event listener:', error);\n        }\n      });\n    }\n  }\n}\n\n// Export singleton instance\nexport const persistenceManager = new PersistenceManager();\n"],"names":["DataMigrationService","constructor","this","currentVersion","migrationKey","backupKey","migrations","to","description","migrate","migrateToV1_0_0","bind","checkAndMigrate","currentStoredVersion","localStorage","getItem","performVersionMigration","performInitialMigration","setItem","success","version","error","message","legacyData","detectLegacyData","Object","keys","length","createMigrationBackup","fromVersion","toVersion","migrationPath","findMigrationPath","Error","currentData","exportCurrentData","migration","restoreFromBackup","oldVariables","variables","JSON","parse","oldSettings","settings","oldWatchlists","watchlists","oldAlerts","alerts","forEach","key","startsWith","includes","e","dataToMigrate","migratedWatchlists","migrateWatchlistsFormat","stringify","migratedAlerts","migrateAlertsFormat","migratedPreferences","migratePreferencesFormat","migratedVariables","migrateVariablesFormat","cleanupLegacyData","migrated","Array","isArray","watchlist","index","name","tickers","stocks","created","Date","toISOString","split","lastUpdated","entries","data","map","alert","id","now","Math","random","ticker","condition","value","triggered","currency","precision","dateFormat","theme","notifications","autoSave","commandHistory","dataRetention","privacy","analytics","crashReporting","dataSharing","removeItem","backup","timestamp","backupData","getMigrationStatus","storedVersion","hasBackup","needsMigration","availableMigrations","clearBackup","CompressionUtils","compressionFormat","textEncoder","TextEncoder","textDecoder","TextDecoder","compress","window","compressWithStream","compressWithLZString","decompress","compressedData","isNativeCompressed","decompressWithStream","decompressWithLZString","stream","CompressionStream","writer","writable","getWriter","reader","readable","getReader","dataBuffer","encode","write","close","chunks","done","readerDone","read","push","totalLength","reduce","sum","chunk","combined","Uint8Array","offset","set","arrayBufferToBase64","buffer","replace","compressedBuffer","base64ToArrayBuffer","DecompressionStream","decode","dictionary","Map","result","dictSize","i","String","fromCharCode","current","char","has","get","compressed","Uint16Array","previous","code","isLZStringCompressed","isCompressed","getCompressionRatio","originalData","originalSize","Blob","size","estimateCompressionBenefit","compressedSize","ratio","savings","savingsPercentage","worthCompressing","isAvailable","getInfo","nativeCompressionAvailable","fallbackAvailable","defaultFormat","available","performanceTest","testData","test","fill","repeat","numbers","_","compressStart","performance","compressTime","decompressStart","decompressTime","compressionRatio","totalTime","iterations","method","bytes","binary","byteLength","btoa","base64","atob","charCodeAt","IndexedDBService","dbName","dbVersion","db","compressionUtils","stores","keyPath","autoIncrement","indexes","unique","analysis_history","command_history","cached_data","user_models","export_data","initialize","indexedDB","openDatabase","cleanupExpiredData","Promise","resolve","reject","request","open","onerror","onsuccess","onupgradeneeded","event","target","createObjectStores","storeName","objectStoreNames","contains","deleteObjectStore","config","store","createObjectStore","createIndex","options","metadata","dataObject","performTransaction","put","retrieve","expiry","remove","delete","clear","storeObj","getKeys","getAllKeys","getAll","limit","filter","results","filteredResults","slice","query","indexName","getStats","total","records","stats","recordCount","storeSize","record","exportAll","exportData","importData","overwrite","imported","skipped","errors","cleaned","cachedData","mode","operation","transaction","objectStore","oncomplete","isStorageAvailable","storeCount","CryptoUtils","algorithm","keyLength","ivLength","tagLength","initializeKey","storedKey","keyData","cryptoKey","crypto","subtle","importKey","generateKey","exportedKey","exportKey","keyString","encrypt","iv","getRandomValues","encryptedBuffer","decrypt","encryptedData","decryptedBuffer","hash","hashBuffer","digest","verifyIntegrity","expectedHash","generateRandomString","array","substring","deriveKeyFromPassword","password","salt","passwordBuffer","saltBuffer","keyMaterial","deriveKey","keyInitialized","clearSensitiveData","ArrayBuffer","view","encryptStart","encrypted","encryptTime","decryptStart","decryptTime","dataSize","encryptedSize","LocalStorageService","prefix","maxSize","cryptoUtils","testKey","ttl","validate","validateData","storageObject","serializedData","storageKey","validateTTL","parseError","decompressed","decompressError","used","totalSize","itemCount","itemSizes","usagePercentage","largestItem","max","hasSpace","cleanup","seen","WeakSet","checkCircular","obj","add","writeStart","writeTime","readStart","readTime","SessionManager","sessionKey","userKey","preferencesKey","currentSession","currentUser","sessionTimeout","listeners","Set","defaultPreferences","loadSession","setupSessionMonitoring","hasSession","createSession","userInfo","sessionId","generateSessionId","session","userId","generateUserId","lastActivity","expires","userAgent","navigator","platform","language","timezone","Intl","DateTimeFormat","resolvedOptions","timeZone","user","email","lastLogin","loginCount","preferences","storeSession","storeUser","notifyListeners","sessionData","userData","destroySession","updateActivity","getSession","getUser","isAuthenticated","getPreferences","updatePreferences","newPreferences","getSessionStats","sessionDuration","timeUntilExpiry","lastActivityAge","userName","userCreated","isExpired","isActive","exportSessionData","exportTimestamp","importSessionData","addEventListener","callback","removeEventListener","toString","substr","throttledUpdate","throttle","document","passive","setInterval","hidden","func","inThrottle","args","arguments","apply","setTimeout","persistenceManager","sessionManager","migrationService","isInitialized","storageQuota","storageStrategy","checkStorageAvailability","all","estimateStorageQuota","availableStorage","getAvailableStorage","ensureInitialized","storage","determineStorageLayer","promises","confirm","getStorageStats","localStorageStats","indexedDBStats","totalUsed","quota","format","includeMetadata","localStorageData","indexedDBData","storageStats","exportOptions","validateImportData","estimate","usage"],"mappings":"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"}